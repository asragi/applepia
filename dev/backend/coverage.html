
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>admin: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/asragi/RinGo/admin/check_is_admin.go (80.0%)</option>
				
				<option value="file1">github.com/asragi/RinGo/admin/login.go (100.0%)</option>
				
				<option value="file2">github.com/asragi/RinGo/admin/register.go (71.4%)</option>
				
				<option value="file3">github.com/asragi/RinGo/auth/base64.go (83.3%)</option>
				
				<option value="file4">github.com/asragi/RinGo/auth/errors.go (0.0%)</option>
				
				<option value="file5">github.com/asragi/RinGo/auth/login.go (0.0%)</option>
				
				<option value="file6">github.com/asragi/RinGo/auth/models.go (42.9%)</option>
				
				<option value="file7">github.com/asragi/RinGo/auth/register.go (0.0%)</option>
				
				<option value="file8">github.com/asragi/RinGo/auth/token.go (0.0%)</option>
				
				<option value="file9">github.com/asragi/RinGo/auth/validate_token.go (0.0%)</option>
				
				<option value="file10">github.com/asragi/RinGo/cmd/database.go (0.0%)</option>
				
				<option value="file11">github.com/asragi/RinGo/cmd/server.go (0.0%)</option>
				
				<option value="file12">github.com/asragi/RinGo/core/decide_initial_name.go (0.0%)</option>
				
				<option value="file13">github.com/asragi/RinGo/core/errors.go (66.7%)</option>
				
				<option value="file14">github.com/asragi/RinGo/core/game/calc_consumed_item_service.go (100.0%)</option>
				
				<option value="file15">github.com/asragi/RinGo/core/game/calc_consuming_stamina_service.go (91.7%)</option>
				
				<option value="file16">github.com/asragi/RinGo/core/game/calc_earned_item_service.go (100.0%)</option>
				
				<option value="file17">github.com/asragi/RinGo/core/game/calc_skill_growth_service.go (100.0%)</option>
				
				<option value="file18">github.com/asragi/RinGo/core/game/calc_stamina_reduction.go (100.0%)</option>
				
				<option value="file19">github.com/asragi/RinGo/core/game/calc_total_item_service.go (100.0%)</option>
				
				<option value="file20">github.com/asragi/RinGo/core/game/calc_total_skill_growth_service.go (95.2%)</option>
				
				<option value="file21">github.com/asragi/RinGo/core/game/errors.go (0.0%)</option>
				
				<option value="file22">github.com/asragi/RinGo/core/game/explore/DIContainer.go (0.0%)</option>
				
				<option value="file23">github.com/asragi/RinGo/core/game/explore/get_common_action.go (84.4%)</option>
				
				<option value="file24">github.com/asragi/RinGo/core/game/explore/get_item_action_detail_service.go (69.2%)</option>
				
				<option value="file25">github.com/asragi/RinGo/core/game/explore/get_item_detail_service.go (71.8%)</option>
				
				<option value="file26">github.com/asragi/RinGo/core/game/explore/get_resource_service.go (71.4%)</option>
				
				<option value="file27">github.com/asragi/RinGo/core/game/explore/get_stage_action_detail_service.go (0.0%)</option>
				
				<option value="file28">github.com/asragi/RinGo/core/game/explore/get_stage_list_service.go (64.5%)</option>
				
				<option value="file29">github.com/asragi/RinGo/core/game/explore/models.go (0.0%)</option>
				
				<option value="file30">github.com/asragi/RinGo/core/game/explore/repositories.go (0.0%)</option>
				
				<option value="file31">github.com/asragi/RinGo/core/game/get_item_list_service.go (86.7%)</option>
				
				<option value="file32">github.com/asragi/RinGo/core/game/make_user_explores.go (85.3%)</option>
				
				<option value="file33">github.com/asragi/RinGo/core/game/models.go (70.0%)</option>
				
				<option value="file34">github.com/asragi/RinGo/core/game/post_action_service.go (70.6%)</option>
				
				<option value="file35">github.com/asragi/RinGo/core/game/repositories.go (30.6%)</option>
				
				<option value="file36">github.com/asragi/RinGo/core/game/repositories_helper.go (0.0%)</option>
				
				<option value="file37">github.com/asragi/RinGo/core/game/services.go (0.0%)</option>
				
				<option value="file38">github.com/asragi/RinGo/core/game/shelf/calc_purchase.go (0.0%)</option>
				
				<option value="file39">github.com/asragi/RinGo/core/game/shelf/get_shelf.go (88.6%)</option>
				
				<option value="file40">github.com/asragi/RinGo/core/game/shelf/initialize_shelf.go (0.0%)</option>
				
				<option value="file41">github.com/asragi/RinGo/core/game/shelf/models.go (0.0%)</option>
				
				<option value="file42">github.com/asragi/RinGo/core/game/shelf/ranking/fetch_user_ranking.go (85.7%)</option>
				
				<option value="file43">github.com/asragi/RinGo/core/game/shelf/ranking/models.go (100.0%)</option>
				
				<option value="file44">github.com/asragi/RinGo/core/game/shelf/ranking/on_change_period.go (76.5%)</option>
				
				<option value="file45">github.com/asragi/RinGo/core/game/shelf/ranking/services.go (0.0%)</option>
				
				<option value="file46">github.com/asragi/RinGo/core/game/shelf/ranking/update_total_score.go (86.5%)</option>
				
				<option value="file47">github.com/asragi/RinGo/core/game/shelf/repositories.go (66.7%)</option>
				
				<option value="file48">github.com/asragi/RinGo/core/game/shelf/reservation/apply_all_reservations.go (0.0%)</option>
				
				<option value="file49">github.com/asragi/RinGo/core/game/shelf/reservation/apply_reservation.go (81.4%)</option>
				
				<option value="file50">github.com/asragi/RinGo/core/game/shelf/reservation/auto_insert_reservation.go (0.0%)</option>
				
				<option value="file51">github.com/asragi/RinGo/core/game/shelf/reservation/calc_reservation_application.go (95.4%)</option>
				
				<option value="file52">github.com/asragi/RinGo/core/game/shelf/reservation/create_reservation.go (53.3%)</option>
				
				<option value="file53">github.com/asragi/RinGo/core/game/shelf/reservation/insert_reservation.go (23.1%)</option>
				
				<option value="file54">github.com/asragi/RinGo/core/game/shelf/reservation/models.go (74.0%)</option>
				
				<option value="file55">github.com/asragi/RinGo/core/game/shelf/reservation/repositories.go (96.0%)</option>
				
				<option value="file56">github.com/asragi/RinGo/core/game/shelf/services.go (0.0%)</option>
				
				<option value="file57">github.com/asragi/RinGo/core/game/shelf/update_on_apply_trade.go (0.0%)</option>
				
				<option value="file58">github.com/asragi/RinGo/core/game/shelf/update_shelf_content.go (86.4%)</option>
				
				<option value="file59">github.com/asragi/RinGo/core/game/shelf/update_shelf_on_purchase.go (0.0%)</option>
				
				<option value="file60">github.com/asragi/RinGo/core/game/shelf/update_shelf_size.go (0.0%)</option>
				
				<option value="file61">github.com/asragi/RinGo/core/game/shelf/validate_purchase.go (0.0%)</option>
				
				<option value="file62">github.com/asragi/RinGo/core/game/shelf/validate_update_shelf_content.go (0.0%)</option>
				
				<option value="file63">github.com/asragi/RinGo/core/game/shelf/validate_update_shelf_size.go (0.0%)</option>
				
				<option value="file64">github.com/asragi/RinGo/core/game/validate_action_service.go (26.5%)</option>
				
				<option value="file65">github.com/asragi/RinGo/core/models.go (27.9%)</option>
				
				<option value="file66">github.com/asragi/RinGo/core/services.go (0.0%)</option>
				
				<option value="file67">github.com/asragi/RinGo/core/update_shop_name.go (0.0%)</option>
				
				<option value="file68">github.com/asragi/RinGo/core/update_user_name.go (0.0%)</option>
				
				<option value="file69">github.com/asragi/RinGo/core/utils.go (0.0%)</option>
				
				<option value="file70">github.com/asragi/RinGo/crypto/crypto.go (0.0%)</option>
				
				<option value="file71">github.com/asragi/RinGo/crypto/sha256.go (83.3%)</option>
				
				<option value="file72">github.com/asragi/RinGo/database/database.go (60.2%)</option>
				
				<option value="file73">github.com/asragi/RinGo/debug/add_initial_period.go (83.3%)</option>
				
				<option value="file74">github.com/asragi/RinGo/debug/mode.go (0.0%)</option>
				
				<option value="file75">github.com/asragi/RinGo/debug/timer.go (100.0%)</option>
				
				<option value="file76">github.com/asragi/RinGo/endpoint/admin_login.go (85.7%)</option>
				
				<option value="file77">github.com/asragi/RinGo/endpoint/auto_insert_reservation.go (5.6%)</option>
				
				<option value="file78">github.com/asragi/RinGo/endpoint/change_period.go (68.8%)</option>
				
				<option value="file79">github.com/asragi/RinGo/endpoint/change_time.go (73.3%)</option>
				
				<option value="file80">github.com/asragi/RinGo/endpoint/get_item_action_detail.go (82.4%)</option>
				
				<option value="file81">github.com/asragi/RinGo/endpoint/get_item_detail.go (83.3%)</option>
				
				<option value="file82">github.com/asragi/RinGo/endpoint/get_item_list.go (83.3%)</option>
				
				<option value="file83">github.com/asragi/RinGo/endpoint/get_my_shelves.go (80.0%)</option>
				
				<option value="file84">github.com/asragi/RinGo/endpoint/get_ranking_user_list.go (83.3%)</option>
				
				<option value="file85">github.com/asragi/RinGo/endpoint/get_resource.go (76.9%)</option>
				
				<option value="file86">github.com/asragi/RinGo/endpoint/get_stage_action_detail.go (80.0%)</option>
				
				<option value="file87">github.com/asragi/RinGo/endpoint/get_stage_list.go (86.4%)</option>
				
				<option value="file88">github.com/asragi/RinGo/endpoint/login.go (85.7%)</option>
				
				<option value="file89">github.com/asragi/RinGo/endpoint/post_action.go (89.3%)</option>
				
				<option value="file90">github.com/asragi/RinGo/endpoint/register.go (75.0%)</option>
				
				<option value="file91">github.com/asragi/RinGo/endpoint/update_shelf_content.go (81.8%)</option>
				
				<option value="file92">github.com/asragi/RinGo/endpoint/update_shelf_size.go (78.6%)</option>
				
				<option value="file93">github.com/asragi/RinGo/endpoint/update_shop_name.go (73.3%)</option>
				
				<option value="file94">github.com/asragi/RinGo/endpoint/update_user_name.go (73.3%)</option>
				
				<option value="file95">github.com/asragi/RinGo/infrastructure/helper.go (100.0%)</option>
				
				<option value="file96">github.com/asragi/RinGo/infrastructure/in_memory/in_memory.go (100.0%)</option>
				
				<option value="file97">github.com/asragi/RinGo/infrastructure/mysql/admin.go (0.0%)</option>
				
				<option value="file98">github.com/asragi/RinGo/infrastructure/mysql/core.go (0.0%)</option>
				
				<option value="file99">github.com/asragi/RinGo/infrastructure/mysql/mysql.go (81.2%)</option>
				
				<option value="file100">github.com/asragi/RinGo/infrastructure/mysql/ranking.go (20.3%)</option>
				
				<option value="file101">github.com/asragi/RinGo/infrastructure/mysql/reservation.go (87.5%)</option>
				
				<option value="file102">github.com/asragi/RinGo/infrastructure/mysql/shelf.go (36.4%)</option>
				
				<option value="file103">github.com/asragi/RinGo/initialize/common.go (100.0%)</option>
				
				<option value="file104">github.com/asragi/RinGo/initialize/wire_gen.go (100.0%)</option>
				
				<option value="file105">github.com/asragi/RinGo/location/location.go (100.0%)</option>
				
				<option value="file106">github.com/asragi/RinGo/server/grpc.go (84.6%)</option>
				
				<option value="file107">github.com/asragi/RinGo/server/initialize.go (92.9%)</option>
				
				<option value="file108">github.com/asragi/RinGo/test/dockertest.go (66.7%)</option>
				
				<option value="file109">github.com/asragi/RinGo/test/utils.go (50.0%)</option>
				
				<option value="file110">github.com/asragi/RinGo/utils/context.go (0.0%)</option>
				
				<option value="file111">github.com/asragi/RinGo/utils/json.go (80.0%)</option>
				
				<option value="file112">github.com/asragi/RinGo/utils/math.go (83.3%)</option>
				
				<option value="file113">github.com/asragi/RinGo/utils/set.go (45.8%)</option>
				
				<option value="file114">github.com/asragi/RinGo/utils/string_to_time.go (0.0%)</option>
				
				<option value="file115">github.com/asragi/RinGo/utils/to_obj.go (0.0%)</option>
				
				<option value="file116">github.com/asragi/RinGo/utils/uuid.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package admin

import (
        "context"
        "errors"
        "fmt"
        "github.com/asragi/RinGo/core"
)

var NotAdminError = errors.New("user is not admin")

type CheckIsAdminFunc func(context.Context, core.UserId) (bool, error)

func CreateCheckIsAdmin(
        checkIsAdminRepo CheckIsAdminRepo,
) CheckIsAdminFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId) (bool, error) </span><span class="cov8" title="1">{
                isAdmin, err := checkIsAdminRepo(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("error on check is admin: %w", err)
                }</span>
                <span class="cov8" title="1">return isAdmin, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package admin

import (
        "context"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
)

type CreateCommonLoginFunc func(
        fetchHashedPassword auth.FetchHashedPassword,
        comparePassword auth.CompareHashedPassword,
        createToken auth.CreateTokenFunc,
) auth.LoginFunc

type LoginFunc func(context.Context, core.UserId, auth.RowPassword) (auth.AccessToken, error)

func CreateLogin(
        fetchHashedPassword FetchHashedPassword,
        comparePassword auth.CompareHashedPassword,
        createToken auth.CreateTokenFunc,
        createLogin CreateCommonLoginFunc,
) LoginFunc <span class="cov8" title="1">{
        fetchPassword := auth.FetchHashedPassword(fetchHashedPassword)
        f := createLogin(fetchPassword, comparePassword, createToken)
        return LoginFunc(f)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package admin

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
)

type RegisterFunc func(context.Context, core.UserId, auth.RowPassword) error

func CreateRegister(
        registerRepo RegisterRepo,
        createHashedPassword auth.CreateHashedPasswordFunc,
) RegisterFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId, password auth.RowPassword) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("register admin: %w", err)
                }</span>
                <span class="cov8" title="1">hashedPassword, err := createHashedPassword(password)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return registerRepo(ctx, userId, hashedPassword)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "encoding/base64"
        "fmt"
)

type Base64EncodeFunc func(string) string

func StringToBase64(text string) string <span class="cov8" title="1">{
        src := []byte(text)
        return base64.StdEncoding.EncodeToString(src)
}</span>

type Base64DecodeFunc func(string) (string, error)

func Base64ToString(base64Text string) (string, error) <span class="cov8" title="1">{
        dec, err := base64.StdEncoding.DecodeString(base64Text)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("decode base64: %w", err)
        }</span>
        <span class="cov8" title="1">return string(dec), nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "errors"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type TokenWasExpiredError struct {
        token *AccessToken
}

func (e *TokenWasExpiredError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("token was expired: %s", string(*e.token))
}</span>

var UserAlreadyExistsError = errors.New("user already exists")

func CreateUserAlreadyExistsError(id core.UserId) error <span class="cov0" title="0">{
        return errors.New(fmt.Sprintf("user id already exists: %s", id))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type LoginFunc func(context.Context, core.UserId, RowPassword) (AccessToken, error)
type CompareHashedPassword func(hash, password string) error

func CreateLoginFunc(
        fetchHashedPassword FetchHashedPassword,
        comparePassword CompareHashedPassword,
        createToken CreateTokenFunc,
) LoginFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, rowPass RowPassword) (AccessToken, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (AccessToken, error) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("login: %w", err)
                }</span>
                <span class="cov0" title="0">hashedPass, err := fetchHashedPassword(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">err = comparePassword(string(hashedPass), string(rowPass))
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return createToken(userId)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

type RowPassword string

func NewRowPassword(password string) RowPassword <span class="cov0" title="0">{
        return RowPassword(password)
}</span>

func (p RowPassword) String() string <span class="cov0" title="0">{
        return string(p)
}</span>

type RowPasswordGenerator func() string

func GenerateRowPassword(gen RowPasswordGenerator) CreateRowPasswordFunc <span class="cov0" title="0">{
        return func() RowPassword </span><span class="cov0" title="0">{ return NewRowPassword(gen()) }</span>
}

type CreateRowPasswordFunc func() RowPassword
type HashedPassword string
type SecretHashKey string
type CreateHashedPasswordFunc func(RowPassword) (HashedPassword, error)

type EncryptFunc func(string) (string, error)

func CreateHashedPassword(encrypt EncryptFunc) CreateHashedPasswordFunc <span class="cov8" title="1">{
        return func(password RowPassword) (HashedPassword, error) </span><span class="cov8" title="1">{
                passwordString, err := encrypt(string(password))
                return HashedPassword(passwordString), err
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type registerResult struct {
        UserId   core.UserId
        Password RowPassword
}

type createUserIdFunc func(context.Context) (core.UserId, error)

type CreateUserIdChallengeNum int

func CreateUserId(
        challengeNum CreateUserIdChallengeNum,
        checkUser core.CheckDoesUserExist,
        generate core.GenerateUUIDFunc,
) createUserIdFunc <span class="cov0" title="0">{
        f := func(ctx context.Context) (core.UserId, error) </span><span class="cov0" title="0">{
                var err error
                for i := 0; i &lt; int(challengeNum); i++ </span><span class="cov0" title="0">{
                        userId := core.UserId(generate())
                        err = checkUser(ctx, userId)
                        if err == nil </span><span class="cov0" title="0">{
                                return userId, nil
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("creating user id was failed: %w", err)</span>
        }
        <span class="cov0" title="0">return f</span>
}

type RegisterUserFunc func(context.Context) (registerResult, error)

func RegisterUser(
        generateUserId createUserIdFunc,
        generateRowPassword CreateRowPasswordFunc,
        createHashedPassword CreateHashedPasswordFunc,
        insertNewUser InsertNewUser,
        decideName core.DecideInitialName,
        decideShopName core.DecideInitialShopName,
) RegisterUserFunc <span class="cov0" title="0">{
        f := func(ctx context.Context) (registerResult, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (registerResult, error) </span><span class="cov0" title="0">{
                        return registerResult{}, fmt.Errorf("register user: %w", err)
                }</span>
                <span class="cov0" title="0">userId, err := generateUserId(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">rowPass := generateRowPassword()
                hashedPass, err := createHashedPassword(rowPass)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">initialName := decideName()
                initialShopName := decideShopName()
                err = insertNewUser(ctx, userId, initialName, initialShopName, hashedPass)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return registerResult{
                        UserId:   userId,
                        Password: rowPass,
                }, nil</span>
        }
        <span class="cov0" title="0">return f</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/crypto"
        "github.com/asragi/RinGo/utils"
        "strings"
)

type CreateTokenFunc func(core.UserId) (AccessToken, error)

// TODO: remove "*"
type Sha256Func func(SecretHashKey, string) (string, error)

func CryptWithSha256(key SecretHashKey, text string) (string, error) <span class="cov0" title="0">{
        keyString := string(key)
        return crypto.SHA256WithKey(keyString, text)
}</span>

type AccessToken string

func NewAccessToken(token string) (AccessToken, error) <span class="cov0" title="0">{
        if len(token) &lt;= 0 </span><span class="cov0" title="0">{
                return "", TokenIsInvalidError{token: AccessToken(token)}
        }</span>
        <span class="cov0" title="0">return AccessToken(token), nil</span>
}

func (token *AccessToken) String() string <span class="cov0" title="0">{
        return string(*token)
}</span>

type ExpirationTime int
type AccessTokenInformation struct {
        UserId         core.UserId
        ExpirationTime ExpirationTime
}

type AccessTokenInformationFromJson struct {
        UserId         string `json:"UserId"`
        ExpirationTime int    `json:"ExpirationTime"`
}

func (info *AccessTokenInformationFromJson) ToInformation() (*AccessTokenInformation, error) <span class="cov0" title="0">{
        userId, err := core.NewUserId(info.UserId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode request: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;AccessTokenInformation{
                UserId:         userId,
                ExpirationTime: ExpirationTime(info.ExpirationTime),
        }, nil</span>
}

func CreateTokenFuncEmitter(
        base64Encode Base64EncodeFunc,
        getTime core.GetCurrentTimeFunc,
        jsonFunc utils.StructToJsonFunc[AccessTokenInformation],
        secret SecretHashKey,
        sha256 Sha256Func,
) CreateTokenFunc <span class="cov0" title="0">{
        return func(userId core.UserId) (AccessToken, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (AccessToken, error) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("create token: %w", err)
                }</span>
                <span class="cov0" title="0">nowTime := getTime()
                header := `{ alg: 'HS256', typ: 'JWT' }`
                info := &amp;AccessTokenInformation{
                        UserId:         userId,
                        ExpirationTime: ExpirationTime(nowTime.Unix()),
                }
                payload, err := jsonFunc(info)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">unsignedToken := fmt.Sprintf("%s.%s", base64Encode(header), base64Encode(*payload))
                signature, err := sha256(secret, unsignedToken)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">jwt := fmt.Sprintf("%s.%s", unsignedToken, signature)
                token := AccessToken(jwt)
                return token, nil</span>
        }
}

type GetTokenInformationFunc func(token *AccessToken) (*AccessTokenInformation, error)

func CreateGetTokenInformation(
        decodeBase64 Base64DecodeFunc,
        unmarshalJson utils.JsonToStructFunc[AccessTokenInformationFromJson],
) GetTokenInformationFunc <span class="cov0" title="0">{
        return func(token *AccessToken) (*AccessTokenInformation, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (*AccessTokenInformation, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("get token info: %w", err)
                }</span>
                <span class="cov0" title="0">tokenString := string(*token)
                splitToken := strings.Split(tokenString, ".")
                if len(splitToken) != 3 </span><span class="cov0" title="0">{
                        return nil, TokenIsInvalidError{token: *token}
                }</span>
                <span class="cov0" title="0">payloadString := splitToken[1]
                payloadJsonString, err := decodeBase64(payloadString)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov0" title="0">tokenInfo, err := unmarshalJson(payloadJsonString)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">info, err := tokenInfo.ToInformation()
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return info, nil</span>
        }
}

type CompareToken func(token *AccessToken) error

func CreateCompareToken(key SecretHashKey, sha256 Sha256Func) CompareToken <span class="cov0" title="0">{
        return func(token *AccessToken) error </span><span class="cov0" title="0">{
                if len(*token) &lt;= 0 </span><span class="cov0" title="0">{
                        return TokenIsInvalidError{token: *token}
                }</span>
                <span class="cov0" title="0">tokenString := string(*token)
                splitToken := strings.Split(tokenString, ".")
                if len(splitToken) != 3 </span><span class="cov0" title="0">{
                        return TokenIsInvalidError{token: *token}
                }</span>
                <span class="cov0" title="0">unsignedSignature := fmt.Sprintf("%s.%s", splitToken[0], splitToken[1])
                signature := splitToken[2]
                hashedUnsignedToken, err := sha256(key, unsignedSignature)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("compare token: %w", err)
                }</span>
                <span class="cov0" title="0">if hashedUnsignedToken != signature </span><span class="cov0" title="0">{
                        return TokenIsInvalidError{token: *token}
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func (token *AccessToken) GetInformation(getInfo GetTokenInformationFunc) (*AccessTokenInformation, error) <span class="cov0" title="0">{
        return getInfo(token)
}</span>

func (token *AccessToken) IsValid(compare CompareToken) error <span class="cov0" title="0">{
        return compare(token)
}</span>

type TokenIsInvalidError struct {
        token AccessToken
}

func (e TokenIsInvalidError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("token is invalid: %s", e.token)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package auth

import "fmt"

type ValidateTokenFunc func(*AccessToken) (*AccessTokenInformation, error)

func CreateValidateToken(compare CompareToken, informationFunc GetTokenInformationFunc) ValidateTokenFunc <span class="cov0" title="0">{
        return func(token *AccessToken) (*AccessTokenInformation, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (*AccessTokenInformation, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("validate token: %w", err)
                }</span>
                <span class="cov0" title="0">err := token.IsValid(compare)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">info, err := token.GetInformation(informationFunc)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return info, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "fmt"
        "github.com/asragi/RinGo/database"
        "os"
        "time"
)

// getEnvOrError は環境変数を取得し、未設定の場合はエラーを返す
func getEnvOrError(key string) (string, error) <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("環境変数 %s が設定されていません", key)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func CreateDB() (*database.DBAccessor, error) <span class="cov0" title="0">{
        // 環境変数から設定を取得
        dbHost, err := getEnvOrError("DB_HOST")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dbPort, err := getEnvOrError("DB_PORT")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dbUser, err := getEnvOrError("DB_USER")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dbPassword, err := getEnvOrError("DB_PASSWORD")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dbName, err := getEnvOrError("DB_NAME")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dbSettings := &amp;database.ConnectionSettings{
                UserName: dbUser,
                Password: dbPassword,
                Port:     dbPort,
                Protocol: "tcp",
                Host:     dbHost,
                Database: dbName,
        }
        db, err := database.ConnectDB(dbSettings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connect DB: %w", err)
        }</span>
        <span class="cov0" title="0">db.SetMaxOpenConns(10)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(5 * time.Minute)
        db.SetConnMaxIdleTime(4 * time.Minute)
        return database.NewDBAccessor(db, db), nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/initialize"
        "github.com/asragi/RinGo/server"
        "log"
        "strconv"
)

func main() <span class="cov0" title="0">{
        handleError := func(err error) </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>

        // 環境変数からSECRET_KEYを取得
        <span class="cov0" title="0">secretKeyStr, err := getEnvOrError("SECRET_KEY")
        if err != nil </span><span class="cov0" title="0">{
                handleError(err)
                return
        }</span>
        <span class="cov0" title="0">secretKey := auth.SecretHashKey(secretKeyStr)

        // 環境変数からSERVER_PORTを取得
        serverPortStr, err := getEnvOrError("SERVER_PORT")
        if err != nil </span><span class="cov0" title="0">{
                handleError(err)
                return
        }</span>
        <span class="cov0" title="0">serverPort, err := strconv.Atoi(serverPortStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("SERVER_PORT の値が不正です: %v", err)
                return
        }</span>

        <span class="cov0" title="0">constants := &amp;initialize.Constants{
                InitialFund:        core.Fund(100000),
                InitialMaxStamina:  core.MaxStamina(6000),
                InitialPopularity:  shelf.ShopPopularity(0),
                UserIdChallengeNum: 3,
        }

        db, err := CreateDB()
        if err != nil </span><span class="cov0" title="0">{
                handleError(err)
                return
        }</span>

        <span class="cov0" title="0">endpoints := initialize.CreateEndpoints(secretKey, constants, db.Exec, db.Query)
        log.Printf("Starting gRPC server on port %d...", serverPort)
        serve, stopDB, err := server.SetUpServer(serverPort, endpoints)
        if err != nil </span><span class="cov0" title="0">{
                handleError(err)
                return
        }</span>
        <span class="cov0" title="0">defer stopDB()

        log.Printf("gRPC server is listening on port %d", serverPort)
        err = serve()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("gRPC Server Error: %v", err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package core

type DecideInitialName func() Name
type DecideInitialShopName func() Name

// TODO: initial name must be decided depending on locale
func CreateDecideInitialName() DecideInitialName <span class="cov0" title="0">{
        return func() Name </span><span class="cov0" title="0">{
                return "夢追い人"
        }</span>
}

func CreateDecideInitialShopName() DecideInitialShopName <span class="cov0" title="0">{
        return func() Name </span><span class="cov0" title="0">{
                return "夢追い人の店"
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import (
        "errors"
        "fmt"
)

var InvalidUserIdError = errors.New("invalid user id")

func ThrowInvalidUserIdError(userId string) error <span class="cov8" title="1">{
        return fmt.Errorf("user id is invalid: %s: %w", userId, InvalidUserIdError)
}</span>

type UserIdIsInvalidError struct {
        userId UserId
}

func (e UserIdIsInvalidError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("id is invalid: %s", e.userId)
}</span>

type InternalServerError struct {
        Message string
}

func (e InternalServerError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("internal server error: %s", e.Message)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package game

import (
        "github.com/asragi/RinGo/core"
)

type ConsumedItem struct {
        ItemId core.ItemId
        Count  core.Count
}

type CalcConsumedItemFunc func(int, []*ConsumingItem, core.EmitRandomFunc) []*ConsumedItem

func CalcConsumedItem(
        execCount int,
        consumingItem []*ConsumingItem,
        random core.EmitRandomFunc,
) []*ConsumedItem <span class="cov8" title="1">{
        simMultipleItemCount := func(
                maxCount core.Count,
                random core.EmitRandomFunc,
                consumptionProb ConsumptionProb,
                execCount int,
        ) core.Count </span><span class="cov8" title="1">{
                result := 0
                // TODO: using approximation to avoid using "for" statement
                for i := 0; i &lt; execCount*int(maxCount); i++ </span><span class="cov8" title="1">{
                        rand := random()
                        if rand &lt; float32(consumptionProb) </span><span class="cov8" title="1">{
                                result += 1
                        }</span>
                }
                <span class="cov8" title="1">return core.Count(result)</span>
        }
        <span class="cov8" title="1">var result []*ConsumedItem
        for _, v := range consumingItem </span><span class="cov8" title="1">{
                consumedItemStruct := ConsumedItem{
                        ItemId: v.ItemId,
                        Count:  simMultipleItemCount(v.MaxCount, random, v.ConsumptionProb, execCount),
                }
                result = append(result, &amp;consumedItemStruct)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package game

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type ExploreStaminaPair struct {
        ExploreId      ActionId
        ReducedStamina core.StaminaCost
}

type CalcConsumingStaminaFunc func(
        context.Context,
        core.UserId,
        []ActionId,
) ([]*ExploreStaminaPair, error)

func CreateCalcConsumingStaminaService(
        fetchUserSkills FetchUserSkillFunc,
        fetchExploreMaster FetchExploreMasterFunc,
        fetchReductionSkills FetchReductionStaminaSkillFunc,
) CalcConsumingStaminaFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId, exploreIds []ActionId) (
                []*ExploreStaminaPair,
                error,
        ) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*ExploreStaminaPair, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on batch calc mockReducedStamina: %w", err)
                }</span>
                <span class="cov8" title="1">explores, err := fetchExploreMaster(ctx, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">exploreMap := func(explores []*GetExploreMasterRes) map[ActionId]GetExploreMasterRes </span><span class="cov8" title="1">{
                        result := map[ActionId]GetExploreMasterRes{}
                        for _, v := range explores </span><span class="cov8" title="1">{
                                result[v.ExploreId] = *v
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(explores)
                <span class="cov8" title="1">reductionStaminaSkills, err := fetchReductionSkills(ctx, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">reductionSkillMap := func(reductionSkills []*StaminaReductionSkillPair) map[ActionId][]core.SkillId </span><span class="cov8" title="1">{
                        result := map[ActionId][]core.SkillId{}
                        for _, v := range reductionSkills </span><span class="cov8" title="1">{
                                result[v.ExploreId] = append(result[v.ExploreId], v.SkillId)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(reductionStaminaSkills)

                <span class="cov8" title="1">allRequiredSkill := func(skills []*StaminaReductionSkillPair) []core.SkillId </span><span class="cov8" title="1">{
                        check := map[core.SkillId]bool{}
                        var result []core.SkillId
                        for _, v := range skills </span><span class="cov8" title="1">{
                                skillId := v.SkillId
                                if _, ok := check[skillId]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">check[skillId] = true
                                result = append(result, skillId)</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }(reductionStaminaSkills)

                <span class="cov8" title="1">allSkills, err := fetchUserSkills(ctx, userId, allRequiredSkill)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">allSkillsMap := func(
                        userId core.UserId,
                        skills []*UserSkillRes,
                        skillId []core.SkillId,
                ) map[core.SkillId]*UserSkillRes </span><span class="cov8" title="1">{
                        result := map[core.SkillId]*UserSkillRes{}
                        for _, v := range skills </span><span class="cov8" title="1">{
                                result[v.SkillId] = v
                        }</span>
                        <span class="cov8" title="1">for _, v := range skillId </span><span class="cov8" title="1">{
                                if _, ok := result[v]; !ok </span><span class="cov8" title="1">{
                                        result[v] = &amp;UserSkillRes{
                                                UserId:   userId,
                                                SkillId:  v,
                                                SkillExp: 0,
                                        }
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }(userId, allSkills.Skills, allRequiredSkill)

                <span class="cov8" title="1">reductionSkillResMap := func(
                        allSkillsMap map[core.SkillId]*UserSkillRes,
                        reductionSkills map[ActionId][]core.SkillId,
                ) map[ActionId][]*UserSkillRes </span><span class="cov8" title="1">{
                        result := map[ActionId][]*UserSkillRes{}
                        for k, v := range reductionSkills </span><span class="cov8" title="1">{
                                for _, w := range v </span><span class="cov8" title="1">{
                                        if _, ok := result[k]; !ok </span><span class="cov8" title="1">{
                                                result[k] = []*UserSkillRes{}
                                        }</span>
                                        <span class="cov8" title="1">result[k] = append(result[k], allSkillsMap[w])</span>
                                }
                        }
                        <span class="cov8" title="1">return result</span>
                }(allSkillsMap, reductionSkillMap)

                <span class="cov8" title="1">result := func(
                        idArr []ActionId,
                        exploreMap map[ActionId]GetExploreMasterRes,
                        reductionSkillMap map[ActionId][]*UserSkillRes,
                ) []*ExploreStaminaPair </span><span class="cov8" title="1">{
                        result := make([]*ExploreStaminaPair, len(exploreMap))
                        index := 0
                        for _, v := range idArr </span><span class="cov8" title="1">{
                                explore := exploreMap[v]
                                baseStamina := explore.ConsumingStamina
                                reducibleRate := explore.StaminaReducibleRate
                                stamina := CalcStaminaReduction(baseStamina, reducibleRate, reductionSkillMap[v])
                                result[index] = &amp;ExploreStaminaPair{
                                        ExploreId:      v,
                                        ReducedStamina: stamina,
                                }
                                index++
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(exploreIds, exploreMap, reductionSkillResMap)
                <span class="cov8" title="1">return result, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package game

import (
        "math"

        "github.com/asragi/RinGo/core"
)

type CalcEarnedItemFunc func(int, []*EarningItem, core.EmitRandomFunc) []*EarnedItem

type EarnedItem struct {
        ItemId core.ItemId
        Count  core.Count
}

func CalcEarnedItem(
        execCount int,
        earningItemData []*EarningItem,
        random core.EmitRandomFunc,
) []*EarnedItem <span class="cov8" title="1">{
        calcItemCount := func(
                minCount core.Count,
                maxCount core.Count,
                random core.EmitRandomFunc,
        ) core.Count </span><span class="cov8" title="1">{
                randValue := random()
                randWidth := maxCount - minCount
                randCount := core.Count(math.Round(float64(randWidth) * float64(randValue)))
                return minCount + randCount
        }</span>

        <span class="cov8" title="1">execMultipleCalcItemCount := func(
                minCount core.Count,
                maxCount core.Count,
                random core.EmitRandomFunc,
                execCount int,
        ) core.Count </span><span class="cov8" title="1">{
                sum := core.Count(0)
                for i := 0; i &lt; execCount; i++ </span><span class="cov8" title="1">{
                        sum = sum + calcItemCount(minCount, maxCount, random)
                }</span>
                <span class="cov8" title="1">return sum</span>
        }

        <span class="cov8" title="1">var result []*EarnedItem
        for _, v := range earningItemData </span><span class="cov8" title="1">{
                earnedItemStruct := EarnedItem{
                        ItemId: v.ItemId,
                        Count:  execMultipleCalcItemCount(v.MinCount, v.MaxCount, random, execCount),
                }
                result = append(result, &amp;earnedItemStruct)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package game

import (
        "github.com/asragi/RinGo/core"
)

type skillGrowthResult struct {
        SkillId core.SkillId
        GainSum GainingPoint
}

type CalcSkillGrowthFunc func(int, []*SkillGrowthData) []*skillGrowthResult

func CalcSkillGrowthService(execCount int, gainingData []*SkillGrowthData) []*skillGrowthResult <span class="cov8" title="1">{
        growth := make([]*skillGrowthResult, len(gainingData))
        for i := range gainingData </span><span class="cov8" title="1">{
                data := gainingData[i]
                growth[i] = &amp;skillGrowthResult{
                        SkillId: data.SkillId,
                        GainSum: data.GainingPoint.Multiply(execCount),
                }
        }</span>
        <span class="cov8" title="1">return growth</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package game

import "github.com/asragi/RinGo/core"

type CalcStaminaReductionFunc func(core.StaminaCost, StaminaReducibleRate, []*UserSkillRes) core.StaminaCost

func CalcStaminaReduction(
        baseStamina core.StaminaCost,
        reducibleRate StaminaReducibleRate,
        reductionSkills []*UserSkillRes,
) core.StaminaCost <span class="cov8" title="1">{
        skillLvs := func(skills []*UserSkillRes) []core.SkillLv </span><span class="cov8" title="1">{
                result := make([]core.SkillLv, len(skills))
                for i, v := range skills </span><span class="cov8" title="1">{
                        result[i] = v.SkillExp.CalcLv()
                }</span>
                <span class="cov8" title="1">return result</span>
        }(reductionSkills)
        <span class="cov8" title="1">skillRate := func(skillLvs []core.SkillLv) float64 </span><span class="cov8" title="1">{
                result := 1.0
                for _, v := range skillLvs </span><span class="cov8" title="1">{
                        result = v.ApplySkillRate(result)
                }</span>
                <span class="cov8" title="1">return result</span>
        }(skillLvs)
        <span class="cov8" title="1">stamina := ApplyReduction(baseStamina, skillRate, reducibleRate)
        return stamina</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package game

import (
        "github.com/asragi/RinGo/core"
)

type totalItem struct {
        ItemId core.ItemId
        Stock  core.Stock
}

type CalcTotalItemFunc func(
        allStorageItems []*StorageData,
        allMasterRes []*GetItemMasterRes,
        earnedItems []*EarnedItem,
        consumedItems []*ConsumedItem,
) []*totalItem

func CalcTotalItem(
        allStorageItems []*StorageData,
        allMasterRes []*GetItemMasterRes,
        earnedItems []*EarnedItem,
        consumedItems []*ConsumedItem,
) []*totalItem <span class="cov8" title="1">{
        earnedItemMap := func(earnedItems []*EarnedItem) map[core.ItemId]*EarnedItem </span><span class="cov8" title="1">{
                result := make(map[core.ItemId]*EarnedItem)
                for _, v := range earnedItems </span><span class="cov8" title="1">{
                        result[v.ItemId] = v
                }</span>
                <span class="cov8" title="1">return result</span>
        }(earnedItems)
        <span class="cov8" title="1">idOrder := func(allMasterRes []*GetItemMasterRes) map[int]core.ItemId </span><span class="cov8" title="1">{
                result := map[int]core.ItemId{}
                for i, v := range allMasterRes </span><span class="cov8" title="1">{
                        result[i] = v.ItemId
                }</span>
                <span class="cov8" title="1">return result</span>
        }(allMasterRes)

        <span class="cov8" title="1">consumedItemMap := func(consumedItems []*ConsumedItem) map[core.ItemId]*ConsumedItem </span><span class="cov8" title="1">{
                result := make(map[core.ItemId]*ConsumedItem)
                for _, v := range consumedItems </span><span class="cov8" title="1">{
                        result[v.ItemId] = v
                }</span>
                <span class="cov8" title="1">return result</span>
        }(consumedItems)

        <span class="cov8" title="1">storageMap := func(stocks []*StorageData) map[core.ItemId]core.Stock </span><span class="cov8" title="1">{
                result := make(map[core.ItemId]core.Stock)
                for _, v := range stocks </span><span class="cov8" title="1">{
                        result[v.ItemId] = v.Stock
                }</span>
                <span class="cov8" title="1">return result</span>
        }(allStorageItems)

        <span class="cov8" title="1">maxStockMap := func(masters []*GetItemMasterRes) map[core.ItemId]core.MaxStock </span><span class="cov8" title="1">{
                result := make(map[core.ItemId]core.MaxStock)
                for _, v := range masters </span><span class="cov8" title="1">{
                        result[v.ItemId] = v.MaxStock
                }</span>
                <span class="cov8" title="1">return result</span>
        }(allMasterRes)

        <span class="cov8" title="1">return func(
                idMap map[int]core.ItemId,
                storageMap map[core.ItemId]core.Stock,
                maxStockMap map[core.ItemId]core.MaxStock,
                earnedItemMap map[core.ItemId]*EarnedItem,
                consumedItemMap map[core.ItemId]*ConsumedItem,
        ) []*totalItem </span><span class="cov8" title="1">{
                result := make([]*totalItem, len(idMap))
                for i := 0; i &lt; len(idMap); i++ </span><span class="cov8" title="1">{
                        id := idMap[i]
                        stock := func(storage map[core.ItemId]core.Stock, id core.ItemId) core.Stock </span><span class="cov8" title="1">{
                                if _, ok := storage[id]; !ok </span><span class="cov8" title="1">{
                                        return core.Stock(0)
                                }</span>
                                <span class="cov8" title="1">return storage[id]</span>
                        }(storageMap, id)
                        <span class="cov8" title="1">diff := core.Count(0)
                        if _, ok := earnedItemMap[id]; ok </span><span class="cov8" title="1">{
                                diff += earnedItemMap[id].Count
                        }</span>
                        <span class="cov8" title="1">if _, ok := consumedItemMap[id]; ok </span><span class="cov8" title="1">{
                                diff -= consumedItemMap[id].Count
                        }</span>
                        <span class="cov8" title="1">afterStock := stock.AddStock(diff, maxStockMap[id])
                        result[i] = &amp;totalItem{
                                ItemId: id,
                                Stock:  afterStock,
                        }</span>
                }
                <span class="cov8" title="1">return result</span>
        }(idOrder, storageMap, maxStockMap, earnedItemMap, consumedItemMap)
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package game

import (
        "github.com/asragi/RinGo/core"
)

type growthApplyResult struct {
        SkillId   core.SkillId
        GainSum   GainingPoint
        BeforeLv  core.SkillLv
        BeforeExp core.SkillExp
        AfterLv   core.SkillLv
        AfterExp  core.SkillExp
        WasLvUp   bool
}

type GrowthApplyFunc func([]*UserSkillRes, []*skillGrowthResult) []*growthApplyResult

func CalcApplySkillGrowth(userSkills []*UserSkillRes, skillGrowth []*skillGrowthResult) []*growthApplyResult <span class="cov8" title="1">{
        applySkillGrowth := func(userSkill *UserSkillRes, skillGrowth *skillGrowthResult) *growthApplyResult </span><span class="cov8" title="1">{
                if userSkill.SkillId != skillGrowth.SkillId </span><span class="cov0" title="0">{
                        panic("invalid apply skill growth!")</span>
                }
                <span class="cov8" title="1">beforeExp := userSkill.SkillExp
                afterExp := skillGrowth.GainSum.ApplyTo(beforeExp)
                beforeLv := beforeExp.CalcLv()
                afterLv := afterExp.CalcLv()
                wasLvUp := beforeLv != afterLv
                return &amp;growthApplyResult{
                        SkillId:   userSkill.SkillId,
                        GainSum:   skillGrowth.GainSum,
                        BeforeLv:  beforeLv,
                        BeforeExp: beforeExp,
                        AfterLv:   afterLv,
                        AfterExp:  afterExp,
                        WasLvUp:   wasLvUp,
                }</span>
        }
        <span class="cov8" title="1">userSkillMap := func(userSkills []*UserSkillRes) map[core.SkillId]*UserSkillRes </span><span class="cov8" title="1">{
                result := make(map[core.SkillId]*UserSkillRes)
                for _, v := range userSkills </span><span class="cov8" title="1">{
                        result[v.SkillId] = v
                }</span>
                <span class="cov8" title="1">return result</span>
        }(userSkills)

        <span class="cov8" title="1">result := make([]*growthApplyResult, len(skillGrowth))
        for i, v := range skillGrowth </span><span class="cov8" title="1">{
                userSkill, ok := userSkillMap[v.SkillId]
                if !ok </span><span class="cov8" title="1">{
                        userSkill = &amp;UserSkillRes{
                                SkillId:  v.SkillId,
                                SkillExp: 0,
                        }
                }</span>
                <span class="cov8" title="1">result[i] = applySkillGrowth(userSkill, v)</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package game

import (
        "errors"
        "fmt"
)

var InvalidActionError = errors.New("invalid Action")

type InvalidResponseFromInfrastructureError struct {
        Message string
}

func (e *InvalidResponseFromInfrastructureError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid Response: %s", e.Message)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package explore

// Deprecated: avoid using DependencyInjectionContainer
type DependencyInjectionContainer struct {
        GetAllStage                      GetAllStageFunc
        CreateGetUserResourceServiceFunc CreateGetUserResourceServiceFunc
}

func CreateDIContainer() DependencyInjectionContainer <span class="cov0" title="0">{
        return DependencyInjectionContainer{
                GetAllStage:                      GetAllStage,
                CreateGetUserResourceServiceFunc: CreateGetUserResourceService,
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package explore

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type (
        getCommonActionRes struct {
                UserId            core.UserId
                ActionDisplayName core.DisplayName
                RequiredPayment   core.Cost
                RequiredStamina   core.StaminaCost
                RequiredItems     []*RequiredItemsRes
                EarningItems      []*EarningItemRes
                RequiredSkills    []*RequiredSkillsRes
        }
        getCommonActionFunc func(
                context.Context,
                core.UserId,
                game.ActionId,
        ) (getCommonActionRes, error)
        CreateGetCommonActionRepositories struct {
                FetchItemStorage        game.FetchStorageFunc
                FetchExploreMaster      game.FetchExploreMasterFunc
                FetchEarningItem        game.FetchEarningItemFunc
                FetchConsumingItem      game.FetchConsumingItemFunc
                FetchSkillMaster        game.FetchSkillMasterFunc
                FetchUserSkill          game.FetchUserSkillFunc
                FetchRequiredSkillsFunc game.FetchRequiredSkillsFunc
        }
        CreateCommonGetActionDetailFunc func(
                game.CalcConsumingStaminaFunc,
                game.FetchStorageFunc,
                game.FetchExploreMasterFunc,
                game.FetchEarningItemFunc,
                game.FetchConsumingItemFunc,
                game.FetchSkillMasterFunc,
                game.FetchUserSkillFunc,
                game.FetchRequiredSkillsFunc,
        ) getCommonActionFunc
)

func CreateGetCommonActionDetail(
        calcConsumingStamina game.CalcConsumingStaminaFunc,
        fetchItemStorage game.FetchStorageFunc,
        fetchExploreMaster game.FetchExploreMasterFunc,
        fetchEarningItem game.FetchEarningItemFunc,
        fetchConsumingItem game.FetchConsumingItemFunc,
        fetchSkillMaster game.FetchSkillMasterFunc,
        fetchUserSkill game.FetchUserSkillFunc,
        fetchRequiredSkillsFunc game.FetchRequiredSkillsFunc,
) getCommonActionFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                exploreId game.ActionId,
        ) (getCommonActionRes, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (getCommonActionRes, error) </span><span class="cov0" title="0">{
                        return getCommonActionRes{}, fmt.Errorf("error on GetActionDetail: %w", err)
                }</span>
                <span class="cov8" title="1">exploreMasterRes, err := fetchExploreMaster(ctx, []game.ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">exploreMaster := exploreMasterRes[0]
                consumingItemsRes, err := fetchConsumingItem(ctx, []game.ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">consumingItems := consumingItemsRes
                consumingItemIds := func(consuming []*game.ConsumingItem) []core.ItemId </span><span class="cov8" title="1">{
                        result := make([]core.ItemId, len(consuming))
                        for i, v := range consuming </span><span class="cov8" title="1">{
                                result[i] = v.ItemId
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(consumingItems)
                <span class="cov8" title="1">userItemPair := game.ToUserItemPair(userId, consumingItemIds)
                consumingItemStorage, err := fetchItemStorage(ctx, userItemPair)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">filledStorageData := game.FillStorageData(consumingItemStorage, userItemPair)
                storage := func() *game.BatchGetStorageRes </span><span class="cov8" title="1">{
                        userStorage := game.FindStorageData(filledStorageData, userId)
                        if userStorage == nil </span><span class="cov0" title="0">{
                                return &amp;game.BatchGetStorageRes{
                                        UserId:   userId,
                                        ItemData: []*game.StorageData{},
                                }
                        }</span>
                        <span class="cov8" title="1">return userStorage</span>
                }()
                <span class="cov8" title="1">consumingItemMap := func(itemStorage []*game.StorageData) map[core.ItemId]*game.StorageData </span><span class="cov8" title="1">{
                        result := make(map[core.ItemId]*game.StorageData)
                        for _, v := range itemStorage </span><span class="cov8" title="1">{
                                result[v.ItemId] = v
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(storage.ItemData)
                <span class="cov8" title="1">requiredItems := func(consuming []*game.ConsumingItem) []*RequiredItemsRes </span><span class="cov8" title="1">{
                        result := make([]*RequiredItemsRes, len(consuming))
                        for i, v := range consuming </span><span class="cov8" title="1">{
                                userData := consumingItemMap[v.ItemId]
                                result[i] = &amp;RequiredItemsRes{
                                        ItemId:   v.ItemId,
                                        MaxCount: v.MaxCount,
                                        Stock:    userData.Stock,
                                        IsKnown:  userData.IsKnown,
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(consumingItems)
                <span class="cov8" title="1">requiredStamina, err := func(baseStamina core.StaminaCost) (core.StaminaCost, error) </span><span class="cov8" title="1">{
                        reducedStamina, err := calcConsumingStamina(ctx, userId, []game.ActionId{exploreId})
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">if len(reducedStamina) &lt;= 0 </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("error on getting reduced stamina: stamina res length == 0")
                        }</span>
                        <span class="cov8" title="1">stamina := reducedStamina[0].ReducedStamina
                        return stamina, err</span>
                }(exploreMaster.ConsumingStamina)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">items, err := fetchEarningItem(ctx, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">earningItems := func(items []*game.EarningItem) []*EarningItemRes </span><span class="cov8" title="1">{
                        result := make([]*EarningItemRes, len(items))
                        for i, v := range items </span><span class="cov8" title="1">{
                                result[i] = &amp;EarningItemRes{
                                        ItemId: v.ItemId,
                                        // TODO: change display depends on user data
                                        IsKnown: true,
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(items)
                <span class="cov8" title="1">requiredSkills, err := func(exploreId game.ActionId) ([]*RequiredSkillsRes, error) </span><span class="cov8" title="1">{
                        res, err := fetchRequiredSkillsFunc(ctx, []game.ActionId{exploreId})
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error on getting required skills: %w", err)
                        }</span>
                        <span class="cov8" title="1">if len(res) &lt;= 0 </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">requiredSkill := res
                        skillIds := func(skills []*game.RequiredSkill) []core.SkillId </span><span class="cov8" title="1">{
                                result := make([]core.SkillId, len(skills))
                                for i, v := range skills </span><span class="cov8" title="1">{
                                        result[i] = v.SkillId
                                }</span>
                                <span class="cov8" title="1">return result</span>
                        }(requiredSkill)
                        <span class="cov8" title="1">skillMasterMap, err := func(skillId []core.SkillId) (map[core.SkillId]*game.SkillMaster, error) </span><span class="cov8" title="1">{
                                res, err := fetchSkillMaster(ctx, skillId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error on getting skill master: %w", err)
                                }</span>
                                <span class="cov8" title="1">result := make(map[core.SkillId]*game.SkillMaster)
                                for _, v := range res </span><span class="cov8" title="1">{
                                        result[v.SkillId] = v
                                }</span>
                                <span class="cov8" title="1">return result, nil</span>
                        }(skillIds)
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error on getting required skills: %w", err)
                        }</span>
                        <span class="cov8" title="1">userSkillRes, err := fetchUserSkill(ctx, userId, skillIds)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error on getting required skills: %w", err)
                        }</span>
                        <span class="cov8" title="1">userSkillMap := func(userSkill game.BatchGetUserSkillRes) map[core.SkillId]*game.UserSkillRes </span><span class="cov8" title="1">{
                                skills := userSkill.Skills
                                result := make(map[core.SkillId]*game.UserSkillRes)
                                for _, v := range skills </span><span class="cov8" title="1">{
                                        result[v.SkillId] = v
                                }</span>
                                <span class="cov8" title="1">return result</span>
                        }(userSkillRes)

                        <span class="cov8" title="1">result := make([]*RequiredSkillsRes, len(requiredSkill))
                        for i, v := range requiredSkill </span><span class="cov8" title="1">{
                                master := skillMasterMap[v.SkillId]
                                userSkill := userSkillMap[v.SkillId]
                                skill := &amp;RequiredSkillsRes{
                                        SkillId:     v.SkillId,
                                        RequiredLv:  v.RequiredLv,
                                        DisplayName: master.DisplayName,
                                        SkillLv:     userSkill.SkillExp.CalcLv(),
                                }
                                result[i] = skill
                        }</span>
                        <span class="cov8" title="1">return result, nil</span>
                }(exploreId)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return getCommonActionRes{
                        UserId:            userId,
                        ActionDisplayName: exploreMaster.DisplayName,
                        RequiredPayment:   exploreMaster.RequiredPayment,
                        RequiredStamina:   requiredStamina,
                        RequiredItems:     requiredItems,
                        EarningItems:      earningItems,
                        RequiredSkills:    requiredSkills,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package explore

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type GetItemActionDetailFunc func(
        context.Context, core.UserId, core.ItemId, game.ActionId,
) (GetItemActionDetailResponse, error)

type GetItemActionDetailResponse struct {
        UserId            core.UserId
        ItemId            core.ItemId
        DisplayName       core.DisplayName
        ActionDisplayName core.DisplayName
        RequiredPayment   core.Cost
        RequiredStamina   core.StaminaCost
        RequiredItems     []*RequiredItemsRes
        EarningItems      []*EarningItemRes
        RequiredSkills    []*RequiredSkillsRes
}

type CreateGetItemActionDetailFunc func(
        getCommonActionFunc,
        game.FetchItemMasterFunc,
) GetItemActionDetailFunc

func CreateGetItemActionDetailService(
        getCommonAction getCommonActionFunc,
        fetchItemMaster game.FetchItemMasterFunc,
) GetItemActionDetailFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                itemId core.ItemId,
                exploreId game.ActionId,
        ) (GetItemActionDetailResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (GetItemActionDetailResponse, error) </span><span class="cov0" title="0">{
                        return GetItemActionDetailResponse{}, fmt.Errorf("on get item action detail service: %w", err)
                }</span>
                <span class="cov8" title="1">commonActionRes, err := getCommonAction(ctx, userId, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemMasterRes, err := fetchItemMaster(ctx, []core.ItemId{itemId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if len(itemMasterRes) &lt;= 0 </span><span class="cov0" title="0">{
                        return handleError(&amp;game.InvalidResponseFromInfrastructureError{Message: "get item master"})
                }</span>
                <span class="cov8" title="1">itemMaster := itemMasterRes[0]

                return GetItemActionDetailResponse{
                        UserId:            userId,
                        ItemId:            itemId,
                        DisplayName:       itemMaster.DisplayName,
                        ActionDisplayName: commonActionRes.ActionDisplayName,
                        RequiredPayment:   commonActionRes.RequiredPayment,
                        RequiredStamina:   commonActionRes.RequiredStamina,
                        RequiredItems:     commonActionRes.RequiredItems,
                        EarningItems:      commonActionRes.EarningItems,
                        RequiredSkills:    commonActionRes.RequiredSkills,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package explore

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type GetUserItemDetailReq struct {
        UserId core.UserId
        ItemId core.ItemId
}

type getUserItemDetailRes struct {
        UserId       core.UserId
        ItemId       core.ItemId
        Price        core.Price
        DisplayName  core.DisplayName
        Description  core.Description
        MaxStock     core.MaxStock
        Stock        core.Stock
        UserExplores []*game.UserExplore
}

type getItemDetailArgs struct {
        masterRes          *game.GetItemMasterRes
        storageRes         *game.StorageData
        exploreStaminaPair []*game.ExploreStaminaPair
        explores           []*game.GetExploreMasterRes
        userExplore        []*game.UserExplore
}

type GetItemDetailFunc func(context.Context, core.UserId, core.ItemId) (*getUserItemDetailRes, error)

type CreateGetItemDetailServiceFunc func(
        GenerateItemDetailArgsFunc,
) GetItemDetailFunc

func CreateGetItemDetailService(
        generateArgs GenerateItemDetailArgsFunc,
) GetItemDetailFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId, itemId core.ItemId) (*getUserItemDetailRes, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*getUserItemDetailRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on get user item data: %w", err)
                }</span>
                <span class="cov8" title="1">args, err := generateArgs(ctx, userId, itemId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">return func(
                        masterRes *game.GetItemMasterRes,
                        storageRes *game.StorageData,
                        explores []*game.UserExplore,
                ) *getUserItemDetailRes </span><span class="cov8" title="1">{
                        return &amp;getUserItemDetailRes{
                                UserId:       storageRes.UserId,
                                ItemId:       masterRes.ItemId,
                                Price:        masterRes.Price,
                                DisplayName:  masterRes.DisplayName,
                                Description:  masterRes.Description,
                                MaxStock:     masterRes.MaxStock,
                                Stock:        storageRes.Stock,
                                UserExplores: explores,
                        }
                }</span>(args.masterRes, args.storageRes, args.userExplore), nil
        }
}

type CreateGetItemDetailArgsFunc func(
        game.FetchItemMasterFunc,
        game.FetchStorageFunc,
        game.FetchExploreMasterFunc,
        FetchItemExploreRelationFunc,
        game.CalcConsumingStaminaFunc,
        game.MakeUserExploreFunc,
) GenerateItemDetailArgsFunc

type GenerateItemDetailArgsFunc func(
        context.Context,
        core.UserId,
        core.ItemId,
) (*getItemDetailArgs, error)

func CreateGenerateGetItemDetailArgs(
        getItemMaster game.FetchItemMasterFunc,
        getItemStorage game.FetchStorageFunc,
        getExploreMaster game.FetchExploreMasterFunc,
        getItemExploreRelation FetchItemExploreRelationFunc,
        calcBatchConsumingStaminaFunc game.CalcConsumingStaminaFunc,
        makeUserExplore game.MakeUserExploreFunc,
) GenerateItemDetailArgsFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId, itemId core.ItemId) (*getItemDetailArgs, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*getItemDetailArgs, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on create get item detail args: %w", err)
                }</span>
                <span class="cov8" title="1">itemIdReq := []core.ItemId{itemId}
                itemMasterRes, err := getItemMaster(ctx, itemIdReq)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if len(itemMasterRes) &lt;= 0 </span><span class="cov0" title="0">{
                        return handleError(&amp;game.InvalidResponseFromInfrastructureError{Message: "item master response"})
                }</span>
                <span class="cov8" title="1">itemMaster := itemMasterRes[0]
                itemExploreIds, err := getItemExploreRelation(ctx, itemId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">explores, err := getExploreMaster(ctx, itemExploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">staminaRes, err := calcBatchConsumingStaminaFunc(ctx, userId, itemExploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">storageRes, err := getItemStorage(ctx, game.ToUserItemPair(userId, itemIdReq))
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">storage := game.FindStorageData(storageRes, userId)
                itemData := storage.ItemData
                if len(itemData) &lt;= 0 </span><span class="cov0" title="0">{
                        return handleError(&amp;game.InvalidResponseFromInfrastructureError{Message: "Item Storage Data"})
                }</span>
                <span class="cov8" title="1">targetStorage := itemData[0]
                userExplores, err := makeUserExplore(ctx, userId, itemExploreIds, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">return &amp;getItemDetailArgs{
                        masterRes:          itemMaster,
                        explores:           explores,
                        exploreStaminaPair: staminaRes,
                        storageRes:         targetStorage,
                        userExplore:        userExplores,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package explore

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type (
        CreateGetUserResourceServiceFunc func(
                resourceFunc game.GetResourceFunc,
        ) GetUserResourceServiceFunc

        GetUserResourceServiceFunc func(
                context.Context,
                core.UserId,
        ) (*game.GetResourceRes, error)
)

func CreateGetUserResourceService(
        getResource game.GetResourceFunc,
) GetUserResourceServiceFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
        ) (*game.GetResourceRes, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*game.GetResourceRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on get user resource: %w", err)
                }</span>
                <span class="cov8" title="1">res, err := getResource(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return res, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package explore

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type RequiredItemsRes struct {
        ItemId   core.ItemId
        IsKnown  core.IsKnown
        Stock    core.Stock
        MaxCount core.Count
}

type RequiredSkillsRes struct {
        SkillId     core.SkillId
        RequiredLv  core.SkillLv
        DisplayName core.DisplayName
        SkillLv     core.SkillLv
}

type EarningItemRes struct {
        ItemId  core.ItemId
        IsKnown core.IsKnown
}

type GetStageActionDetailFunc func(
        context.Context,
        core.UserId,
        StageId,
        game.ActionId,
) (gateway.GetStageActionDetailResponse, error)

type CreateGetStageActionDetailFunc func(getCommonActionFunc, FetchStageMasterFunc) GetStageActionDetailFunc

func CreateGetStageActionDetailService(
        getCommonAction getCommonActionFunc,
        fetchStageMaster FetchStageMasterFunc,
) GetStageActionDetailFunc <span class="cov0" title="0">{
        getActionDetail := func(
                ctx context.Context,
                userId core.UserId,
                stageId StageId,
                exploreId game.ActionId,
        ) (gateway.GetStageActionDetailResponse, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (gateway.GetStageActionDetailResponse, error) </span><span class="cov0" title="0">{
                        return gateway.GetStageActionDetailResponse{}, fmt.Errorf("error on getting stage action detail: %w", err)
                }</span>
                <span class="cov0" title="0">getCommonActionRes, err := getCommonAction(ctx, userId, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">requiredItems := RequiredItemsToGateway(getCommonActionRes.RequiredItems)
                earningItems := EarningItemsToGateway(getCommonActionRes.EarningItems)
                requiredSkills := RequiredSkillsToGateway(getCommonActionRes.RequiredSkills)

                stageMasterRes, err := fetchStageMaster(ctx, []StageId{stageId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if len(stageMasterRes) &lt;= 0 </span><span class="cov0" title="0">{
                        return gateway.GetStageActionDetailResponse{}, fmt.Errorf("stage not found: %s", stageId)
                }</span>
                <span class="cov0" title="0">stageMaster := stageMasterRes[0]

                return gateway.GetStageActionDetailResponse{
                        UserId:            string(userId),
                        StageId:           string(stageId),
                        DisplayName:       string(stageMaster.DisplayName),
                        ActionDisplayName: string(getCommonActionRes.ActionDisplayName),
                        RequiredPayment:   int32(getCommonActionRes.RequiredPayment),
                        RequiredStamina:   int32(getCommonActionRes.RequiredStamina),
                        RequiredItems:     requiredItems,
                        EarningItems:      earningItems,
                        RequiredSkills:    requiredSkills,
                }, nil</span>
        }

        <span class="cov0" title="0">return getActionDetail</span>
}

// TODO: RequiredItemsToGateway should not be in stage package
func RequiredItemsToGateway(requiredItems []*RequiredItemsRes) []*gateway.RequiredItem <span class="cov0" title="0">{
        result := make([]*gateway.RequiredItem, len(requiredItems))
        for i, v := range requiredItems </span><span class="cov0" title="0">{
                item := gateway.RequiredItem{
                        ItemId:  string(v.ItemId),
                        IsKnown: bool(v.IsKnown),
                }
                result[i] = &amp;item
        }</span>
        <span class="cov0" title="0">return result</span>
}

func EarningItemsToGateway(earningItems []*EarningItemRes) []*gateway.EarningItem <span class="cov0" title="0">{
        result := make([]*gateway.EarningItem, len(earningItems))
        for i, v := range earningItems </span><span class="cov0" title="0">{
                result[i] = &amp;gateway.EarningItem{
                        ItemId:  string(v.ItemId),
                        IsKnown: bool(v.IsKnown),
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}

func RequiredSkillsToGateway(requiredSkills []*RequiredSkillsRes) []*gateway.RequiredSkill <span class="cov0" title="0">{
        result := make([]*gateway.RequiredSkill, len(requiredSkills))
        for i, v := range requiredSkills </span><span class="cov0" title="0">{
                result[i] = &amp;gateway.RequiredSkill{
                        SkillId:     string(v.SkillId),
                        DisplayName: string(v.DisplayName),
                        RequiredLv:  int32(v.RequiredLv),
                        SkillLv:     int32(v.SkillLv),
                }
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package explore

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type StageInformation struct {
        StageId      StageId
        DisplayName  core.DisplayName
        IsKnown      core.IsKnown
        Description  core.Description
        UserExplores []*game.UserExplore
}

type GetStageListFunc func(
        context.Context,
        core.UserId,
        core.GetCurrentTimeFunc,
) ([]*StageInformation, error)

type CreateGetStageListFunc func(
        GetAllStageFunc,
        fetchStageDataFunc,
) GetStageListFunc

func CreateGetStageList(
        getAllStage GetAllStageFunc,
        fetchStageData fetchStageDataFunc,
) GetStageListFunc <span class="cov8" title="1">{
        getStageListFunc := func(
                ctx context.Context,
                userId core.UserId,
                currentTime core.GetCurrentTimeFunc,
        ) ([]*StageInformation, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*StageInformation, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on get stage list: %w", err)
                }</span>
                <span class="cov8" title="1">stageData, err := fetchStageData(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">stageInformation := getAllStage(
                        stageData,
                )
                return stageInformation, nil</span>
        }

        <span class="cov8" title="1">return getStageListFunc</span>
}

type fetchStageDataFunc func(context.Context, core.UserId) (*getAllStageArgs, error)
type FetchStageDataRepositories struct {
        FetchAllStage             FetchAllStageFunc
        FetchUserStageFunc        FetchUserStageFunc
        FetchStageExploreRelation FetchStageExploreRelation
        MakeUserExplore           game.MakeUserExploreFunc
}
type CreateFetchStageDataFunc func(
        FetchAllStageFunc,
        FetchUserStageFunc,
        FetchStageExploreRelation,
        game.MakeUserExploreFunc,
) fetchStageDataFunc

func CreateFetchStageData(
        fetchAllStage FetchAllStageFunc,
        fetchUserStageFunc FetchUserStageFunc,
        fetchStageExploreRelation FetchStageExploreRelation,
        makeUserExplore game.MakeUserExploreFunc,
) fetchStageDataFunc <span class="cov0" title="0">{
        fetch := func(
                ctx context.Context,
                userId core.UserId,
        ) (*getAllStageArgs, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (*getAllStageArgs, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on fetch stage data: %w", err)
                }</span>
                <span class="cov0" title="0">allStageRes, err := fetchAllStage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">stageId := func(stageRes []*StageMaster) []StageId </span><span class="cov0" title="0">{
                        result := make([]StageId, len(stageRes))
                        for i, v := range stageRes </span><span class="cov0" title="0">{
                                result[i] = v.StageId
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }(allStageRes)
                <span class="cov0" title="0">userStage, err := fetchUserStageFunc(ctx, userId, stageId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">stageExplorePair, err := fetchStageExploreRelation(ctx, stageId)
                exploreIds := func(stageExplore []*StageExploreIdPairRow) []game.ActionId </span><span class="cov0" title="0">{
                        result := make([]game.ActionId, len(stageExplore))
                        for i, v := range stageExplore </span><span class="cov0" title="0">{
                                result[i] = v.ExploreId
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }(stageExplorePair)
                <span class="cov0" title="0">userExplore, err := makeUserExplore(ctx, userId, exploreIds, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return &amp;getAllStageArgs{
                        stageId:        stageId,
                        allStageRes:    allStageRes,
                        userStageRes:   userStage,
                        stageExploreId: stageExplorePair,
                        exploreId:      exploreIds,
                        userExplore:    userExplore,
                }, nil</span>
        }

        <span class="cov0" title="0">return fetch</span>
}

type getAllStageArgs struct {
        stageId        []StageId
        allStageRes    []*StageMaster
        userStageRes   []*UserStage
        stageExploreId []*StageExploreIdPairRow
        exploreId      []game.ActionId
        userExplore    []*game.UserExplore
}

type GetAllStageFunc func(
        *getAllStageArgs,
) []*StageInformation

func GetAllStage(
        args *getAllStageArgs,
) []*StageInformation <span class="cov8" title="1">{
        stageMaster := args.allStageRes
        userStageData := args.userStageRes
        stageExplores := args.stageExploreId
        stageIds := args.stageId
        stages := stageMaster
        userExplore := args.userExplore

        userStageMap := func(userStages []*UserStage, stageIds []StageId) map[StageId]*UserStage </span><span class="cov8" title="1">{
                result := make(map[StageId]*UserStage)
                for _, v := range userStages </span><span class="cov8" title="1">{
                        result[v.StageId] = v
                }</span>
                <span class="cov8" title="1">for _, v := range stageIds </span><span class="cov8" title="1">{
                        if _, ok := result[v]; !ok </span><span class="cov8" title="1">{
                                result[v] = &amp;UserStage{
                                        StageId: v,
                                        IsKnown: false,
                                }
                        }</span>
                }
                <span class="cov8" title="1">return result</span>
        }(userStageData, stageIds)

        <span class="cov8" title="1">allActions := func(
                stageIds []StageId,
                userExplore []*game.UserExplore,
        ) map[StageId][]*game.UserExplore </span><span class="cov8" title="1">{
                stageIdExploreMap := func(stageExploreIds []*StageExploreIdPairRow) map[StageId][]game.ActionId </span><span class="cov8" title="1">{
                        result := make(map[StageId][]game.ActionId)
                        for _, v := range stageExploreIds </span><span class="cov8" title="1">{
                                if _, ok := result[v.StageId]; !ok </span><span class="cov8" title="1">{
                                        result[v.StageId] = []game.ActionId{}
                                }</span>
                                <span class="cov8" title="1">result[v.StageId] = append(result[v.StageId], v.ExploreId)</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }(stageExplores)

                <span class="cov8" title="1">userExploreFetchedMap := func(exploreArray []*game.UserExplore) map[game.ActionId]*game.UserExplore </span><span class="cov8" title="1">{
                        result := make(map[game.ActionId]*game.UserExplore)
                        for _, v := range exploreArray </span><span class="cov8" title="1">{
                                result[v.ExploreId] = v
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(userExplore)

                <span class="cov8" title="1">result := func() map[StageId][]*game.UserExplore </span><span class="cov8" title="1">{
                        result := make(map[StageId][]*game.UserExplore)
                        for _, v := range stageIds </span><span class="cov8" title="1">{
                                if _, ok := result[v]; !ok </span><span class="cov8" title="1">{
                                        result[v] = []*game.UserExplore{}
                                }</span>
                                <span class="cov8" title="1">for _, w := range stageIdExploreMap[v] </span><span class="cov8" title="1">{
                                        result[v] = append(result[v], userExploreFetchedMap[w])
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">return result</span>
        }(stageIds, userExplore)

        <span class="cov8" title="1">result := make([]*StageInformation, len(stages))
        for i, v := range stages </span><span class="cov8" title="1">{
                id := v.StageId
                actions := allActions[id]
                result[i] = &amp;StageInformation{
                        StageId:      id,
                        DisplayName:  v.DisplayName,
                        Description:  v.Description,
                        IsKnown:      userStageMap[id].IsKnown,
                        UserExplores: actions,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package explore

type StageId string

func CreateStageId(id string) (StageId, error) <span class="cov0" title="0">{
        return StageId(id), nil
}</span>

func (id StageId) String() string <span class="cov0" title="0">{
        return string(id)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package explore

import (
        "context"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type StageExploreIdPair struct {
        StageId    StageId
        ExploreIds []StageExploreIdPairRow
}

func (p StageExploreIdPair) CreateSelf(id StageId, data []StageExploreIdPairRow) StageExploreIdPair <span class="cov0" title="0">{
        return StageExploreIdPair{
                StageId:    id,
                ExploreIds: data,
        }
}</span>

type StageExploreIdPairRow struct {
        StageId   StageId       `db:"stage_id"`
        ExploreId game.ActionId `db:"explore_id"`
}

func (row StageExploreIdPairRow) GetId() StageId <span class="cov0" title="0">{
        return row.StageId
}</span>

type FetchItemExploreRelationFunc func(context.Context, core.ItemId) ([]game.ActionId, error)

type FetchStageExploreRelation func(context.Context, []StageId) ([]*StageExploreIdPairRow, error)

type StageMaster struct {
        StageId     StageId          `db:"stage_id"`
        DisplayName core.DisplayName `db:"display_name"`
        Description core.Description `db:"description"`
}

type GetAllStagesRes struct {
        Stages []StageMaster
}

type FetchStageMasterFunc func(context.Context, []StageId) ([]*StageMaster, error)
type FetchAllStageFunc func(context.Context) ([]*StageMaster, error)

type FetchUserStageFunc func(context.Context, core.UserId, []StageId) ([]*UserStage, error)

type UserStage struct {
        StageId StageId      `db:"stage_id"`
        IsKnown core.IsKnown `db:"is_known"`
}

type GetAllUserStagesRes struct {
        UserStage []UserStage
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package game

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type GetItemListFunc func(context.Context, core.UserId) ([]*ItemListRow, error)

type ItemListRow struct {
        ItemId      core.ItemId
        DisplayName core.DisplayName
        Stock       core.Stock
        MaxStock    core.MaxStock
        Price       core.Price
}

type CreateGetItemListFunc func(FetchAllStorageFunc, FetchItemMasterFunc) GetItemListFunc

func CreateGetItemListService(
        getAllStorage FetchAllStorageFunc,
        getItemMaster FetchItemMasterFunc,
) GetItemListFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
        ) ([]*ItemListRow, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*ItemListRow, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on get all storage: %w", err)
                }</span>
                <span class="cov8" title="1">storages, err := getAllStorage(ctx, userId)
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return []*ItemListRow{}, nil
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemIds := func(storages []*StorageData) []core.ItemId </span><span class="cov8" title="1">{
                        result := make([]core.ItemId, len(storages))
                        for i, v := range storages </span><span class="cov8" title="1">{
                                result[i] = v.ItemId
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(storages)
                <span class="cov8" title="1">itemMaster, err := getItemMaster(ctx, itemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">storageMap := func(storages []*StorageData) map[core.ItemId]*StorageData </span><span class="cov8" title="1">{
                        result := map[core.ItemId]*StorageData{}
                        for _, v := range storages </span><span class="cov8" title="1">{
                                result[v.ItemId] = v
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(storages)
                <span class="cov8" title="1">masterMap := ItemMasterResToMap(itemMaster)
                itemList := func(
                        items []core.ItemId,
                        itemMasterMap map[core.ItemId]*GetItemMasterRes,
                        itemStorageMap map[core.ItemId]*StorageData,
                ) []*ItemListRow </span><span class="cov8" title="1">{
                        result := make([]*ItemListRow, len(items))
                        for i, v := range items </span><span class="cov8" title="1">{
                                master := itemMasterMap[v]
                                storage := itemStorageMap[v]
                                result[i] = &amp;ItemListRow{
                                        ItemId:      v,
                                        DisplayName: master.DisplayName,
                                        Stock:       storage.Stock,
                                        MaxStock:    master.MaxStock,
                                        Price:       master.Price,
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(itemIds, masterMap, storageMap)
                <span class="cov8" title="1">return itemList, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package game

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type CreateMakeUserExploreRepositories struct {
        FetchResource        GetResourceFunc
        GetAction            GetUserExploreFunc
        GetRequiredSkills    FetchRequiredSkillsFunc
        GetConsumingItems    FetchConsumingItemFunc
        GetStorage           FetchStorageFunc
        GetUserSkill         FetchUserSkillFunc
        CalcConsumingStamina CalcConsumingStaminaFunc
        GetExploreMaster     FetchExploreMasterFunc
        GetCurrentTime       core.GetCurrentTimeFunc
}

type GenerateMakeUserExploreArgs func(
        context.Context,
        core.UserId,
        []ActionId,
) (*makeUserExploreArgs, error)

func CreateGenerateMakeUserExploreArgs(
        fetchResource GetResourceFunc,
        getAction GetUserExploreFunc,
        getRequiredSkills FetchRequiredSkillsFunc,
        getConsumingItems FetchConsumingItemFunc,
        getStorage FetchStorageFunc,
        getUserSkill FetchUserSkillFunc,
        calcConsumingStamina CalcConsumingStaminaFunc,
        getExploreMaster FetchExploreMasterFunc,
        getCurrentTime core.GetCurrentTimeFunc,
) GenerateMakeUserExploreArgs <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                exploreIds []ActionId,
        ) (*makeUserExploreArgs, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*makeUserExploreArgs, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on create make user explore args: %w", err)
                }</span>
                <span class="cov8" title="1">resource, err := fetchResource(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">fund := resource.Fund
                staminaRecoverTime := resource.StaminaRecoverTime
                maxStamina := resource.MaxStamina
                actionRes, err := getAction(ctx, userId, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">getActionsRes := GetActionsRes{
                        UserId:   userId,
                        Explores: actionRes,
                }
                requiredSkillsResponse, err := getRequiredSkills(ctx, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">consumingItemRes, err := getConsumingItems(ctx, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">storageData, err := func(consuming []*ConsumingItem) ([]*StorageData, error) </span><span class="cov8" title="1">{
                        handleError := func(err error) ([]*StorageData, error) </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error on get storage data: %w", err)
                        }</span>
                        <span class="cov8" title="1">if len(consuming) == 0 </span><span class="cov0" title="0">{
                                return []*StorageData{}, nil
                        }</span>
                        <span class="cov8" title="1">itemIds := func(consuming []*ConsumingItem) []core.ItemId </span><span class="cov8" title="1">{
                                checkedItems := make(map[core.ItemId]bool)
                                var result []core.ItemId
                                for _, v := range consuming </span><span class="cov8" title="1">{
                                        if _, ok := checkedItems[v.ItemId]; ok </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">checkedItems[v.ItemId] = true
                                        result = append(result, v.ItemId)</span>
                                }
                                <span class="cov8" title="1">return result</span>
                        }(consumingItemRes)

                        <span class="cov8" title="1">storage, innerErr := getStorage(ctx, ToUserItemPair(userId, itemIds))
                        if innerErr != nil </span><span class="cov0" title="0">{
                                return handleError(innerErr)
                        }</span>
                        <span class="cov8" title="1">userStorage := FindStorageData(storage, userId)
                        if userStorage == nil </span><span class="cov8" title="1">{
                                return handleError(fmt.Errorf("user storage not found"))
                        }</span>
                        <span class="cov0" title="0">return userStorage.ItemData, nil</span>
                }(consumingItemRes)
                <span class="cov8" title="1">skillIds := func(requiredSkills []*RequiredSkill) []core.SkillId </span><span class="cov8" title="1">{
                        checkedItems := make(map[core.SkillId]bool)
                        var result []core.SkillId
                        for _, v := range requiredSkills </span><span class="cov8" title="1">{
                                if _, ok := checkedItems[v.SkillId]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">checkedItems[v.SkillId] = true
                                result = append(result, v.SkillId)</span>
                        }
                        <span class="cov8" title="1">return result</span>

                }(requiredSkillsResponse)
                <span class="cov8" title="1">skills, err := getUserSkill(ctx, userId, skillIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">consumingStaminaRes, err := calcConsumingStamina(ctx, userId, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">staminaMap := func(pair []*ExploreStaminaPair) map[ActionId]core.StaminaCost </span><span class="cov8" title="1">{
                        result := map[ActionId]core.StaminaCost{}
                        for _, v := range pair </span><span class="cov8" title="1">{
                                result[v.ExploreId] = v.ReducedStamina
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(consumingStaminaRes)
                <span class="cov8" title="1">explores, err := getExploreMaster(ctx, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">exploreMap := func(masters []*GetExploreMasterRes) map[ActionId]*GetExploreMasterRes </span><span class="cov8" title="1">{
                        result := make(map[ActionId]*GetExploreMasterRes)
                        for _, v := range masters </span><span class="cov8" title="1">{
                                result[v.ExploreId] = v
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(explores)
                <span class="cov8" title="1">return &amp;makeUserExploreArgs{
                        fundRes:            fund,
                        staminaRecoverTime: staminaRecoverTime,
                        maxStamina:         maxStamina,
                        currentTimer:       getCurrentTime,
                        actionsRes:         getActionsRes,
                        requiredSkillRes:   requiredSkillsResponse,
                        consumingItemRes:   consumingItemRes,
                        itemData:           storageData,
                        batchGetSkillRes:   skills,
                        exploreIds:         exploreIds,
                        calculatedStamina:  staminaMap,
                        exploreMasterMap:   exploreMap,
                }, nil</span>
        }
}

type makeUserExploreArgs struct {
        fundRes            core.Fund
        staminaRecoverTime core.StaminaRecoverTime
        maxStamina         core.MaxStamina
        currentTimer       core.GetCurrentTimeFunc
        actionsRes         GetActionsRes
        requiredSkillRes   []*RequiredSkill
        consumingItemRes   []*ConsumingItem
        itemData           []*StorageData
        batchGetSkillRes   BatchGetUserSkillRes
        exploreIds         []ActionId
        calculatedStamina  map[ActionId]core.StaminaCost
        exploreMasterMap   map[ActionId]*GetExploreMasterRes
}

type MakeUserExploreFunc func(context.Context, core.UserId, []ActionId, int) ([]*UserExplore, error)

func CreateMakeUserExplore(generateArgs GenerateMakeUserExploreArgs) MakeUserExploreFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId, exploreIds []ActionId, execNum int) ([]*UserExplore, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*UserExplore, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on make user explore: %w", err)
                }</span>
                <span class="cov8" title="1">args, err := generateArgs(ctx, userId, exploreIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">currentStamina := args.staminaRecoverTime.CalcStamina(args.currentTimer(), args.maxStamina)
                currentFund := args.fundRes
                exploreMap := func(explores []*ExploreUserData, exploreIds []ActionId) map[ActionId]*ExploreUserData </span><span class="cov8" title="1">{
                        result := make(map[ActionId]*ExploreUserData)
                        for _, v := range explores </span><span class="cov0" title="0">{
                                result[v.ExploreId] = v
                        }</span>
                        <span class="cov8" title="1">for _, v := range exploreIds </span><span class="cov8" title="1">{
                                if _, ok := result[v]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">result[v] = &amp;ExploreUserData{
                                        ExploreId: v,
                                        IsKnown:   false,
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }(args.actionsRes.Explores, exploreIds)

                <span class="cov8" title="1">skillDataToLvMap := func(arr []*UserSkillRes) map[core.SkillId]core.SkillLv </span><span class="cov8" title="1">{
                        result := make(map[core.SkillId]core.SkillLv)
                        for _, v := range arr </span><span class="cov8" title="1">{
                                result[v.SkillId] = v.SkillExp.CalcLv()
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }

                <span class="cov8" title="1">requiredSkillMap := func(rows []*RequiredSkill) map[ActionId][]*RequiredSkill </span><span class="cov8" title="1">{
                        result := make(map[ActionId][]*RequiredSkill)
                        for _, v := range rows </span><span class="cov8" title="1">{
                                result[v.ExploreId] = append(result[v.ExploreId], v)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(args.requiredSkillRes)

                <span class="cov8" title="1">consumingItemMap := func(consuming []*ConsumingItem) map[ActionId][]*ConsumingItem </span><span class="cov8" title="1">{
                        result := make(map[ActionId][]*ConsumingItem)
                        for _, v := range consuming </span><span class="cov8" title="1">{
                                result[v.ExploreId] = append(result[v.ExploreId], v)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(args.consumingItemRes)

                <span class="cov8" title="1">itemStockList := func(arr []*StorageData) map[core.ItemId]core.Stock </span><span class="cov8" title="1">{
                        result := make(map[core.ItemId]core.Stock)
                        for _, v := range arr </span><span class="cov8" title="1">{
                                result[v.ItemId] = v.Stock
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(args.itemData)

                <span class="cov8" title="1">skillLvList := skillDataToLvMap(args.batchGetSkillRes.Skills)

                result := make([]*UserExplore, len(args.exploreIds))
                for i, v := range args.exploreIds </span><span class="cov8" title="1">{
                        requiredPrice := args.exploreMasterMap[v].RequiredPayment
                        stamina := args.calculatedStamina[v]
                        isPossibleList := CheckIsExplorePossible(
                                &amp;CheckIsPossibleArgs{
                                        stamina,
                                        requiredPrice,
                                        consumingItemMap[v],
                                        requiredSkillMap[v],
                                        currentStamina,
                                        currentFund,
                                        itemStockList,
                                        skillLvList,
                                        execNum,
                                },
                        )
                        isPossible := isPossibleList[core.PossibleTypeAll]
                        isKnown := exploreMap[v].IsKnown
                        result[i] = &amp;UserExplore{
                                ExploreId:   v,
                                IsPossible:  isPossible,
                                IsKnown:     isKnown,
                                DisplayName: args.exploreMasterMap[v].DisplayName,
                        }
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package game

import (
        "github.com/asragi/RinGo/core"
        "math"
)

type ConsumptionProb float32

type GainingPoint int

func (g GainingPoint) Multiply(num int) GainingPoint <span class="cov8" title="1">{
        value := int(g)
        return GainingPoint(value * num)
}</span>

func (g GainingPoint) ApplyTo(exp core.SkillExp) core.SkillExp <span class="cov8" title="1">{
        return exp + core.SkillExp(g)
}</span>

type ActionId string

func NewActionId(id string) (ActionId, error) <span class="cov0" title="0">{
        return ActionId(id), nil
}</span>

func (id ActionId) String() string <span class="cov0" title="0">{
        return string(id)
}</span>

type StaminaReducibleRate float64

func ApplyReduction(s core.StaminaCost, reductionRate float64, reducibleRate StaminaReducibleRate) core.StaminaCost <span class="cov8" title="1">{
        constStamina := float64(s) * (1.0 - float64(reducibleRate))
        varyStamina := float64(s) * reductionRate * float64(reducibleRate)
        staminaRounded := int(math.Max(1, math.Round(constStamina+varyStamina)))
        return core.StaminaCost(staminaRounded)
}</span>

type EarningProb float32

type PricePenalty float32

func NewPricePenalty(basePrice core.Price) PricePenalty <span class="cov0" title="0">{
        // 100 -&gt; 1, 10000 -&gt; 2, 1000000 -&gt; 3
        return PricePenalty(math.Log10(float64(basePrice)) / 2)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package game

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type getPostActionRepositories struct {
        FetchResource              GetResourceFunc
        FetchExploreMaster         FetchExploreMasterFunc
        FetchSkillMaster           FetchSkillMasterFunc
        FetchSkillGrowthData       FetchSkillGrowthData
        FetchUserSkill             FetchUserSkillFunc
        FetchEarningItem           FetchEarningItemFunc
        FetchConsumingItem         FetchConsumingItemFunc
        FetchRequiredSkill         FetchRequiredSkillsFunc
        FetchStorage               FetchStorageFunc
        FetchItemMaster            FetchItemMasterFunc
        FetchStaminaReductionSkill FetchReductionStaminaSkillFunc
}

type GeneratePostActionArgsFunc func(context.Context, core.UserId, int, ActionId) (*postActionArgs, error)

func CreateGeneratePostActionArgs(
        fetchResource GetResourceFunc,
        fetchExploreMaster FetchExploreMasterFunc,
        fetchSkillMaster FetchSkillMasterFunc,
        fetchSkillGrowthData FetchSkillGrowthData,
        fetchUserSkill FetchUserSkillFunc,
        fetchEarningItem FetchEarningItemFunc,
        fetchConsumingItem FetchConsumingItemFunc,
        fetchRequiredSkill FetchRequiredSkillsFunc,
        fetchStorage FetchStorageFunc,
        fetchItemMaster FetchItemMasterFunc,
        fetchStaminaReductionSkill FetchReductionStaminaSkillFunc,
) GeneratePostActionArgsFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                execCount int,
                exploreId ActionId,
        ) (*postActionArgs, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*postActionArgs, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on creating post action args: %w", err)
                }</span>
                <span class="cov8" title="1">userResources, err := fetchResource(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">exploreMasters, err := fetchExploreMaster(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">skillGrowthList, err := fetchSkillGrowthData(ctx, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">skillIds := func(data []*SkillGrowthData) []core.SkillId </span><span class="cov8" title="1">{
                        result := make([]core.SkillId, len(data))
                        for i, v := range data </span><span class="cov0" title="0">{
                                result[i] = v.SkillId
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(skillGrowthList)
                <span class="cov8" title="1">skillsRes, err := fetchUserSkill(ctx, userId, skillIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">earningItemData, err := fetchEarningItem(ctx, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">consumingItem, err := fetchConsumingItem(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemIds := func(earningItems []*EarningItem, consumingItem []*ConsumingItem) []core.ItemId </span><span class="cov8" title="1">{
                        var result []core.ItemId
                        check := map[core.ItemId]bool{}
                        for _, v := range earningItems </span><span class="cov0" title="0">{
                                if _, ok := check[v.ItemId]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">check[v.ItemId] = true
                                result = append(result, v.ItemId)</span>
                        }

                        <span class="cov8" title="1">for _, v := range consumingItem </span><span class="cov0" title="0">{
                                if _, ok := check[v.ItemId]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">check[v.ItemId] = true
                                result = append(result, v.ItemId)</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }(earningItemData, consumingItem)
                <span class="cov8" title="1">storageRes, err := fetchStorage(ctx, ToUserItemPair(userId, itemIds))
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">storageData := FillStorageData(storageRes, ToUserItemPair(userId, itemIds))
                userStorage := FindStorageData(storageData, userId)
                itemStorage := func() []*StorageData </span><span class="cov8" title="1">{
                        if userStorage == nil </span><span class="cov8" title="1">{
                                return []*StorageData{}
                        }</span>
                        <span class="cov0" title="0">return userStorage.ItemData</span>
                }()

                <span class="cov8" title="1">itemMaster, err := fetchItemMaster(ctx, itemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">requiredSkills, err := fetchRequiredSkill(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">skillMaster, err := fetchSkillMaster(ctx, skillIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">reductionSkills, err := fetchStaminaReductionSkill(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">allReductionSkillId := func() []core.SkillId </span><span class="cov8" title="1">{
                        result := make([]core.SkillId, len(reductionSkills))
                        for i, v := range reductionSkills </span><span class="cov0" title="0">{
                                result[i] = v.SkillId
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                // TODO: FetchUserSkill is called twice in this function.
                <span class="cov8" title="1">reductionUserSkills, err := fetchUserSkill(ctx, userId, allReductionSkillId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;postActionArgs{
                        userId:                 userId,
                        exploreId:              exploreId,
                        execCount:              execCount,
                        userFund:               userResources.Fund,
                        userStamina:            userResources.StaminaRecoverTime,
                        exploreMaster:          exploreMasters[0],
                        skillGrowthList:        skillGrowthList,
                        skillsRes:              skillsRes,
                        skillMaster:            skillMaster,
                        earningItemData:        earningItemData,
                        consumingItemData:      consumingItem,
                        requiredSkills:         requiredSkills,
                        allStorageItems:        itemStorage,
                        allItemMasterRes:       itemMaster,
                        staminaReductionSkills: reductionUserSkills.Skills,
                }, nil</span>
        }
}

type skillGrowthInformation struct {
        DisplayName  core.DisplayName
        GrowthResult *growthApplyResult
}

type PostActionResult struct {
        EarnedItems            []*EarnedItem
        ConsumedItems          []*ConsumedItem
        SkillGrowthInformation []*skillGrowthInformation
        AfterFund              core.Fund
        AfterStamina           core.StaminaRecoverTime
}

type postActionArgs struct {
        userId                 core.UserId
        exploreId              ActionId
        execCount              int
        userFund               core.Fund
        userStamina            core.StaminaRecoverTime
        exploreMaster          *GetExploreMasterRes
        skillGrowthList        []*SkillGrowthData
        skillsRes              BatchGetUserSkillRes
        skillMaster            []*SkillMaster
        earningItemData        []*EarningItem
        consumingItemData      []*ConsumingItem
        requiredSkills         []*RequiredSkill
        allStorageItems        []*StorageData
        allItemMasterRes       []*GetItemMasterRes
        staminaReductionSkills []*UserSkillRes
}

type PostActionFunc func(context.Context, core.UserId, int, ActionId) (*PostActionResult, error)

func CreatePostAction(
        generateArgs GeneratePostActionArgsFunc,
        calcSkillGrowth CalcSkillGrowthFunc,
        calcGrowthApply GrowthApplyFunc,
        calcEarnedItem CalcEarnedItemFunc,
        calcConsumedItem CalcConsumedItemFunc,
        calcTotalItem CalcTotalItemFunc,
        calcStaminaReduction CalcStaminaReductionFunc,
        updateItemStorage UpdateItemStorageFunc,
        updateSkill UpdateUserSkillExpFunc,
        updateStamina UpdateStaminaFunc,
        updateFund UpdateFundFunc,
        random core.EmitRandomFunc,
) PostActionFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                execCount int,
                exploreId ActionId,
        ) (*PostActionResult, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*PostActionResult, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on post action: %w", err)
                }</span>
                <span class="cov8" title="1">args, err := generateArgs(ctx, userId, execCount, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">skillGrowth := calcSkillGrowth(args.execCount, args.skillGrowthList)
                applySkillGrowth := calcGrowthApply(args.skillsRes.Skills, skillGrowth)
                skillGrowthReq := convertToSkillGrowthPost(userId, applySkillGrowth)

                earnedItems := calcEarnedItem(args.execCount, args.earningItemData, random)
                consumedItems := calcConsumedItem(args.execCount, args.consumingItemData, random)
                calculatedTotalItem := calcTotalItem(
                        args.allStorageItems,
                        args.allItemMasterRes,
                        earnedItems,
                        consumedItems,
                )

                currentStaminaRecoverTime := args.userStamina
                requiredStamina := calcStaminaReduction(
                        args.exploreMaster.ConsumingStamina,
                        args.exploreMaster.StaminaReducibleRate,
                        args.staminaReductionSkills,
                )
                afterStaminaTime := core.CalcAfterStamina(
                        currentStaminaRecoverTime,
                        requiredStamina,
                )
                currentFund := args.userFund
                requiredCost := args.exploreMaster.RequiredPayment
                afterFund, err := currentFund.ReduceFund(requiredCost)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">toStorageData := func(userId core.UserId, totalItem []*totalItem) []*StorageData </span><span class="cov8" title="1">{
                        result := make([]*StorageData, len(totalItem))
                        for i, v := range totalItem </span><span class="cov0" title="0">{
                                result[i] = &amp;StorageData{
                                        UserId:  userId,
                                        ItemId:  v.ItemId,
                                        Stock:   v.Stock,
                                        IsKnown: true,
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(userId, calculatedTotalItem)
                <span class="cov8" title="1">err = updateItemStorage(ctx, toStorageData)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateStamina(ctx, userId, afterStaminaTime)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateFund(ctx, []*UserFundPair{{UserId: userId, Fund: afterFund}})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">execUpdateSkill := func() error </span><span class="cov8" title="1">{
                        if len(skillGrowthReq) == 0 </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return updateSkill(
                                ctx,
                                SkillGrowthPost{
                                        UserId:      args.userId,
                                        SkillGrowth: skillGrowthReq,
                                },
                        )</span>
                }
                <span class="cov8" title="1">err = execUpdateSkill()
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">postResult := func(
                        earnedItem []*EarnedItem,
                        consumedItem []*ConsumedItem,
                        skillMaster []*SkillMaster,
                        skillGrowth []*growthApplyResult,
                        afterFund core.Fund,
                        afterStamina core.StaminaRecoverTime,
                ) PostActionResult </span><span class="cov8" title="1">{
                        growthInfo := convertToGrowthInfo(skillMaster, skillGrowth)
                        return PostActionResult{
                                EarnedItems:            earnedItem,
                                ConsumedItems:          consumedItem,
                                SkillGrowthInformation: growthInfo,
                                AfterFund:              afterFund,
                                AfterStamina:           afterStamina,
                        }
                }</span>(
                        earnedItems,
                        consumedItems,
                        args.skillMaster,
                        applySkillGrowth,
                        afterFund,
                        afterStaminaTime,
                )
                <span class="cov8" title="1">return &amp;postResult, nil</span>
        }
}

func convertToGrowthInfo(
        skillMaster []*SkillMaster,
        skillGrowth []*growthApplyResult,
) []*skillGrowthInformation <span class="cov8" title="1">{
        idArr := func(skillMaster []*SkillMaster) map[int]core.SkillId </span><span class="cov8" title="1">{
                result := map[int]core.SkillId{}
                for i, v := range skillMaster </span><span class="cov0" title="0">{
                        result[i] = v.SkillId
                }</span>
                <span class="cov8" title="1">return result</span>
        }(skillMaster)
        <span class="cov8" title="1">skillMasterMap := func(skillMaster []*SkillMaster) map[core.SkillId]*SkillMaster </span><span class="cov8" title="1">{
                result := map[core.SkillId]*SkillMaster{}
                for _, v := range skillMaster </span><span class="cov0" title="0">{
                        result[v.SkillId] = v
                }</span>
                <span class="cov8" title="1">return result</span>
        }(skillMaster)
        <span class="cov8" title="1">skillGrowthMap := func(skillGrowth []*growthApplyResult) map[core.SkillId]*growthApplyResult </span><span class="cov8" title="1">{
                result := map[core.SkillId]*growthApplyResult{}
                for _, v := range skillGrowth </span><span class="cov0" title="0">{
                        result[v.SkillId] = v
                }</span>
                <span class="cov8" title="1">return result</span>
        }(skillGrowth)
        <span class="cov8" title="1">result := make([]*skillGrowthInformation, len(idArr))
        for i := 0; i &lt; len(idArr); i++ </span><span class="cov0" title="0">{
                id := idArr[i]
                master := skillMasterMap[id]
                growth := skillGrowthMap[id]
                result[i] = &amp;skillGrowthInformation{
                        DisplayName:  master.DisplayName,
                        GrowthResult: growth,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}

func convertToSkillGrowthPost(userId core.UserId, skillGrowth []*growthApplyResult) []*SkillGrowthPostRow <span class="cov8" title="1">{
        result := make([]*SkillGrowthPostRow, len(skillGrowth))
        for i, v := range skillGrowth </span><span class="cov0" title="0">{
                result[i] = &amp;SkillGrowthPostRow{
                        UserId:   userId,
                        SkillId:  v.SkillId,
                        SkillExp: v.AfterExp,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package game

import (
        "context"
        "github.com/asragi/RinGo/core"
)

type (
        GetResourceRes struct {
                UserId             core.UserId             `db:"user_id"`
                MaxStamina         core.MaxStamina         `db:"max_stamina"`
                StaminaRecoverTime core.StaminaRecoverTime `db:"stamina_recover_time"`
                Fund               core.Fund               `db:"fund"`
        }
        GetResourceFunc func(context.Context, core.UserId) (*GetResourceRes, error)
        StaminaRes      struct {
                UserId             core.UserId             `db:"user_id"`
                MaxStamina         core.MaxStamina         `db:"max_stamina"`
                StaminaRecoverTime core.StaminaRecoverTime `db:"stamina_recover_time"`
        }
        FetchStaminaFunc func(context.Context, []core.UserId) ([]*StaminaRes, error)
        FundRes          struct {
                UserId core.UserId `db:"user_id"`
                Fund   core.Fund   `db:"fund"`
        }
        FetchFundFunc func(context.Context, []core.UserId) ([]*FundRes, error)
        UserFundPair  struct {
                UserId core.UserId `db:"user_id"`
                Fund   core.Fund   `db:"fund"`
        }
        UpdateFundFunc    func(context.Context, []*UserFundPair) error
        UpdateStaminaFunc func(context.Context, core.UserId, core.StaminaRecoverTime) error
)

func FundPairToUserId(pairs []*UserFundPair) ([]core.UserId, []core.Fund) <span class="cov0" title="0">{
        userId := make([]core.UserId, len(pairs))
        fund := make([]core.Fund, len(pairs))
        for i, v := range pairs </span><span class="cov0" title="0">{
                userId[i] = v.UserId
                fund[i] = v.Fund
        }</span>
        <span class="cov0" title="0">return userId, fund</span>
}

type GetItemMasterRes struct {
        ItemId      core.ItemId      `db:"item_id" json:"item_id"`
        Price       core.Price       `db:"price" json:"price"`
        DisplayName core.DisplayName `db:"display_name" json:"display_name"`
        Description core.Description `db:"description" json:"description"`
        MaxStock    core.MaxStock    `db:"max_stock" json:"max_stock"`
}

func ItemMasterResToMap(res []*GetItemMasterRes) map[core.ItemId]*GetItemMasterRes <span class="cov8" title="1">{
        result := make(map[core.ItemId]*GetItemMasterRes)
        for _, v := range res </span><span class="cov8" title="1">{
                result[v.ItemId] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

type FetchItemMasterFunc func(context.Context, []core.ItemId) ([]*GetItemMasterRes, error)

type StorageData struct {
        UserId  core.UserId  `db:"user_id"`
        ItemId  core.ItemId  `db:"item_id"`
        Stock   core.Stock   `db:"stock"`
        IsKnown core.IsKnown `db:"is_known"`
}

func totalItemStockToStorageData(userId core.UserId, totalItems []*totalItem) []*StorageData <span class="cov8" title="1">{
        result := make([]*StorageData, len(totalItems))
        for i, v := range totalItems </span><span class="cov0" title="0">{
                result[i] = &amp;StorageData{
                        UserId: userId,
                        ItemId: v.ItemId,
                        Stock:  v.Stock,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}

type BatchGetStorageRes struct {
        UserId   core.UserId
        ItemData []*StorageData
}

func SpreadGetStorageRes(res []*BatchGetStorageRes) []*StorageData <span class="cov0" title="0">{
        result := make([]*StorageData, 0)
        for _, v := range res </span><span class="cov0" title="0">{
                result = append(result, v.ItemData...)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func FindItemStorageData(data []*StorageData, itemId core.ItemId) *StorageData <span class="cov0" title="0">{
        for _, v := range data </span><span class="cov0" title="0">{
                if v.ItemId == itemId </span><span class="cov0" title="0">{
                        return v
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func FindStorageData(res []*BatchGetStorageRes, userId core.UserId) *BatchGetStorageRes <span class="cov8" title="1">{
        for _, v := range res </span><span class="cov8" title="1">{
                if v.UserId == userId </span><span class="cov0" title="0">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func StorageDataToMap(res []*BatchGetStorageRes) map[core.UserId]map[core.ItemId]*StorageData <span class="cov0" title="0">{
        result := make(map[core.UserId]map[core.ItemId]*StorageData)
        for _, v := range res </span><span class="cov0" title="0">{
                result[v.UserId] = make(map[core.ItemId]*StorageData)
                for _, item := range v.ItemData </span><span class="cov0" title="0">{
                        result[v.UserId][item.ItemId] = item
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

type UserItemPair struct {
        UserId core.UserId `db:"user_id"`
        ItemId core.ItemId `db:"item_id"`
}

func ToUserItemPair(userId core.UserId, itemIds []core.ItemId) []*UserItemPair <span class="cov8" title="1">{
        result := make([]*UserItemPair, len(itemIds))
        for i, v := range itemIds </span><span class="cov8" title="1">{
                result[i] = &amp;UserItemPair{
                        UserId: userId,
                        ItemId: v,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}

type FetchStorageFunc func(context.Context, []*UserItemPair) ([]*BatchGetStorageRes, error)

func FillStorageData(res []*BatchGetStorageRes, userIdPair []*UserItemPair) []*BatchGetStorageRes <span class="cov8" title="1">{
        userIds := func() []core.UserId </span><span class="cov8" title="1">{
                check := make(map[core.UserId]bool)
                var result []core.UserId
                for _, v := range userIdPair </span><span class="cov0" title="0">{
                        if _, ok := check[v.UserId]; ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">check[v.UserId] = true
                        result = append(result, v.UserId)</span>
                }
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">result := make([]*BatchGetStorageRes, len(userIds))
        for i, userId := range userIds </span><span class="cov0" title="0">{
                itemIds := func() []core.ItemId </span><span class="cov0" title="0">{
                        check := make(map[core.ItemId]bool)
                        var result []core.ItemId
                        for _, v := range userIdPair </span><span class="cov0" title="0">{
                                if v.UserId != userId </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if _, ok := check[v.ItemId]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">check[v.ItemId] = true
                                result = append(result, v.ItemId)</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }()
                <span class="cov0" title="0">storageData := make([]*StorageData, len(itemIds))
                for j, itemId := range itemIds </span><span class="cov0" title="0">{
                        storage := FindStorageData(res, userId)
                        if storage == nil </span><span class="cov0" title="0">{
                                storage = &amp;BatchGetStorageRes{
                                        UserId:   userId,
                                        ItemData: make([]*StorageData, 0),
                                }
                        }</span>
                        <span class="cov0" title="0">storageData[j] = FindItemStorageData(storage.ItemData, itemId)
                        if storageData[j] == nil </span><span class="cov0" title="0">{
                                storageData[j] = &amp;StorageData{
                                        UserId:  userId,
                                        ItemId:  itemId,
                                        Stock:   0,
                                        IsKnown: false,
                                }
                        }</span>
                }
                <span class="cov0" title="0">result[i] = &amp;BatchGetStorageRes{
                        UserId:   userId,
                        ItemData: storageData,
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

type FetchAllStorageFunc func(context.Context, core.UserId) ([]*StorageData, error)

type UpdateItemStorageFunc func(context.Context, []*StorageData) error

type SkillMaster struct {
        SkillId     core.SkillId     `db:"skill_id"`
        DisplayName core.DisplayName `db:"display_name"`
}

type FetchSkillMasterFunc func(context.Context, []core.SkillId) ([]*SkillMaster, error)

type UserSkillRes struct {
        UserId   core.UserId   `db:"user_id"`
        SkillId  core.SkillId  `db:"skill_id"`
        SkillExp core.SkillExp `db:"skill_exp"`
}

type BatchGetUserSkillRes struct {
        UserId core.UserId
        Skills []*UserSkillRes
}

type FetchUserSkillFunc func(context.Context, core.UserId, []core.SkillId) (BatchGetUserSkillRes, error)

type SkillGrowthData struct {
        ExploreId    ActionId     `db:"explore_id"`
        SkillId      core.SkillId `db:"skill_id"`
        GainingPoint GainingPoint `db:"gaining_point"`
}

type FetchSkillGrowthData func(context.Context, ActionId) ([]*SkillGrowthData, error)

type SkillGrowthPostRow struct {
        UserId   core.UserId   `db:"user_id"`
        SkillId  core.SkillId  `db:"skill_id"`
        SkillExp core.SkillExp `db:"skill_exp"`
}

type SkillGrowthPost struct {
        UserId      core.UserId `db:"user_id"`
        SkillGrowth []*SkillGrowthPostRow
}

type UpdateUserSkillExpFunc func(context.Context, SkillGrowthPost) error

type RequiredSkill struct {
        ExploreId  ActionId     `db:"explore_id"`
        SkillId    core.SkillId `db:"skill_id"`
        RequiredLv core.SkillLv `db:"skill_lv"`
}

type FetchRequiredSkillsFunc func(context.Context, []ActionId) ([]*RequiredSkill, error)

type RequiredSkillRow struct {
        ExploreId      ActionId
        RequiredSkills []RequiredSkill
}

type ConsumingItem struct {
        ExploreId       ActionId        `db:"explore_id"`
        ItemId          core.ItemId     `db:"item_id"`
        MaxCount        core.Count      `db:"max_count"`
        ConsumptionProb ConsumptionProb `db:"consumption_prob"`
}

type FetchConsumingItemFunc func(context.Context, []ActionId) ([]*ConsumingItem, error)

type StaminaReductionSkillPair struct {
        ExploreId ActionId     `db:"explore_id"`
        SkillId   core.SkillId `db:"skill_id"`
}

type FetchReductionStaminaSkillFunc func(context.Context, []ActionId) ([]*StaminaReductionSkillPair, error)

func ReductionStaminaSkillToMap(res []*StaminaReductionSkillPair) map[ActionId][]core.SkillId <span class="cov0" title="0">{
        result := make(map[ActionId][]core.SkillId)
        for _, v := range res </span><span class="cov0" title="0">{
                result[v.ExploreId] = append(result[v.ExploreId], v.SkillId)
        }</span>
        <span class="cov0" title="0">return result</span>
}

type EarningItem struct {
        ItemId      core.ItemId `db:"item_id"`
        MinCount    core.Count  `db:"min_count"`
        MaxCount    core.Count  `db:"max_count"`
        Probability EarningProb `db:"probability"`
}

type FetchEarningItemFunc func(context.Context, ActionId) ([]*EarningItem, error)

type GetExploreMasterRes struct {
        ExploreId            ActionId             `db:"explore_id"`
        DisplayName          core.DisplayName     `db:"display_name"`
        Description          core.Description     `db:"description"`
        ConsumingStamina     core.StaminaCost     `db:"consuming_stamina"`
        RequiredPayment      core.Cost            `db:"required_payment"`
        StaminaReducibleRate StaminaReducibleRate `db:"stamina_reducible_rate"`
}

type FetchExploreMasterFunc func(context.Context, []ActionId) ([]*GetExploreMasterRes, error)

type UserExplore struct {
        ExploreId   ActionId
        DisplayName core.DisplayName
        IsKnown     core.IsKnown
        IsPossible  core.IsPossible
}

type ExploreUserData struct {
        ExploreId ActionId     `db:"explore_id"`
        IsKnown   core.IsKnown `db:"is_known"`
}

type GetUserExploreFunc func(context.Context, core.UserId, []ActionId) ([]*ExploreUserData, error)

type GetActionsRes struct {
        UserId   core.UserId
        Explores []*ExploreUserData
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package game

import (
        "github.com/asragi/RinGo/core"
)

func RequiredSkillsToIdArray(requiredSkills []*RequiredSkill) []core.SkillId <span class="cov0" title="0">{
        result := make([]core.SkillId, len(requiredSkills))
        for i, skill := range requiredSkills </span><span class="cov0" title="0">{
                result[i] = skill.SkillId
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ConsumingItemsToIdArray(consumingItems []*ConsumingItem) []core.ItemId <span class="cov0" title="0">{
        result := make([]core.ItemId, len(consumingItems))
        for i, item := range consumingItems </span><span class="cov0" title="0">{
                result[i] = item.ItemId
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package game

import "github.com/asragi/RinGo/core"

type Services struct {
        ValidateAction       ValidateActionFunc
        PostAction           PostActionFunc
        MakeUserExplore      MakeUserExploreFunc
        CalcConsumingStamina CalcConsumingStaminaFunc
        GetItemList          GetItemListFunc
}

func createPostActionService(
        fetchResource GetResourceFunc,
        fetchExploreMaster FetchExploreMasterFunc,
        fetchSkillMaster FetchSkillMasterFunc,
        fetchSkillGrowthData FetchSkillGrowthData,
        fetchUserSkill FetchUserSkillFunc,
        fetchEarningItem FetchEarningItemFunc,
        fetchConsumingItem FetchConsumingItemFunc,
        fetchRequiredSkill FetchRequiredSkillsFunc,
        fetchStorage FetchStorageFunc,
        fetchItemMaster FetchItemMasterFunc,
        fetchReductionStamina FetchReductionStaminaSkillFunc,
        updateStorage UpdateItemStorageFunc,
        updateSkill UpdateUserSkillExpFunc,
        updateStamina UpdateStaminaFunc,
        updateFund UpdateFundFunc,
        emitRandom core.EmitRandomFunc,
) PostActionFunc <span class="cov0" title="0">{
        generateArgs := CreateGeneratePostActionArgs(
                fetchResource,
                fetchExploreMaster,
                fetchSkillMaster,
                fetchSkillGrowthData,
                fetchUserSkill,
                fetchEarningItem,
                fetchConsumingItem,
                fetchRequiredSkill,
                fetchStorage,
                fetchItemMaster,
                fetchReductionStamina,
        )
        return CreatePostAction(
                generateArgs,
                CalcSkillGrowthService,
                CalcApplySkillGrowth,
                CalcEarnedItem,
                CalcConsumedItem,
                CalcTotalItem,
                CalcStaminaReduction,
                updateStorage,
                updateSkill,
                updateStamina,
                updateFund,
                emitRandom,
        )
}</span>

func createMakeUserExplore(
        fetchResource GetResourceFunc,
        fetchAction GetUserExploreFunc,
        fetchRequiredSkills FetchRequiredSkillsFunc,
        fetchConsumingItems FetchConsumingItemFunc,
        fetchStorage FetchStorageFunc,
        fetchUserSkill FetchUserSkillFunc,
        calcConsumingStamina CalcConsumingStaminaFunc,
        fetchExploreMaster FetchExploreMasterFunc,
        getTime core.GetCurrentTimeFunc,
) MakeUserExploreFunc <span class="cov0" title="0">{
        generateArgs := CreateGenerateMakeUserExploreArgs(
                fetchResource,
                fetchAction,
                fetchRequiredSkills,
                fetchConsumingItems,
                fetchStorage,
                fetchUserSkill,
                calcConsumingStamina,
                fetchExploreMaster,
                getTime,
        )
        return CreateMakeUserExplore(generateArgs)
}</span>

func createCalcConsumingStamina(
        fetchUserSkill FetchUserSkillFunc,
        fetchExploreMaster FetchExploreMasterFunc,
        fetchReductionSkills FetchReductionStaminaSkillFunc,
) CalcConsumingStaminaFunc <span class="cov0" title="0">{
        return CreateCalcConsumingStaminaService(
                fetchUserSkill,
                fetchExploreMaster,
                fetchReductionSkills,
        )
}</span>

func CreateServices(
        fetchResource GetResourceFunc,
        fetchExploreMaster FetchExploreMasterFunc,
        fetchSkillMaster FetchSkillMasterFunc,
        fetchSkillGrowthData FetchSkillGrowthData,
        fetchUserSkill FetchUserSkillFunc,
        fetchEarningItem FetchEarningItemFunc,
        fetchConsumingItem FetchConsumingItemFunc,
        fetchRequiredSkill FetchRequiredSkillsFunc,
        fetchStorage FetchStorageFunc,
        fetchAllStorage FetchAllStorageFunc,
        fetchItemMaster FetchItemMasterFunc,
        fetchReductionStamina FetchReductionStaminaSkillFunc,
        fetchUserExplore GetUserExploreFunc,
        updateStorage UpdateItemStorageFunc,
        updateSkill UpdateUserSkillExpFunc,
        updateStamina UpdateStaminaFunc,
        updateFund UpdateFundFunc,
        emitRandom core.EmitRandomFunc,
        getTime core.GetCurrentTimeFunc,
) *Services <span class="cov0" title="0">{
        validateAction := CreateValidateAction(
                fetchResource,
                fetchExploreMaster,
                fetchConsumingItem,
                fetchRequiredSkill,
                fetchUserSkill,
                fetchStorage,
                getTime,
        )
        postAction := createPostActionService(
                fetchResource,
                fetchExploreMaster,
                fetchSkillMaster,
                fetchSkillGrowthData,
                fetchUserSkill,
                fetchEarningItem,
                fetchConsumingItem,
                fetchRequiredSkill,
                fetchStorage,
                fetchItemMaster,
                fetchReductionStamina,
                updateStorage,
                updateSkill,
                updateStamina,
                updateFund,
                emitRandom,
        )
        calcConsumingStamina := createCalcConsumingStamina(
                fetchUserSkill,
                fetchExploreMaster,
                fetchReductionStamina,
        )
        makeUserExplore := createMakeUserExplore(
                fetchResource,
                fetchUserExplore,
                fetchRequiredSkill,
                fetchConsumingItem,
                fetchStorage,
                fetchUserSkill,
                calcConsumingStamina,
                fetchExploreMaster,
                getTime,
        )
        getItemList := CreateGetItemListService(
                fetchAllStorage,
                fetchItemMaster,
        )

        return &amp;Services{
                ValidateAction:       validateAction,
                PostAction:           postAction,
                MakeUserExplore:      makeUserExplore,
                CalcConsumingStamina: calcConsumingStamina,
                GetItemList:          getItemList,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package shelf

import (
        "fmt"
        "github.com/asragi/RinGo/core"
)

type purchaseArgs struct {
        userFund      core.Fund
        targetFund    core.Fund
        userStock     core.Stock
        targetStock   core.Stock
        maxStock      core.MaxStock
        totalCost     core.Cost
        profit        core.Profit
        purchaseCount core.Count
}
type purchaseResult struct {
        userFundAfter    core.Fund
        targetFundAfter  core.Fund
        userStockAfter   core.Stock
        targetStockAfter core.Stock
}

type CalcPurchaseFunc func(args *purchaseArgs) (*purchaseResult, error)

func calcPurchase(args purchaseArgs) (*purchaseResult, error) <span class="cov0" title="0">{
        handleError := func(err error) (*purchaseResult, error) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calc purchase: %w", err)
        }</span>
        <span class="cov0" title="0">userFundAfter, err := args.userFund.ReduceFund(args.totalCost)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err)
        }</span>
        <span class="cov0" title="0">targetFundAfter := args.targetFund.AddFund(args.profit)
        userStockAfter := args.userStock.AddStock(args.purchaseCount, args.maxStock)
        targetStockAfter, err := args.targetStock.SubStock(args.purchaseCount)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err)
        }</span>
        <span class="cov0" title="0">return &amp;purchaseResult{
                userFundAfter:    userFundAfter,
                targetFundAfter:  targetFundAfter,
                userStockAfter:   userStockAfter,
                targetStockAfter: targetStockAfter,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type GetShelfFunc func(
        context.Context,
        []core.UserId,
) ([]*Shelf, error)

func CreateGetShelves(
        fetchShelf FetchShelf,
        fetchItemMaster game.FetchItemMasterFunc,
        fetchStorage game.FetchStorageFunc,
) GetShelfFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userIds []core.UserId,
        ) ([]*Shelf, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*Shelf, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("getting shelf: %w", err)
                }</span>
                <span class="cov8" title="1">shelfRepoRows, err := fetchShelf(ctx, userIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userItemPair := shelfRowToUserItemPair(shelfRepoRows)
                itemIds := shelvesToItemIds(shelfRepoRows)
                shelvesMap := shelvesToMap(shelfRepoRows)
                itemMasters, err := fetchItemMaster(ctx, itemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemMasterMap := game.ItemMasterResToMap(itemMasters)

                storageData, err := fetchStorage(ctx, userItemPair)
                storageMap := game.StorageDataToMap(storageData)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">var result []*Shelf
                for _, userId := range userIds </span><span class="cov8" title="1">{
                        shelf := shelvesMap[userId]
                        for _, row := range shelf </span><span class="cov8" title="1">{
                                displayName := func() core.DisplayName </span><span class="cov8" title="1">{
                                        if row.ItemId == core.EmptyItemId </span><span class="cov8" title="1">{
                                                return ""
                                        }</span>
                                        <span class="cov8" title="1">return itemMasterMap[row.ItemId].DisplayName</span>
                                }()
                                <span class="cov8" title="1">stock := func() core.Stock </span><span class="cov8" title="1">{
                                        if row.ItemId == core.EmptyItemId </span><span class="cov8" title="1">{
                                                return 0
                                        }</span>
                                        <span class="cov8" title="1">return storageMap[userId][row.ItemId].Stock</span>
                                }()
                                <span class="cov8" title="1">price := func() core.Price </span><span class="cov8" title="1">{
                                        if row.ItemId == core.EmptyItemId </span><span class="cov8" title="1">{
                                                return 0
                                        }</span>
                                        <span class="cov8" title="1">return itemMasterMap[row.ItemId].Price</span>
                                }()
                                <span class="cov8" title="1">result = append(
                                        result, &amp;Shelf{
                                                Id:          row.Id,
                                                UserId:      userId,
                                                ItemId:      row.ItemId,
                                                DisplayName: displayName,
                                                Index:       row.Index,
                                                SetPrice:    row.SetPrice,
                                                Stock:       stock,
                                                TotalSales:  row.TotalSales,
                                                Price:       price,
                                        },
                                )</span>
                        }
                }
                <span class="cov8" title="1">return result, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type InitializeShelfFunc func(context.Context, core.UserId) error

func CreateInitializeShelf(
        insertEmptyShelf InsertEmptyShelfFunc,
        generateId core.GenerateUUIDFunc,
) InitializeShelfFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("initializing shelf: %w", err)
                }</span>
                <span class="cov0" title="0">emptyShelf := &amp;ShelfRepoRow{
                        Id:         Id(generateId()),
                        UserId:     userId,
                        ItemId:     core.EmptyItemId,
                        Index:      0,
                        SetPrice:   0,
                        TotalSales: 0,
                }
                err := insertEmptyShelf(ctx, userId, []*ShelfRepoRow{emptyShelf})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package shelf

import (
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/utils"
        "math"
)

type (
        Id       string
        Size     int
        Index    int
        SetPrice core.Price
        Shelf    struct {
                Id          Id
                ItemId      core.ItemId
                UserId      core.UserId
                Index       Index
                DisplayName core.DisplayName
                Stock       core.Stock
                SetPrice    SetPrice
                Price       core.Price
                TotalSales  core.SalesFigures
        }
)

func (id Id) String() string <span class="cov0" title="0">{
        return string(id)
}</span>

func (p SetPrice) CalculateProfit(purchaseNum core.Count) core.Profit <span class="cov0" title="0">{
        return core.Profit(int(p) * int(purchaseNum))
}</span>

func (s Size) Equals(other Size) bool <span class="cov0" title="0">{
        return s == other
}</span>

func (s Size) ValidSize() bool <span class="cov0" title="0">{
        const MaxSize Size = 8
        const MinSize Size = 0
        return s &gt;= MinSize &amp;&amp; s &lt;= MaxSize
}</span>

func NewPopularityGain(price core.Price, setPrice SetPrice) PopularityChange <span class="cov0" title="0">{
        const percent = 0.01
        const BasePopularityGain = 0.1 * percent
        const MinPopularityGain = 0.005 * percent
        const MaxPopularityGain = 0.5 * percent
        priceEffect := math.Pow(2, math.Log10(float64(price)/100))
        setPriceEffect := float64(price) / float64(setPrice)
        return PopularityChange(
                utils.Clamp(
                        BasePopularityGain*priceEffect*setPriceEffect,
                        MinPopularityGain,
                        MaxPopularityGain,
                ),
        )
}</span>

func NewPopularityLost(price core.Price, setPrice SetPrice) PopularityChange <span class="cov0" title="0">{
        const lostRate = 2
        return -1 * lostRate * NewPopularityGain(price, setPrice)
}</span>

type PopularityChange float64

// ShopPopularity ranges from 0 to 1
type ShopPopularity float64

func (p ShopPopularity) AddPopularityChange(change PopularityChange) ShopPopularity <span class="cov0" title="0">{
        return ShopPopularity(utils.Clamp(float64(p)+float64(change), 0, 1))
}</span>

type SoldItem struct {
        UserId      core.UserId
        SetPrice    SetPrice
        Popularity  ShopPopularity
        PurchaseNum core.Count
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package ranking

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/utils"
)

type UserDailyRanking struct {
        UserId     core.UserId
        UserName   core.Name
        ShopName   core.Name
        Rank       Rank
        TotalScore TotalScore
        Shelves    []*shelf.Shelf
}

type FetchUserDailyRanking func(context.Context, core.Limit, core.Offset) ([]*UserDailyRanking, error)

func CreateFetchUserDailyRanking(
        fetchUserName core.FetchUserNameFunc,
        fetchUserDailyRanking FetchUserDailyRankingRepo,
        fetchTotalScore FetchUserScore,
        fetchPeriod FetchLatestRankPeriod,
        getShelfService shelf.GetShelfFunc,
) FetchUserDailyRanking <span class="cov8" title="1">{
        return func(ctx context.Context, limit core.Limit, offset core.Offset) ([]*UserDailyRanking, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*UserDailyRanking, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch user daily ranking: %w", err)
                }</span>
                <span class="cov8" title="1">latestPeriod, err := fetchPeriod(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">rankingData, err := fetchUserDailyRanking(ctx, limit, offset, latestPeriod)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if len(rankingData) == 0 </span><span class="cov8" title="1">{
                        return []*UserDailyRanking{}, nil
                }</span>
                <span class="cov8" title="1">rankingSet := utils.NewSet[*UserDailyRankingRes](rankingData)
                rankingMap := utils.SetToMap(rankingSet, func(res *UserDailyRankingRes) core.UserId </span><span class="cov8" title="1">{ return res.UserId }</span>)
                <span class="cov8" title="1">userIds := utils.SetSelect(rankingSet, func(res *UserDailyRankingRes) core.UserId </span><span class="cov8" title="1">{ return res.UserId }</span>)
                <span class="cov8" title="1">shelves, err := getShelfService(ctx, userIds.ToArray())
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">shelvesSet := utils.NewSet[*shelf.Shelf](shelves)
                userShelves := func() map[core.UserId][]*shelf.Shelf </span><span class="cov8" title="1">{
                        m := make(map[core.UserId][]*shelf.Shelf)
                        shelvesSet.Foreach(
                                func(_ int, s *shelf.Shelf) </span><span class="cov8" title="1">{
                                        m[s.UserId] = append(m[s.UserId], s)
                                }</span>,
                        )
                        <span class="cov8" title="1">return m</span>
                }()
                <span class="cov8" title="1">userNames, err := fetchUserName(ctx, userIds.ToArray())
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userNameSet := utils.NewSet(userNames)
                userNameMap := utils.SetToMap(userNameSet, func(name *core.FetchUserNameRes) core.UserId </span><span class="cov8" title="1">{ return name.UserId }</span>)

                <span class="cov8" title="1">totalScores, err := fetchTotalScore(ctx, userIds.ToArray(), latestPeriod)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">totalScoreSet := utils.NewSet(totalScores)
                totalScoreMap := utils.SetToMap(totalScoreSet, func(score *UserScorePair) core.UserId </span><span class="cov8" title="1">{ return score.UserId }</span>)

                <span class="cov8" title="1">result := make([]*UserDailyRanking, len(rankingData))
                userIds.Foreach(
                        func(i int, userId core.UserId) </span><span class="cov8" title="1">{
                                nameData := userNameMap[userId]
                                result[i] = &amp;UserDailyRanking{
                                        UserId:     userId,
                                        UserName:   nameData.UserName,
                                        ShopName:   nameData.ShopName,
                                        Rank:       rankingMap[userId].Rank,
                                        TotalScore: totalScoreMap[userId].TotalScore,
                                        Shelves:    userShelves[userId],
                                }
                        }</span>,
                )
                <span class="cov8" title="1">return result, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package ranking

import (
        "github.com/asragi/RinGo/core/game/shelf"
)

type Rank int
type TotalScore int

func NewTotalScore(gainingScore GainingScore, beforeTotalScore TotalScore) TotalScore <span class="cov8" title="1">{
        return TotalScore(int(beforeTotalScore) + int(gainingScore))
}</span>

type GainingScore int

func NewGainingScore(setPrice shelf.SetPrice, popularity shelf.ShopPopularity) GainingScore <span class="cov8" title="1">{
        score := float64(setPrice) * (float64(popularity) + 1)
        return GainingScore(int(score))
}</span>

type RankPeriod int

func (r RankPeriod) ToInt() int <span class="cov8" title="1">{
        return int(r)
}</span>

func (r RankPeriod) Next() RankPeriod <span class="cov8" title="1">{
        return r + 1
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package ranking

import (
        "context"
        "github.com/asragi/RinGo/core"
)

type OnChangePeriodFunc func(context.Context) error

func CreateOnChangePeriod(
        fetchDailyRanking FetchUserDailyRanking,
        insertWinRepo InsertWinRepo,
        getLatestPeriod FetchLatestRankPeriod,
        insertPeriod InsertRankPeriodRepo,
) OnChangePeriodFunc <span class="cov8" title="1">{
        const rankLimit = 3
        return func(ctx context.Context) error </span><span class="cov8" title="1">{
                period, err := getLatestPeriod(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">dailyRanking, err := fetchDailyRanking(ctx, core.Limit(rankLimit), 0)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">var reqs []*InsertWinReq
                for _, r := range dailyRanking </span><span class="cov8" title="1">{
                        reqs = append(
                                reqs, &amp;InsertWinReq{
                                        UserId: r.UserId,
                                        Rank:   r.Rank,
                                        Period: period,
                                },
                        )
                }</span>
                <span class="cov8" title="1">if err = insertWinRepo(ctx, reqs); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">nextPeriod := period.Next()
                if err = insertPeriod(ctx, nextPeriod); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package ranking

import (
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
)

type Services struct {
        UpdateTotalScore      UpdateTotalScoreServiceFunc
        FetchUserDailyRanking FetchUserDailyRanking
}

func NewService(
        getShelvesService shelf.GetShelfFunc,
        fetchUserName core.FetchUserNameFunc,
        fetchUserDailyRanking FetchUserDailyRankingRepo,
        fetchScore FetchUserScore,
        updateScore UpsertScoreFunc,
        fetchLatestPeriod FetchLatestRankPeriod,
) *Services <span class="cov0" title="0">{
        updateTotalScore := CreateUpdateTotalScoreService(
                fetchScore,
                fetchLatestPeriod,
                updateScore,
        )
        fetchUserDailyRankingService := CreateFetchUserDailyRanking(
                fetchUserName,
                fetchUserDailyRanking,
                fetchScore,
                fetchLatestPeriod,
                getShelvesService,
        )

        return &amp;Services{
                UpdateTotalScore:      updateTotalScore,
                FetchUserDailyRanking: fetchUserDailyRankingService,
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package ranking

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
)

func userPopToId(popPair []*shelf.UserPopularity) []core.UserId <span class="cov8" title="1">{
        result := make([]core.UserId, len(popPair))
        for i, v := range popPair </span><span class="cov8" title="1">{
                result[i] = v.UserId
        }</span>
        <span class="cov8" title="1">return result</span>
}

type UpdateTotalScoreServiceFunc func(context.Context, []*shelf.UserPopularity, []*shelf.SoldItem) error

func CreateUpdateTotalScoreService(
        fetchScore FetchUserScore,
        fetchLatestPeriod FetchLatestRankPeriod,
        updateScore UpsertScoreFunc,
) UpdateTotalScoreServiceFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userPopularity []*shelf.UserPopularity,
                soldItems []*shelf.SoldItem,
        ) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("on update total score service: %w", err)
                }</span>
                <span class="cov8" title="1">latestPeriod, err := fetchLatestPeriod(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userIds := userPopToId(userPopularity)
                userScores, err := fetchScore(ctx, userIds, latestPeriod)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userScoreMap := func() map[core.UserId]TotalScore </span><span class="cov8" title="1">{
                        result := map[core.UserId]TotalScore{}
                        for _, v := range userScores </span><span class="cov8" title="1">{
                                result[v.UserId] = v.TotalScore
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()

                <span class="cov8" title="1">resultScoreReq := make([]*UserScorePair, len(userIds))
                for i, v := range userPopularity </span><span class="cov8" title="1">{
                        userId := v.UserId
                        beforeTotalScore := func() TotalScore </span><span class="cov8" title="1">{
                                if score, ok := userScoreMap[userId]; ok </span><span class="cov8" title="1">{
                                        return score
                                }</span>
                                <span class="cov8" title="1">return 0</span>
                        }()
                        <span class="cov8" title="1">resultTotalScore := beforeTotalScore
                        for _, soldItem := range soldItems </span><span class="cov8" title="1">{
                                if soldItem.UserId != userId </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">gainingScore := NewGainingScore(soldItem.SetPrice, v.Popularity)
                                resultTotalScore = NewTotalScore(gainingScore, resultTotalScore)</span>
                        }
                        <span class="cov8" title="1">resultScoreReq[i] = &amp;UserScorePair{
                                UserId:     userId,
                                TotalScore: resultTotalScore,
                        }</span>
                }
                <span class="cov8" title="1">err = updateScore(ctx, resultScoreReq, latestPeriod)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package shelf

import (
        "context"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type (
        FetchSizeToActionRepoFunc func(context.Context, Size) (game.ActionId, error)
        ShelfRepoRow              struct {
                Id         Id                `db:"shelf_id"`
                UserId     core.UserId       `db:"user_id"`
                ItemId     core.ItemId       `db:"item_id"`
                Index      Index             `db:"shelf_index"`
                SetPrice   SetPrice          `db:"set_price"`
                TotalSales core.SalesFigures `db:"total_sales"`
        }
        FetchShelf    func(context.Context, []core.UserId) ([]*ShelfRepoRow, error)
        TotalSalesReq struct {
                Id         Id                `db:"shelf_id"`
                TotalSales core.SalesFigures `db:"total_sales"`
        }
        UpdateShelfTotalSalesFunc func(
                context.Context,
                []*TotalSalesReq,
        ) error
        UpdateShelfContentRepoFunc func(
                context.Context,
                Id,
                core.ItemId,
                SetPrice,
        ) error

        InsertEmptyShelfFunc func(ctx context.Context, userId core.UserId, shelves []*ShelfRepoRow) error

        // DeleteShelfBySizeFunc deletes shelves  until the total number of shelves
        // reaches the requested size
        DeleteShelfBySizeFunc func(context.Context, core.UserId, Size) error
)

func checkContainItem(shelves []*ShelfRepoRow, itemId core.ItemId) bool <span class="cov0" title="0">{
        for _, shelf := range shelves </span><span class="cov0" title="0">{
                if shelf.ItemId == itemId </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func checkContainIndex(shelves []*ShelfRepoRow, index Index) bool <span class="cov0" title="0">{
        for _, shelf := range shelves </span><span class="cov0" title="0">{
                if shelf.Index == index </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func shelvesToItemIds(shelves []*ShelfRepoRow) []core.ItemId <span class="cov8" title="1">{
        checked := map[core.ItemId]struct{}{}
        var itemIds []core.ItemId
        for _, shelf := range shelves </span><span class="cov8" title="1">{
                if _, ok := checked[shelf.ItemId]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if shelf.ItemId == core.EmptyItemId </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">checked[shelf.ItemId] = struct{}{}
                itemIds = append(itemIds, shelf.ItemId)</span>
        }
        <span class="cov8" title="1">return itemIds</span>
}

func shelvesToMap(shelves []*ShelfRepoRow) map[core.UserId][]*ShelfRepoRow <span class="cov8" title="1">{
        shelvesMap := map[core.UserId][]*ShelfRepoRow{}
        for _, shelf := range shelves </span><span class="cov8" title="1">{
                if _, ok := shelvesMap[shelf.UserId]; !ok </span><span class="cov8" title="1">{
                        shelvesMap[shelf.UserId] = []*ShelfRepoRow{}
                }</span>
                <span class="cov8" title="1">shelvesMap[shelf.UserId] = append(shelvesMap[shelf.UserId], shelf)</span>
        }
        <span class="cov8" title="1">return shelvesMap</span>
}

func shelfRowToSize(shelf []*ShelfRepoRow) Size <span class="cov0" title="0">{
        return Size(len(shelf))
}</span>

func shelfRowToUserItemPair(shelf []*ShelfRepoRow) []*game.UserItemPair <span class="cov8" title="1">{
        var userItemPairs []*game.UserItemPair
        for _, row := range shelf </span><span class="cov8" title="1">{
                userItemPairs = append(
                        userItemPairs, &amp;game.UserItemPair{
                                UserId: row.UserId,
                                ItemId: row.ItemId,
                        },
                )
        }</span>
        <span class="cov8" title="1">return userItemPairs</span>
}

func findShelfRow(shelves []*ShelfRepoRow, userId core.UserId, index Index) *ShelfRepoRow <span class="cov8" title="1">{
        for _, shelf := range shelves </span><span class="cov8" title="1">{
                if shelf.UserId != userId </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if shelf.Index != index </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">return shelf</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type UserPopularity struct {
        UserId     core.UserId    `db:"user_id" json:"user_id"`
        Popularity ShopPopularity `db:"popularity" json:"popularity"`
}

type FetchUserPopularityFunc func(context.Context, []core.UserId) ([]*UserPopularity, error)
type UpdateUserPopularityFunc func(context.Context, []*UserPopularity) error
</pre>
		
		<pre class="file" id="file48" style="display: none">package reservation

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type ApplyAllReservationsFunc func(ctx context.Context) error

func CreateApplyAllReservations(
        fetchAllUserId core.FetchAllUserId,
        applyReservation ApplyReservationFunc,
) ApplyAllReservationsFunc <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("error on apply all reservations: %w", err)
                }</span>
                <span class="cov0" title="0">userIdReq, err := fetchAllUserId(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if len(userIdReq) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">err = applyReservation(ctx, userIdReq)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package reservation

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/ranking"
        "time"
)

type ApplyReservationFunc func(context.Context, []core.UserId) error

func CreateApplyReservation(
        fetchReservation FetchReservationRepoFunc,
        deleteReservation DeleteReservationRepoFunc,
        fetchItemMaster game.FetchItemMasterFunc,
        fetchUserStorage game.FetchStorageFunc,
        fetchPopularity shelf.FetchUserPopularityFunc,
        fetchShelf shelf.FetchShelf,
        fetchFund game.FetchFundFunc,
        updateFund game.UpdateFundFunc,
        updatePopularity shelf.UpdateUserPopularityFunc,
        updateStorage game.UpdateItemStorageFunc,
        updateShelfTotalSales shelf.UpdateShelfTotalSalesFunc,
        updateTotalScore ranking.UpdateTotalScoreServiceFunc,
        calcApplication CalcReservationApplicationFunc,
        getTime core.GetCurrentTimeFunc,
) ApplyReservationFunc <span class="cov8" title="1">{
        return func(ctx context.Context, users []core.UserId) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("error on apply reservation: %w", err)
                }</span>
                <span class="cov8" title="1">fromTime := time.Unix(0, 0)
                toTime := getTime()
                reservations, err := fetchReservation(ctx, users, fromTime, toTime)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if len(reservations) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">reservationIds := ReservationRowsToIdArray(reservations)
                reservationMap := func() map[core.UserId][]*ReservationRow </span><span class="cov8" title="1">{
                        result := make(map[core.UserId][]*ReservationRow)
                        for _, r := range reservations </span><span class="cov8" title="1">{
                                result[r.UserId] = append(result[r.UserId], r)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">userIds := ReservationRowsToUserIdArray(reservations)
                allShelvesData, err := fetchShelf(ctx, userIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">shelvesMap := func() map[core.UserId]map[shelf.Index]*shelf.ShelfRepoRow </span><span class="cov8" title="1">{
                        result := make(map[core.UserId]map[shelf.Index]*shelf.ShelfRepoRow)
                        for _, s := range allShelvesData </span><span class="cov8" title="1">{
                                if _, ok := result[s.UserId]; !ok </span><span class="cov8" title="1">{
                                        result[s.UserId] = make(map[shelf.Index]*shelf.ShelfRepoRow)
                                }</span>
                                <span class="cov8" title="1">result[s.UserId][s.Index] = s</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">userItemPairs := func() []*game.UserItemPair </span><span class="cov8" title="1">{
                        var result []*game.UserItemPair
                        for _, userId := range userIds </span><span class="cov8" title="1">{
                                for _, w := range reservationMap[userId] </span><span class="cov8" title="1">{
                                        result = append(
                                                result, &amp;game.UserItemPair{
                                                        UserId: userId,
                                                        ItemId: shelvesMap[userId][w.Index].ItemId,
                                                },
                                        )
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">storageData, err := fetchUserStorage(ctx, userItemPairs)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">fundData, err := fetchFund(ctx, userIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemIds := func() []core.ItemId </span><span class="cov8" title="1">{
                        var result []core.ItemId
                        for _, pair := range userItemPairs </span><span class="cov8" title="1">{
                                result = append(result, pair.ItemId)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">itemMasterRes, err := fetchItemMaster(ctx, itemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">popularity, err := fetchPopularity(ctx, userIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">calcApplyResult, err := calcApplication(
                        userIds,
                        popularity,
                        itemMasterRes,
                        fundData,
                        game.SpreadGetStorageRes(storageData),
                        allShelvesData,
                        ToReservationModel(reservations),
                )
                err = updateStorage(ctx, calcApplyResult.afterStorage)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateFund(ctx, calcApplyResult.calculatedFund)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updatePopularity(ctx, calcApplyResult.afterPopularity)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateShelfTotalSales(ctx, calcApplyResult.totalSales)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateTotalScore(ctx, popularity, calcApplyResult.soldItems)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>

                <span class="cov8" title="1">err = deleteReservation(ctx, reservationIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package reservation

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
)

type AutoInsertReservationFunc func(context.Context) error

func CreateAutoInsertReservation(
        fetchAllUserId core.FetchAllUserId,
        insertReservation BatchInsertReservationFunc,
) AutoInsertReservationFunc <span class="cov0" title="0">{
        return func(ctx context.Context) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("error on auto insert reservation: %w", err)
                }</span>
                <span class="cov0" title="0">allUserId, err := fetchAllUserId(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if len(allUserId) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">err = insertReservation(ctx, allUserId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package reservation

import (
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/shelf"
)

type calcReservationResult struct {
        calculatedFund  []*game.UserFundPair
        afterStorage    []*game.StorageData
        totalSales      []*shelf.TotalSalesReq
        soldItems       []*shelf.SoldItem
        afterPopularity []*shelf.UserPopularity
}

type CalcReservationApplicationFunc func(
        users []core.UserId,
        initialPopularity []*shelf.UserPopularity,
        itemMasterReq []*game.GetItemMasterRes,
        fundData []*game.FundRes,
        storageData []*game.StorageData,
        shelves []*shelf.ShelfRepoRow,
        reservations []*Reservation,
) (*calcReservationResult, error)

func CalcReservationApplication(
        users []core.UserId,
        initialPopularityArray []*shelf.UserPopularity,
        itemMasterReq []*game.GetItemMasterRes,
        fundData []*game.FundRes,
        storageData []*game.StorageData,
        shelves []*shelf.ShelfRepoRow,
        reservationsRow []*Reservation,
) (*calcReservationResult, error) <span class="cov8" title="1">{
        handleError := func(err error) (*calcReservationResult, error) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calc reservation application: %w", err)
        }</span>
        <span class="cov8" title="1">itemMasterMap := game.ItemMasterResToMap(itemMasterReq)
        initialPopularityMap := func() map[core.UserId]*shelf.UserPopularity </span><span class="cov8" title="1">{
                result := make(map[core.UserId]*shelf.UserPopularity)
                for _, p := range initialPopularityArray </span><span class="cov8" title="1">{
                        result[p.UserId] = p
                }</span>
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">shelfMap := func() map[core.UserId]map[shelf.Index]*shelf.ShelfRepoRow </span><span class="cov8" title="1">{
                result := make(map[core.UserId]map[shelf.Index]*shelf.ShelfRepoRow)
                for _, s := range shelves </span><span class="cov8" title="1">{
                        if _, ok := result[s.UserId]; !ok </span><span class="cov8" title="1">{
                                result[s.UserId] = make(map[shelf.Index]*shelf.ShelfRepoRow)
                        }</span>
                        <span class="cov8" title="1">result[s.UserId][s.Index] = s</span>
                }
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">reservationMap := func() map[core.UserId]map[core.ItemId][]*Reservation </span><span class="cov8" title="1">{
                result := make(map[core.UserId]map[core.ItemId][]*Reservation)
                for _, r := range reservationsRow </span><span class="cov8" title="1">{
                        if _, ok := result[r.TargetUser]; !ok </span><span class="cov8" title="1">{
                                result[r.TargetUser] = make(map[core.ItemId][]*Reservation)
                        }</span>
                        <span class="cov8" title="1">index := r.Index
                        itemId := shelfMap[r.TargetUser][index].ItemId
                        result[r.TargetUser][itemId] = append(result[r.TargetUser][itemId], r)</span>
                }
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">itemIdMap := func() map[core.UserId][]core.ItemId </span><span class="cov8" title="1">{
                result := make(map[core.UserId][]core.ItemId)
                itemIdAlreadyAdded := make(map[core.UserId]map[core.ItemId]struct{})
                for _, r := range reservationsRow </span><span class="cov8" title="1">{
                        index := r.Index
                        itemId := shelfMap[r.TargetUser][index].ItemId
                        // Fix it
                        if _, ok := itemIdAlreadyAdded[r.TargetUser]; !ok </span><span class="cov8" title="1">{
                                itemIdAlreadyAdded[r.TargetUser] = make(map[core.ItemId]struct{})
                        }</span>
                        <span class="cov8" title="1">if _, ok := itemIdAlreadyAdded[r.TargetUser][itemId]; ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">itemIdAlreadyAdded[r.TargetUser][itemId] = struct{}{}
                        result[r.TargetUser] = append(result[r.TargetUser], itemId)</span>
                }
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">storageMap := func() map[core.UserId]map[core.ItemId]*game.StorageData </span><span class="cov8" title="1">{
                result := make(map[core.UserId]map[core.ItemId]*game.StorageData)
                for _, s := range storageData </span><span class="cov8" title="1">{
                        if _, ok := result[s.UserId]; !ok </span><span class="cov8" title="1">{
                                result[s.UserId] = make(map[core.ItemId]*game.StorageData)
                        }</span>
                        <span class="cov8" title="1">result[s.UserId][s.ItemId] = s</span>
                }
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">fundMap := func() map[core.UserId]*game.FundRes </span><span class="cov8" title="1">{
                result := make(map[core.UserId]*game.FundRes)
                for _, f := range fundData </span><span class="cov8" title="1">{
                        result[f.UserId] = f
                }</span>
                <span class="cov8" title="1">return result</span>
        }()
        <span class="cov8" title="1">afterPopularityForAllUser := make([]*shelf.UserPopularity, len(users))
        appliedFunds := make([]*game.UserFundPair, len(users))
        appliedStorages := make([]*game.StorageData, 0)
        appliedShelfSales := make([]*shelf.TotalSalesReq, 0)
        soldItems := make([]*shelf.SoldItem, 0)
        for i, user := range users </span><span class="cov8" title="1">{
                reservations := reservationMap[user]
                itemArr := itemIdMap[user]
                totalFund := fundMap[user].Fund
                initialPopularity := initialPopularityMap[user]
                afterPopularityForUser := initialPopularity.Popularity
                for _, itemId := range itemArr </span><span class="cov8" title="1">{
                        if _, ok := reservations[itemId]; !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">itemMaster := itemMasterMap[itemId]
                        reservationsToItem := reservations[itemId]
                        if len(reservationsToItem) == 0 </span><span class="cov0" title="0">{
                                // This should not happen
                                continue</span>
                        }
                        <span class="cov8" title="1">index := reservationsToItem[0].Index
                        targetShelf := shelfMap[user][index]
                        purchaseNumArr := func() []core.Count </span><span class="cov8" title="1">{
                                result := make([]core.Count, len(reservationsToItem))
                                for i, r := range reservationsToItem </span><span class="cov8" title="1">{
                                        result[i] = r.PurchaseNum
                                }</span>
                                <span class="cov8" title="1">return result</span>
                        }()
                        <span class="cov8" title="1">storageStock := storageMap[user][itemId].Stock
                        setPrice := targetShelf.SetPrice
                        totalSalesBefore := targetShelf.TotalSales
                        calcPurchasePerItemResult, err := calcPurchaseResultPerItem(
                                user,
                                storageStock,
                                afterPopularityForUser,
                                purchaseNumArr,
                                itemMaster.Price,
                                setPrice,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov8" title="1">afterPopularityForUser = calcPurchasePerItemResult.afterPopularity
                        appliedStorages = append(
                                appliedStorages, &amp;game.StorageData{
                                        UserId:  user,
                                        ItemId:  itemId,
                                        Stock:   calcPurchasePerItemResult.afterStock,
                                        IsKnown: true,
                                },
                        )
                        appliedShelfSales = append(
                                appliedShelfSales, &amp;shelf.TotalSalesReq{
                                        Id:         targetShelf.Id,
                                        TotalSales: totalSalesBefore.TotalingSales(calcPurchasePerItemResult.totalSalesFigures),
                                },
                        )
                        totalFund = totalFund.AddFund(calcPurchasePerItemResult.totalProfit)
                        soldItems = append(soldItems, calcPurchasePerItemResult.soldItems...)</span>
                }
                <span class="cov8" title="1">appliedFunds[i] = &amp;game.UserFundPair{
                        UserId: user,
                        Fund:   totalFund,
                }
                afterPopularityForAllUser[i] = &amp;shelf.UserPopularity{
                        UserId:     user,
                        Popularity: afterPopularityForUser,
                }</span>
        }

        <span class="cov8" title="1">return &amp;calcReservationResult{
                calculatedFund:  appliedFunds,
                afterStorage:    appliedStorages,
                totalSales:      appliedShelfSales,
                soldItems:       soldItems,
                afterPopularity: afterPopularityForAllUser,
        }, nil</span>
}

type calcPurchaseResult struct {
        afterStock        core.Stock
        afterPopularity   shelf.ShopPopularity
        totalProfit       core.Profit
        totalSalesFigures core.SalesFigures
        soldItems         []*shelf.SoldItem
}

func calcPurchaseResultPerItem(
        userId core.UserId,
        initialStock core.Stock,
        initialPopularity shelf.ShopPopularity,
        purchaseNumArray []core.Count,
        price core.Price,
        setPrice shelf.SetPrice,
) (*calcPurchaseResult, error) <span class="cov8" title="1">{
        restStock := initialStock
        resultPopularity := initialPopularity
        totalSales := core.SalesFigures(0)
        totalProfit := core.Profit(0)
        soldItems := make([]*shelf.SoldItem, 0)
        for _, purchaseNum := range purchaseNumArray </span><span class="cov8" title="1">{
                if !restStock.CheckIsStockEnough(purchaseNum) </span><span class="cov8" title="1">{
                        lostPopularity := shelf.NewPopularityLost(price, setPrice)
                        resultPopularity = resultPopularity.AddPopularityChange(lostPopularity)
                        continue</span>
                }
                <span class="cov8" title="1">reducedRestStock, err := restStock.SubStock(purchaseNum)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid reducing stock action: %w", err)
                }</span>
                <span class="cov8" title="1">restStock = reducedRestStock
                totalSales = totalSales.AddSalesFigures(purchaseNum)
                totalProfit = totalProfit + setPrice.CalculateProfit(purchaseNum)
                gainPopularity := shelf.NewPopularityGain(price, setPrice)
                resultPopularity = resultPopularity.AddPopularityChange(gainPopularity)
                soldItem := &amp;shelf.SoldItem{
                        UserId:      userId,
                        SetPrice:    setPrice,
                        Popularity:  resultPopularity,
                        PurchaseNum: purchaseNum,
                }
                soldItems = append(soldItems, soldItem)</span>
        }
        <span class="cov8" title="1">return &amp;calcPurchaseResult{
                afterStock:        restStock,
                afterPopularity:   resultPopularity,
                totalProfit:       totalProfit,
                totalSalesFigures: totalSales,
                soldItems:         soldItems,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package reservation

import (
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/utils"
        "time"
)

type shelfArg struct {
        SetPrice       shelf.SetPrice
        Price          core.Price
        BaseAttraction ItemAttraction
}

// deprecated: use CreateReservation instead
func informationToShelfArg(
        indices []shelf.Index,
        information map[shelf.Index]*shelf.UpdateShelfContentShelfInformation,
        itemAttractionMap map[core.ItemId]*ItemAttractionRes,
) []*shelfArg <span class="cov8" title="1">{
        shelves := make([]*shelfArg, len(information))
        for i, index := range indices </span><span class="cov8" title="1">{
                info := information[index]
                attraction := func() ItemAttraction </span><span class="cov8" title="1">{
                        if info.ItemId == core.EmptyItemId </span><span class="cov0" title="0">{
                                return ItemAttraction(0)
                        }</span>
                        <span class="cov8" title="1">return itemAttractionMap[info.ItemId].Attraction</span>
                }()
                <span class="cov8" title="1">shelves[i] = &amp;shelfArg{
                        SetPrice:       info.SetPrice,
                        Price:          info.Price,
                        BaseAttraction: attraction,
                }</span>
        }
        <span class="cov8" title="1">return shelves</span>
}

type CreateReservationFunc func(
        updatedIndex shelf.Index,
        updatedItemPrice core.Price,
        updatedItemSetPrice shelf.SetPrice,
        baseProbability PurchaseProbability,
        targetUserId core.UserId,
        shopPopularity shelf.ShopPopularity,
        shelves *utils.Set[*shelfArg],
        rand core.EmitRandomFunc,
        fromTime time.Time,
        toTime time.Time,
        generateId func() string,
) []*Reservation

func CreateReservation(
        updatedIndex shelf.Index,
        updatedItemPrice core.Price,
        updatedItemSetPrice shelf.SetPrice,
        baseProbability PurchaseProbability,
        targetUserId core.UserId,
        shopPopularity shelf.ShopPopularity,
        shelves *utils.Set[*shelfArg],
        rand core.EmitRandomFunc,
        fromTime time.Time,
        toTime time.Time,
        generateId func() string,
) []*Reservation <span class="cov0" title="0">{
        modifiedItemAttractions := utils.SetSelect(
                shelves, func(s *shelfArg) ModifiedItemAttraction </span><span class="cov0" title="0">{
                        return calcItemAttraction(s.BaseAttraction, s.Price, s.SetPrice)
                }</span>,
        )
        <span class="cov0" title="0">shelfAttraction := calcShelfAttraction(modifiedItemAttractions.ToArray())
        customerNum := calcCustomerNumPerHour(shopPopularity, shelfAttraction)
        probability := calcModifiedPurchaseProbability(
                baseProbability,
                updatedItemPrice,
                updatedItemSetPrice,
        )
        return createReservations(
                customerNum,
                rand,
                fromTime,
                toTime,
                probability,
                targetUserId,
                updatedIndex,
                generateId,
        )</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package reservation

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/utils"
        "time"
)

type InsertedReservation struct {
        UserId        core.UserId
        Index         shelf.Index
        ReservationId Id
        ScheduledTime time.Time
        PurchaseNum   core.Count
}

func ToInsertedReservation(reservations []*Reservation) []*InsertedReservation <span class="cov8" title="1">{
        insertedReservations := make([]*InsertedReservation, len(reservations))
        for i, r := range reservations </span><span class="cov8" title="1">{
                insertedReservations[i] = &amp;InsertedReservation{
                        UserId:        r.TargetUser,
                        Index:         r.Index,
                        ReservationId: r.Id,
                        ScheduledTime: r.ScheduledTime,
                        PurchaseNum:   r.PurchaseNum,
                }
        }</span>
        <span class="cov8" title="1">return insertedReservations</span>
}

type InsertReservationResult struct {
        Reservations []*InsertedReservation
}

type InsertReservationFunc func(
        context.Context,
        core.UserId,
        shelf.Index,
        []shelf.Index,
        map[shelf.Index]*shelf.UpdateShelfContentShelfInformation,
) (*InsertReservationResult, error)

func CreateInsertReservation(
        fetchItemAttraction FetchItemAttractionFunc,
        fetchUserPopularity shelf.FetchUserPopularityFunc,
        createReservation CreateReservationFunc,
        insertReservation InsertReservationRepoFunc,
        deleteReservation DeleteReservationToShelfRepoFunc,
        updateCheckedTime UpdateCheckedTime,
        rand core.EmitRandomFunc,
        getCurrentTime core.GetCurrentTimeFunc,
        generateId core.GenerateUUIDFunc,
) InsertReservationFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                index shelf.Index,
                indices []shelf.Index,
                shelves map[shelf.Index]*shelf.UpdateShelfContentShelfInformation,
        ) (*InsertReservationResult, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*InsertReservationResult, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("inserting reservation: %w", err)
                }</span>

                <span class="cov8" title="1">err := deleteReservation(ctx, userId, index)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemIds := func(
                        indices []shelf.Index,
                        shelvesMap map[shelf.Index]*shelf.UpdateShelfContentShelfInformation,
                ) []core.ItemId </span><span class="cov8" title="1">{
                        itemIds := make([]core.ItemId, len(indices))
                        for i, mapIndex := range indices </span><span class="cov8" title="1">{
                                itemIds[i] = shelvesMap[mapIndex].ItemId
                        }</span>
                        <span class="cov8" title="1">return itemIds</span>
                }(indices, shelves)
                <span class="cov8" title="1">itemAttraction, err := fetchItemAttraction(ctx, itemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemAttractionMap := itemAttractionResToMap(itemAttraction)
                shelfArgs := informationToShelfArg(indices, shelves, itemAttractionMap)
                shelvesArgsSet := utils.NewSet(shelfArgs)
                updatedShelf := shelves[index]
                updatedItemAttractionData := itemAttractionMap[updatedShelf.ItemId]
                probability := func() PurchaseProbability </span><span class="cov8" title="1">{
                        if updatedShelf.ItemId == core.EmptyItemId </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                        <span class="cov8" title="1">return updatedItemAttractionData.PurchaseProbability</span>
                }()
                <span class="cov8" title="1">shopPopularity, err := fetchUserPopularity(ctx, []core.UserId{userId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if len(shopPopularity) == 0 </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("no user popularity data"))
                }</span>
                <span class="cov8" title="1">currentTime := getCurrentTime()
                endTime := currentTime.Add(time.Hour)
                reservations := createReservation(
                        index,
                        updatedShelf.Price,
                        updatedShelf.SetPrice,
                        probability,
                        userId,
                        shopPopularity[0].Popularity,
                        shelvesArgsSet,
                        rand,
                        currentTime,
                        endTime,
                        generateId,
                )
                if len(reservations) == 0 </span><span class="cov0" title="0">{
                        return &amp;InsertReservationResult{[]*InsertedReservation{}}, nil
                }</span>

                <span class="cov8" title="1">reservationRows := ToReservationRow(reservations)
                err = insertReservation(ctx, reservationRows)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateCheckedTime(
                        ctx, []*UpdateCheckedTimePair{
                                {
                                        ShelfId:     updatedShelf.Id,
                                        CheckedTime: endTime,
                                },
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;InsertReservationResult{ToInsertedReservation(reservations)}, nil</span>
        }
}

type BatchInsertReservationFunc func(context.Context, []core.UserId) error

func CreateBatchInsertReservation(
        fetchItemMaster game.FetchItemMasterFunc,
        fetchShelves shelf.FetchShelf,
        fetchItemAttraction FetchItemAttractionFunc,
        fetchUserPopularity shelf.FetchUserPopularityFunc,
        createReservation CreateReservationFunc,
        insertReservation InsertReservationRepoFunc,
        fetchCheckedTime FetchCheckedTimeFunc,
        updateCheckedTime UpdateCheckedTime,
        rand core.EmitRandomFunc,
        generateId core.GenerateUUIDFunc,
        getCurrentTime core.GetCurrentTimeFunc,
) BatchInsertReservationFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                userIds []core.UserId,
        ) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("inserting reservation: %w", err)
                }</span>

                <span class="cov0" title="0">if len(userIds) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">shelvesRes, err := fetchShelves(ctx, userIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">shelvesSet := utils.NewSet(shelvesRes)
                allShelvesId := utils.SetSelect(shelvesSet, func(s *shelf.ShelfRepoRow) shelf.Id </span><span class="cov0" title="0">{ return s.Id }</span>)
                <span class="cov0" title="0">shelvesMap := func() map[core.UserId]map[shelf.Index]*shelf.ShelfRepoRow </span><span class="cov0" title="0">{
                        result := make(map[core.UserId]map[shelf.Index]*shelf.ShelfRepoRow)
                        for _, s := range shelvesRes </span><span class="cov0" title="0">{
                                if _, ok := result[s.UserId]; !ok </span><span class="cov0" title="0">{
                                        result[s.UserId] = make(map[shelf.Index]*shelf.ShelfRepoRow)
                                }</span>
                                <span class="cov0" title="0">result[s.UserId][s.Index] = s</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }()
                <span class="cov0" title="0">shelvesMapById := utils.SetToMap(shelvesSet, func(s *shelf.ShelfRepoRow) shelf.Id </span><span class="cov0" title="0">{ return s.Id }</span>)
                <span class="cov0" title="0">allItemIds := func() []core.ItemId </span><span class="cov0" title="0">{
                        checked := map[core.ItemId]struct{}{}
                        var itemIds []core.ItemId
                        for _, s := range shelvesRes </span><span class="cov0" title="0">{
                                if _, ok := checked[s.ItemId]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">checked[s.ItemId] = struct{}{}
                                itemIds = append(itemIds, s.ItemId)</span>
                        }
                        <span class="cov0" title="0">return itemIds</span>
                }()
                <span class="cov0" title="0">checkedTimeRes, err := fetchCheckedTime(ctx, allShelvesId.ToArray())
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">checkedTimeMap := func() map[core.UserId]map[shelf.Index]*CheckedTimePair </span><span class="cov0" title="0">{
                        result := make(map[core.UserId]map[shelf.Index]*CheckedTimePair)
                        for _, r := range checkedTimeRes </span><span class="cov0" title="0">{
                                s := shelvesMapById[r.ShelfId]
                                userId := s.UserId
                                index := s.Index
                                if _, ok := result[userId]; !ok </span><span class="cov0" title="0">{
                                        result[userId] = make(map[shelf.Index]*CheckedTimePair)
                                }</span>
                                <span class="cov0" title="0">result[userId][index] = r</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }()
                <span class="cov0" title="0">itemMasters, err := fetchItemMaster(ctx, allItemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">itemMasterMap := func() map[core.ItemId]*game.GetItemMasterRes </span><span class="cov0" title="0">{
                        set := utils.NewSet(itemMasters)
                        return utils.SetToMap(set, func(m *game.GetItemMasterRes) core.ItemId </span><span class="cov0" title="0">{ return m.ItemId }</span>)
                }()

                <span class="cov0" title="0">itemAttraction, err := fetchItemAttraction(ctx, allItemIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">itemAttractionMap := itemAttractionResToMap(itemAttraction)
                shopPopularityRes, err := fetchUserPopularity(ctx, userIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">shopPopMap := func() map[core.UserId]*shelf.UserPopularity </span><span class="cov0" title="0">{
                        set := utils.NewSet(shopPopularityRes)
                        return utils.SetToMap(set, func(p *shelf.UserPopularity) core.UserId </span><span class="cov0" title="0">{ return p.UserId }</span>)
                }()
                <span class="cov0" title="0">var allReservations []*Reservation
                var allUpdatedCheckedTime []*UpdateCheckedTimePair
                for _, v := range userIds </span><span class="cov0" title="0">{
                        userShelves := shelvesMap[v]
                        userCheckedTimeData := checkedTimeMap[v]
                        indices := func() []shelf.Index </span><span class="cov0" title="0">{
                                var indices []shelf.Index
                                for k := range userShelves </span><span class="cov0" title="0">{
                                        indices = append(indices, k)
                                }</span>
                                <span class="cov0" title="0">return indices</span>
                        }()
                        <span class="cov0" title="0">shelvesArgsSet := func() *utils.Set[*shelfArg] </span><span class="cov0" title="0">{
                                var result []*shelfArg
                                for _, index := range indices </span><span class="cov0" title="0">{
                                        shelfData := userShelves[index]
                                        if shelfData.ItemId == core.EmptyItemId </span><span class="cov0" title="0">{
                                                result = append(
                                                        result, &amp;shelfArg{
                                                                SetPrice:       0,
                                                                Price:          0,
                                                                BaseAttraction: 0,
                                                        },
                                                )
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">price := itemMasterMap[shelfData.ItemId].Price
                                        baseAttraction := itemAttractionMap[shelfData.ItemId].Attraction
                                        result = append(
                                                result, &amp;shelfArg{
                                                        SetPrice:       shelfData.SetPrice,
                                                        Price:          price,
                                                        BaseAttraction: baseAttraction,
                                                },
                                        )</span>
                                }
                                <span class="cov0" title="0">return utils.NewSet(result)</span>
                        }()
                        <span class="cov0" title="0">for _, shelfIndex := range indices </span><span class="cov0" title="0">{
                                checkedTimeValue := userCheckedTimeData[shelfIndex].CheckedTime
                                itemId := userShelves[shelfIndex].ItemId
                                if itemId == core.EmptyItemId </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">itemMaster := itemMasterMap[itemId]
                                itemAttractionData := itemAttractionMap[itemId]
                                userShopPopularity := shopPopMap[v]
                                currentTime := getCurrentTime()
                                targetTime := currentTime.Add(time.Hour)
                                if checkedTimeValue.isNull </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">checkedTime, err := checkedTimeValue.Time()
                                if err != nil </span><span class="cov0" title="0">{
                                        return handleError(err)
                                }</span>
                                <span class="cov0" title="0">if checkedTime.After(targetTime) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">reservations := createReservation(
                                        shelfIndex,
                                        itemMaster.Price,
                                        userShelves[shelfIndex].SetPrice,
                                        itemAttractionData.PurchaseProbability,
                                        v,
                                        userShopPopularity.Popularity,
                                        shelvesArgsSet,
                                        rand,
                                        checkedTime.Add(time.Minute),
                                        targetTime,
                                        generateId,
                                )
                                if len(reservations) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">allUpdatedCheckedTime = append(
                                        allUpdatedCheckedTime, &amp;UpdateCheckedTimePair{
                                                ShelfId:     userShelves[shelfIndex].Id,
                                                CheckedTime: targetTime,
                                        },
                                )
                                allReservations = append(allReservations, reservations...)</span>
                        }
                }
                <span class="cov0" title="0">req := ToReservationRow(allReservations)
                err = insertReservation(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">err = updateCheckedTime(ctx, allUpdatedCheckedTime)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package reservation

import (
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/utils"
        "math"
        "time"
)

type Reservation struct {
        Id            Id          `db:"reservation_id"`
        TargetUser    core.UserId `db:"user_id"`
        Index         shelf.Index `db:"shelf_index"`
        ScheduledTime time.Time   `db:"scheduled_time"`
        PurchaseNum   core.Count  `db:"purchase_num"`
}

type CheckedTime struct {
        time   time.Time
        isNull bool
}

func NewCheckedTime(t time.Time, isValid bool) *CheckedTime <span class="cov0" title="0">{
        return &amp;CheckedTime{
                time:   t,
                isNull: !isValid,
        }
}</span>

func (c *CheckedTime) IsNull() bool <span class="cov0" title="0">{
        return c.isNull
}</span>

func (c *CheckedTime) Time() (time.Time, error) <span class="cov0" title="0">{
        if c.isNull </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("time is nil")
        }</span>
        <span class="cov0" title="0">return c.time, nil</span>
}

func (c *CheckedTime) Add(d time.Duration) (time.Time, error) <span class="cov0" title="0">{
        if c.isNull </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("time is nil")
        }</span>
        <span class="cov0" title="0">return c.time.Add(d), nil</span>
}

func (c *CheckedTime) String() string <span class="cov0" title="0">{
        if c.isNull </span><span class="cov0" title="0">{
                return "&lt;Time is Null&gt;"
        }</span>
        <span class="cov0" title="0">return c.time.Format(time.DateTime)</span>
}

type attraction int
type ItemAttraction attraction
type ModifiedItemAttraction attraction
type ShelfAttraction attraction
type CustomerNum int

func NewCustomerNum(fromTime time.Time, toTime time.Time, customerNumPerHour CustomerNumPerHour) CustomerNum <span class="cov8" title="1">{
        duration := toTime.Sub(fromTime)
        hourRatio := duration.Hours() / time.Hour.Hours()
        return CustomerNum(hourRatio * float64(customerNumPerHour))
}</span>

type CustomerNumPerHour int
type PurchaseProbability float64
type ModifiedPurchaseProbability PurchaseProbability

func (p ModifiedPurchaseProbability) CheckWin(rand core.EmitRandomFunc) bool <span class="cov8" title="1">{
        return rand() &lt; float32(p)
}</span>

func calcModifiedPurchaseProbability(
        baseProbability PurchaseProbability,
        price core.Price,
        setPrice shelf.SetPrice,
) ModifiedPurchaseProbability <span class="cov8" title="1">{
        const MaxProbability float64 = 0.95
        const MinProbability float64 = 0
        maxProbability := math.Min(MaxProbability, float64(baseProbability)*2)
        priceRatio := float32(setPrice) / float32(price)
        penaltyPower := game.NewPricePenalty(price)
        poweredRatio := math.Pow(float64(priceRatio), float64(penaltyPower))
        if priceRatio &gt;= 1 </span><span class="cov8" title="1">{
                return ModifiedPurchaseProbability(float64(baseProbability) / poweredRatio)
        }</span>
        <span class="cov8" title="1">failedProbability := 1 - float64(baseProbability)
        modifiedFailedProbability := failedProbability * poweredRatio
        return ModifiedPurchaseProbability(
                utils.Clamp(1.0-modifiedFailedProbability, MinProbability, maxProbability),
        )</span>
}

func createReservations(
        customerNumPerHour CustomerNumPerHour,
        rand core.EmitRandomFunc,
        fromTime time.Time,
        toTime time.Time,
        probability ModifiedPurchaseProbability,
        targetUser core.UserId,
        targetIndex shelf.Index,
        generateId func() string,
) []*Reservation <span class="cov8" title="1">{
        customerNum := NewCustomerNum(fromTime, toTime, customerNumPerHour)
        reservations := make([]*Reservation, 0, int(customerNum))
        purchaseDuration := calcPurchaseDuration(customerNumPerHour)
        for i := 0; i &lt; int(customerNum); i++ </span><span class="cov8" title="1">{
                if !probability.CheckWin(rand) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">scheduledTime := func() time.Time </span><span class="cov8" title="1">{
                        result := fromTime.Add(purchaseDuration * time.Duration(i+1))
                        return result
                }</span>()
                <span class="cov8" title="1">reservations = append(
                        reservations, &amp;Reservation{
                                Id:            Id(generateId()),
                                TargetUser:    targetUser,
                                Index:         targetIndex,
                                ScheduledTime: scheduledTime,
                                // TODO: PurchaseNum should be calculated based on the item data
                                PurchaseNum: 1,
                        },
                )</span>
        }
        <span class="cov8" title="1">return reservations</span>
}

func calcPurchaseDuration(customerNum CustomerNumPerHour) time.Duration <span class="cov8" title="1">{
        if customerNum == 0 </span><span class="cov0" title="0">{
                return time.Hour * 2
        }</span>
        <span class="cov8" title="1">return time.Hour / time.Duration(customerNum)</span>
}

func calcCustomerNumPerHour(
        shopPopularity shelf.ShopPopularity,
        shelfAttraction ShelfAttraction,
) CustomerNumPerHour <span class="cov8" title="1">{
        return CustomerNumPerHour(int((0.5 + float64(shopPopularity)) * float64(shelfAttraction)))
}</span>

func calcShelfAttraction(items []ModifiedItemAttraction) ShelfAttraction <span class="cov8" title="1">{
        result := 0
        for _, v := range items </span><span class="cov8" title="1">{
                result += int(v)
        }</span>
        <span class="cov8" title="1">return ShelfAttraction(result)</span>
}

func calcItemAttraction(
        baseAttraction ItemAttraction,
        basePrice core.Price,
        setPrice shelf.SetPrice,
) ModifiedItemAttraction <span class="cov8" title="1">{
        const MaxAttractionRatio float64 = 4.0
        const MinAttractionRatio float64 = 0.25
        priceRatio := float32(setPrice) / float32(basePrice)
        penaltyPower := game.NewPricePenalty(basePrice)
        return ModifiedItemAttraction(
                math.Min(
                        math.Max(
                                float64(baseAttraction)*math.Pow(float64(1/priceRatio), float64(penaltyPower)),
                                MinAttractionRatio*float64(baseAttraction),
                        ),
                        MaxAttractionRatio*float64(baseAttraction),
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package reservation

import (
        "context"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "time"
)

type Id string

func NewReservationId(id string) Id <span class="cov0" title="0">{
        return Id(id)
}</span>

type ReservationRow struct {
        Id            Id          `db:"reservation_id"`
        UserId        core.UserId `db:"user_id"`
        Index         shelf.Index `db:"shelf_index"`
        ScheduledTime time.Time   `db:"scheduled_time"` // sql.db doesn't support type alias for time.Time
        PurchaseNum   core.Count  `db:"purchase_num"`
}

func ReservationRowsToUserIdArray(rows []*ReservationRow) []core.UserId <span class="cov8" title="1">{
        checked := make(map[core.UserId]struct{})
        userIdArray := make([]core.UserId, 0)
        for _, r := range rows </span><span class="cov8" title="1">{
                if _, ok := checked[r.UserId]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">checked[r.UserId] = struct{}{}
                userIdArray = append(userIdArray, r.UserId)</span>
        }
        <span class="cov8" title="1">return userIdArray</span>
}

func ReservationRowsToIdArray(rows []*ReservationRow) []Id <span class="cov8" title="1">{
        idArray := make([]Id, len(rows))
        for i, r := range rows </span><span class="cov8" title="1">{
                idArray[i] = r.Id
        }</span>
        <span class="cov8" title="1">return idArray</span>
}

func ToReservationRow(row []*Reservation) []*ReservationRow <span class="cov8" title="1">{
        reservationRows := make([]*ReservationRow, len(row))
        for i, r := range row </span><span class="cov8" title="1">{
                reservationRows[i] = &amp;ReservationRow{
                        Id:            r.Id,
                        UserId:        r.TargetUser,
                        Index:         r.Index,
                        ScheduledTime: r.ScheduledTime,
                        PurchaseNum:   r.PurchaseNum,
                }
        }</span>
        <span class="cov8" title="1">return reservationRows</span>
}

func ToReservationModel(reservations []*ReservationRow) []*Reservation <span class="cov8" title="1">{
        reservationRows := make([]*Reservation, len(reservations))
        for i, r := range reservations </span><span class="cov8" title="1">{
                reservationRows[i] = &amp;Reservation{
                        Id:            r.Id,
                        TargetUser:    r.UserId,
                        Index:         r.Index,
                        ScheduledTime: r.ScheduledTime,
                        PurchaseNum:   r.PurchaseNum,
                }
        }</span>
        <span class="cov8" title="1">return reservationRows</span>
}

type InsertReservationRepoFunc func(context.Context, []*ReservationRow) error
type DeleteReservationToShelfRepoFunc func(context.Context, core.UserId, shelf.Index) error
type DeleteReservationRepoFunc func(context.Context, []Id) error
type FetchReservationRepoFunc func(ctx context.Context, users []core.UserId, from time.Time, to time.Time) (
        []*ReservationRow,
        error,
)

type ItemAttractionRes struct {
        ItemId              core.ItemId         `db:"item_id"`
        Attraction          ItemAttraction      `db:"attraction"`
        PurchaseProbability PurchaseProbability `db:"purchase_probability"`
}

func itemAttractionResToMap(res []*ItemAttractionRes) map[core.ItemId]*ItemAttractionRes <span class="cov8" title="1">{
        result := make(map[core.ItemId]*ItemAttractionRes)
        for _, v := range res </span><span class="cov8" title="1">{
                result[v.ItemId] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

type FetchItemAttractionFunc func(context.Context, []core.ItemId) ([]*ItemAttractionRes, error)

type CheckedTimePair struct {
        ShelfId     shelf.Id     `db:"shelf_id"`
        CheckedTime *CheckedTime `db:"checked_time"`
}

type FetchCheckedTimeFunc func(context.Context, []shelf.Id) ([]*CheckedTimePair, error)

type UpdateCheckedTimePair struct {
        ShelfId     shelf.Id  `db:"shelf_id"`
        CheckedTime time.Time `db:"checked_time"`
}

type UpdateCheckedTime func(context.Context, []*UpdateCheckedTimePair) error
</pre>
		
		<pre class="file" id="file56" style="display: none">package shelf

import (
        "github.com/asragi/RinGo/core/game"
)

type Services struct {
        UpdateShelfContent UpdateShelfContentFunc
        UpdateShelfSize    UpdateShelfSizeFunc
        InitializeShelf    InitializeShelfFunc
        GetShelves         GetShelfFunc
}

func NewService(
        fetchStorage game.FetchStorageFunc,
        fetchItemMaster game.FetchItemMasterFunc,
        fetchShelf FetchShelf,
        insertEmptyShelf InsertEmptyShelfFunc,
        deleteShelfBySize DeleteShelfBySizeFunc,
        updateShelfContent UpdateShelfContentRepoFunc,
        fetchSizeToAction FetchSizeToActionRepoFunc,
        postAction game.PostActionFunc,
        validateAction game.ValidateActionFunc,
        generateId func() string,
) *Services <span class="cov0" title="0">{
        updateShelfContentService := CreateUpdateShelfContent(
                fetchStorage,
                fetchItemMaster,
                fetchShelf,
                updateShelfContent,
                ValidateUpdateShelfContent,
        )

        updateShelfSizeService := CreateUpdateShelfSize(
                fetchShelf,
                fetchSizeToAction,
                insertEmptyShelf,
                deleteShelfBySize,
                postAction,
                ValidateUpdateShelfSize,
                validateAction,
                generateId,
        )

        initializeShelf := CreateInitializeShelf(insertEmptyShelf, generateId)

        getShelves := CreateGetShelves(fetchShelf, fetchItemMaster, fetchStorage)

        return &amp;Services{
                UpdateShelfContent: updateShelfContentService,
                UpdateShelfSize:    updateShelfSizeService,
                InitializeShelf:    initializeShelf,
                GetShelves:         getShelves,
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type updateOnApplyTradeFunc func(context.Context, *updateOnApplyTradeArgs) error

type updateOnApplyTradeArgs struct {
        userId           core.UserId
        targetUserId     core.UserId
        itemId           core.ItemId
        userFundAfter    core.Fund
        targetFundAfter  core.Fund
        userStockAfter   core.Stock
        targetStockAfter core.Stock
}

func CreateUpdateOnApplyTrade(
        updateFund game.UpdateFundFunc,
        updateStorage game.UpdateItemStorageFunc,
) updateOnApplyTradeFunc <span class="cov0" title="0">{
        return func(ctx context.Context, args *updateOnApplyTradeArgs) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("updating on apply trade: %w", err)
                }</span>
                <span class="cov0" title="0">updateFundRequest := []*game.UserFundPair{
                        {
                                UserId: args.userId,
                                Fund:   args.userFundAfter,
                        },
                        {
                                UserId: args.targetUserId,
                                Fund:   args.targetFundAfter,
                        },
                }
                err := updateFund(ctx, updateFundRequest)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">storageData := []*game.StorageData{
                        {
                                UserId:  args.userId,
                                ItemId:  args.itemId,
                                Stock:   args.userStockAfter,
                                IsKnown: true,
                        },
                        {
                                UserId:  args.targetUserId,
                                ItemId:  args.itemId,
                                Stock:   args.targetStockAfter,
                                IsKnown: true,
                        },
                }
                err = updateStorage(ctx, storageData)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type UpdateShelfContentShelfInformation struct {
        Id       Id
        ItemId   core.ItemId
        Index    Index
        Price    core.Price
        SetPrice SetPrice
}

type UpdateShelfContentInformation struct {
        UserId       core.UserId
        UpdatedIndex Index
        Indices      []Index
        Shelves      map[Index]*UpdateShelfContentShelfInformation
}

type UpdateShelfContentFunc func(
        context.Context,
        core.UserId,
        core.ItemId,
        SetPrice,
        Index,
) (*UpdateShelfContentInformation, error)

func CreateUpdateShelfContent(
        fetchStorage game.FetchStorageFunc,
        fetchItemMaster game.FetchItemMasterFunc,
        fetchShelf FetchShelf,
        updateShelfContent UpdateShelfContentRepoFunc,
        validateUpdateShelfContent ValidateUpdateShelfContentFunc,
) UpdateShelfContentFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                userId core.UserId,
                itemId core.ItemId,
                setPrice SetPrice,
                index Index,
        ) (*UpdateShelfContentInformation, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*UpdateShelfContentInformation, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("updating shelf content: %w", err)
                }</span>
                <span class="cov8" title="1">var shelves map[Index]*UpdateShelfContentShelfInformation
                var indices []Index
                storageReq := game.ToUserItemPair(userId, []core.ItemId{itemId})
                storageRes, err := fetchStorage(ctx, storageReq)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if len(storageRes) == 0 </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("storage not found"))
                }</span>
                <span class="cov8" title="1">itemData := game.FillStorageData(storageRes, storageReq)
                userStorage := game.FindStorageData(itemData, userId)
                storage := game.FindItemStorageData(userStorage.ItemData, itemId)
                shelvesRes, err := fetchShelf(ctx, []core.UserId{userId})
                err = validateUpdateShelfContent(shelvesRes, storage, index)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">indices = func(shelves []*ShelfRepoRow) []Index </span><span class="cov8" title="1">{
                        result := make([]Index, len(shelves))
                        for i, v := range shelves </span><span class="cov8" title="1">{
                                result[i] = v.Index
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(shelvesRes)
                <span class="cov8" title="1">shelf := findShelfRow(shelvesRes, userId, index)
                err = updateShelfContent(ctx, shelf.Id, itemId, setPrice)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemIds := shelvesToItemIds(shelvesRes)
                itemIdReq := append(itemIds, itemId)
                itemMasters, err := fetchItemMaster(ctx, itemIdReq)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">itemMasterMap := game.ItemMasterResToMap(itemMasters)
                shelves = func() map[Index]*UpdateShelfContentShelfInformation </span><span class="cov8" title="1">{
                        result := make(map[Index]*UpdateShelfContentShelfInformation)
                        for _, v := range shelvesRes </span><span class="cov8" title="1">{
                                price := func() core.Price </span><span class="cov8" title="1">{
                                        if v.ItemId == core.EmptyItemId </span><span class="cov8" title="1">{
                                                return 0
                                        }</span>
                                        <span class="cov8" title="1">return itemMasterMap[v.ItemId].Price</span>
                                }()
                                <span class="cov8" title="1">result[v.Index] = &amp;UpdateShelfContentShelfInformation{
                                        Id:       v.Id,
                                        ItemId:   v.ItemId,
                                        Index:    v.Index,
                                        Price:    price,
                                        SetPrice: v.SetPrice,
                                }</span>
                        }
                        <span class="cov8" title="1">result[index] = &amp;UpdateShelfContentShelfInformation{
                                Id:       shelf.Id,
                                ItemId:   itemId,
                                Index:    index,
                                Price:    itemMasterMap[itemId].Price,
                                SetPrice: setPrice,
                        }
                        return result</span>
                }()

                <span class="cov8" title="1">return &amp;UpdateShelfContentInformation{
                        UserId:       userId,
                        UpdatedIndex: index,
                        Indices:      indices,
                        Shelves:      shelves,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type UpdateShelfOnPurchaseFunc func(
        ctx context.Context,
        userId core.UserId,
        targetUserId core.UserId,
        index Index,
        num core.Count,
) error

func CreateUpdateShelfOnPurchase(
        getResource game.GetResourceFunc,
        validatePurchase ValidatePurchaseFunc,
        calcPurchase CalcPurchaseFunc,
        updateOnTrade updateOnApplyTradeFunc,
        transaction core.TransactionFunc,
) UpdateShelfOnPurchaseFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                userId core.UserId,
                targetUserId core.UserId,
                index Index,
                num core.Count,
        ) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("updating shelf on purchase: %w", err)
                }</span>
                <span class="cov0" title="0">err := transaction(
                        ctx, func(ctx context.Context) error </span><span class="cov0" title="0">{
                                txHandleError := func(err error) error </span><span class="cov0" title="0">{
                                        return fmt.Errorf("updating shelf on purchase in transaction: %w", err)
                                }</span>
                                <span class="cov0" title="0">validateData, err := validatePurchase(ctx, userId, targetUserId, index, num)
                                if err != nil </span><span class="cov0" title="0">{
                                        return txHandleError(err)
                                }</span>
                                <span class="cov0" title="0">targetFund, err := getResource(ctx, targetUserId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return txHandleError(err)
                                }</span>
                                <span class="cov0" title="0">calcResult, err := calcPurchase(
                                        &amp;purchaseArgs{
                                                userFund:      validateData.UserFund,
                                                targetFund:    targetFund.Fund,
                                                userStock:     validateData.UserStock,
                                                targetStock:   validateData.TargetUserStock,
                                                maxStock:      validateData.MaxStock,
                                                totalCost:     validateData.TotalCost,
                                                profit:        validateData.Profit,
                                                purchaseCount: validateData.PurchaseCount,
                                        },
                                )
                                if err != nil </span><span class="cov0" title="0">{
                                        return txHandleError(err)
                                }</span>
                                <span class="cov0" title="0">itemId := validateData.ItemId
                                err = updateOnTrade(
                                        ctx, &amp;updateOnApplyTradeArgs{
                                                userId:           userId,
                                                targetUserId:     targetUserId,
                                                itemId:           itemId,
                                                userFundAfter:    calcResult.userFundAfter,
                                                targetFundAfter:  calcResult.targetFundAfter,
                                                userStockAfter:   calcResult.userStockAfter,
                                                targetStockAfter: calcResult.targetStockAfter,
                                        },
                                )
                                if err != nil </span><span class="cov0" title="0">{
                                        return txHandleError(err)
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                )
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type UpdateShelfSizeFunc func(
        ctx context.Context,
        userId core.UserId,
        shelfSize Size,
) error

func CreateUpdateShelfSize(
        fetchShelf FetchShelf,
        fetchSizeToAction FetchSizeToActionRepoFunc,
        insertEmptyShelf InsertEmptyShelfFunc,
        deleteShelfBySize DeleteShelfBySizeFunc,
        postAction game.PostActionFunc,
        validateUpdateShelfSize ValidateUpdateShelfSizeFunc,
        validateAction game.ValidateActionFunc,
        generateId core.GenerateUUIDFunc,
) UpdateShelfSizeFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, targetShelfSize Size) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("updating shelf size: %w", err)
                }</span>
                <span class="cov0" title="0">shelves, err := fetchShelf(ctx, []core.UserId{userId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">currentSize := shelfRowToSize(shelves)
                err = validateUpdateShelfSize(currentSize, targetShelfSize)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">actionId, err := fetchSizeToAction(ctx, targetShelfSize)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">_, err = validateAction(ctx, userId, actionId, 1)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">_, err = postAction(ctx, userId, 1, actionId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if targetShelfSize &gt; currentSize </span><span class="cov0" title="0">{
                        err = insertEmptyShelf(ctx, userId, createEmptyShelf(userId, currentSize, targetShelfSize, generateId))
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">err = deleteShelfBySize(ctx, userId, targetShelfSize)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func createEmptyShelf(userId core.UserId, currentSize Size, targetSize Size, generateId func() string) []*ShelfRepoRow <span class="cov0" title="0">{
        shelves := make([]*ShelfRepoRow, 0)
        for i := currentSize; i &lt; targetSize; i++ </span><span class="cov0" title="0">{
                shelves = append(
                        shelves, &amp;ShelfRepoRow{
                                Id:         Id(generateId()),
                                UserId:     userId,
                                ItemId:     core.EmptyItemId,
                                Index:      Index(i),
                                SetPrice:   0,
                                TotalSales: 0,
                        },
                )
        }</span>
        <span class="cov0" title="0">return shelves</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package shelf

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
)

type ValidatePurchaseFunc func(
        ctx context.Context,
        userId core.UserId,
        targetUserId core.UserId,
        index Index,
        num core.Count,
) (*ValidateResult, error)

type ValidateResult struct {
        ItemId             core.ItemId
        UserStock          core.Stock
        TargetUserStock    core.Stock
        PurchaseCount      core.Count
        MaxStock           core.MaxStock
        TotalCost          core.Cost
        Profit             core.Profit
        UserFund           core.Fund
        ReducedStaminaCost core.StaminaCost
}

func CreateValidatePurchase(
        baseRequiredStamina core.StaminaCost,
        reducibleRate game.StaminaReducibleRate,
        purchaseExploreId game.ActionId,
        fetchShelf FetchShelf,
        fetchUserResource game.GetResourceFunc,
        fetchItemMaster game.FetchItemMasterFunc,
        fetchStorage game.FetchStorageFunc,
        fetchUserSkills game.FetchUserSkillFunc,
        fetchReductionStaminaSkill game.FetchReductionStaminaSkillFunc,
        calcStaminaReduction game.CalcStaminaReductionFunc,
        getCurrentTime core.GetCurrentTimeFunc,
) ValidatePurchaseFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                userId core.UserId,
                targetUserId core.UserId,
                index Index,
                num core.Count,
        ) (*ValidateResult, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (*ValidateResult, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("validating purchase: %w", err)
                }</span>
                <span class="cov0" title="0">shelfRes, err := fetchShelf(ctx, []core.UserId{targetUserId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if len(shelfRes) == 0 </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("shelf not found"))
                }</span>
                <span class="cov0" title="0">selectedShelf := findShelfRow(shelfRes, targetUserId, index)
                if selectedShelf == nil </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("shelf not found: %s, index: %d", targetUserId, index))
                }</span>
                <span class="cov0" title="0">targetItemId := selectedShelf.ItemId
                storageRes, err := fetchStorage(
                        ctx,
                        []*game.UserItemPair{
                                {UserId: targetUserId, ItemId: targetItemId},
                                {UserId: userId, ItemId: targetItemId},
                        },
                )
                targetStorageArr := game.FindStorageData(storageRes, targetUserId)
                if targetStorageArr == nil </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("storage not found: %s", targetUserId))
                }</span>
                <span class="cov0" title="0">targetStorage := game.FindItemStorageData(targetStorageArr.ItemData, targetItemId)
                if targetStorage == nil </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("storage not found: %s, item: %s", targetUserId, targetItemId))
                }</span>
                <span class="cov0" title="0">stock := targetStorage.Stock
                isStockEnough := stock.CheckIsStockEnough(num)
                if !isStockEnough </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("stock is not enough: %d, (requested: %d)", targetStorage.Stock, num))
                }</span>
                <span class="cov0" title="0">userStorageArr := game.FindStorageData(storageRes, userId)
                if userStorageArr == nil </span><span class="cov0" title="0">{
                        userStorageArr = &amp;game.BatchGetStorageRes{
                                UserId: userId,
                                ItemData: []*game.StorageData{
                                        {
                                                UserId:  userId,
                                                ItemId:  targetItemId,
                                                Stock:   0,
                                                IsKnown: false,
                                        },
                                },
                        }
                }</span>
                <span class="cov0" title="0">userStorage := game.FindItemStorageData(userStorageArr.ItemData, targetItemId)
                itemMaster, err := fetchItemMaster(ctx, []core.ItemId{targetItemId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if len(itemMaster) == 0 </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("item master not found: %s", targetItemId))
                }</span>
                <span class="cov0" title="0">targetItemMaster := itemMaster[0]
                targetItemMaxCount := targetItemMaster.MaxStock
                isStockOver := core.CheckIsStockOver(userStorage.Stock, num, targetItemMaxCount)
                if isStockOver </span><span class="cov0" title="0">{
                        return handleError(
                                fmt.Errorf(
                                        "stock is over: %d, (requested: %d, max: %d)",
                                        userStorage.Stock,
                                        num,
                                        targetItemMaxCount,
                                ),
                        )
                }</span>
                <span class="cov0" title="0">userResource, err := fetchUserResource(ctx, userId)
                userFund := userResource.Fund
                price := itemMaster[0].Price
                cost := price.CalculateCost(num)
                isFundEnough := userFund.CheckIsFundEnough(cost)
                if !isFundEnough </span><span class="cov0" title="0">{
                        return handleError(
                                fmt.Errorf(
                                        "fund is not enough: %d, (requested: %d, cost: %d)",
                                        userFund,
                                        num,
                                        cost,
                                ),
                        )
                }</span>
                <span class="cov0" title="0">profit := price.CalculateProfit(num)

                reductionSkillsRes, err := fetchReductionStaminaSkill(ctx, []game.ActionId{purchaseExploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">reductionSkillsMap := game.ReductionStaminaSkillToMap(reductionSkillsRes)
                if _, ok := reductionSkillsMap[purchaseExploreId]; !ok </span><span class="cov0" title="0">{
                        reductionSkillsMap[purchaseExploreId] = []core.SkillId{}
                }</span>
                <span class="cov0" title="0">reductionSkills := reductionSkillsMap[purchaseExploreId]
                userSkillsRes, err := fetchUserSkills(ctx, userId, reductionSkills)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">userStamina := userResource.StaminaRecoverTime.CalcStamina(getCurrentTime(), userResource.MaxStamina)
                reducedStamina := calcStaminaReduction(baseRequiredStamina, reducibleRate, userSkillsRes.Skills)
                isStaminaEnough := userStamina.CheckIsStaminaEnough(reducedStamina)
                if !isStaminaEnough </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("stamina not enough"))
                }</span>
                <span class="cov0" title="0">return &amp;ValidateResult{
                        ItemId:             targetItemId,
                        UserStock:          userStorage.Stock,
                        TargetUserStock:    targetStorage.Stock,
                        PurchaseCount:      num,
                        MaxStock:           targetItemMaxCount,
                        TotalCost:          cost,
                        Profit:             profit,
                        UserFund:           userFund,
                        ReducedStaminaCost: reducedStamina,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package shelf

import (
        "fmt"
        "github.com/asragi/RinGo/core/game"
)

type ValidateUpdateShelfContentFunc func(
        []*ShelfRepoRow,
        *game.StorageData,
        Index,
) error

func ValidateUpdateShelfContent(
        shelves []*ShelfRepoRow,
        targetStorage *game.StorageData,
        index Index,
) error <span class="cov0" title="0">{
        if !checkContainIndex(shelves, index) </span><span class="cov0" title="0">{
                return fmt.Errorf("index is not found")
        }</span>
        <span class="cov0" title="0">if checkContainItem(shelves, targetStorage.ItemId) </span><span class="cov0" title="0">{
                return fmt.Errorf("item is already on shelf")
        }</span>
        <span class="cov0" title="0">if targetStorage == nil || targetStorage.Stock &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("stock is empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package shelf

import (
        "fmt"
        "github.com/asragi/RinGo/core/game"
)

type ValidateUpdateShelfSizeFunc func(targetSize Size, currentSize Size) error

func ValidateUpdateShelfSize(size Size, currentSize Size) error <span class="cov0" title="0">{
        if !size.ValidSize() </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid shelf size: %d :%w", size, game.InvalidActionError)
        }</span>
        <span class="cov0" title="0">if size.Equals(currentSize) </span><span class="cov0" title="0">{
                return fmt.Errorf("shelf size is already %d: %w", size, game.InvalidActionError)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package game

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "time"
)

type CheckIsPossibleArgs struct {
        requiredStamina core.StaminaCost
        requiredPrice   core.Cost
        RequiredItems   []*ConsumingItem
        requiredSkills  []*RequiredSkill
        currentStamina  core.Stamina
        currentFund     core.Fund
        itemStockList   map[core.ItemId]core.Stock
        skillLvList     map[core.SkillId]core.SkillLv
        execNum         int
}

type GenerateIsExplorePossibleArgsFunc func(
        *GetExploreMasterRes,
        *GetResourceRes,
        []*ConsumingItem,
        []*RequiredSkill,
        []*UserSkillRes,
        []*StorageData,
        int,
        CalcStaminaReductionFunc,
        time.Time,
) CheckIsPossibleArgs

func GenerateIsExplorePossibleArgs(
        exploreMaster *GetExploreMasterRes,
        userResources *GetResourceRes,
        requiredItems []*ConsumingItem,
        requiredSkills []*RequiredSkill,
        userSkills []*UserSkillRes,
        storage []*StorageData,
        execNum int,
        staminaReductionFunc CalcStaminaReductionFunc,
        currentTime time.Time,
) CheckIsPossibleArgs <span class="cov0" title="0">{
        requiredStamina := staminaReductionFunc(
                exploreMaster.ConsumingStamina,
                exploreMaster.StaminaReducibleRate,
                userSkills,
        )
        currentStamina := userResources.StaminaRecoverTime.CalcStamina(
                currentTime, userResources.MaxStamina,
        )
        itemStockList := func(storage []*StorageData) map[core.ItemId]core.Stock </span><span class="cov0" title="0">{
                result := map[core.ItemId]core.Stock{}
                for _, v := range storage </span><span class="cov0" title="0">{
                        result[v.ItemId] = v.Stock
                }</span>
                <span class="cov0" title="0">return result</span>
        }(storage)
        <span class="cov0" title="0">skillLvList := func(userSkills []*UserSkillRes) map[core.SkillId]core.SkillLv </span><span class="cov0" title="0">{
                result := map[core.SkillId]core.SkillLv{}
                for _, v := range userSkills </span><span class="cov0" title="0">{
                        result[v.SkillId] = v.SkillExp.CalcLv()
                }</span>
                <span class="cov0" title="0">return result</span>
        }(userSkills)
        <span class="cov0" title="0">return CheckIsPossibleArgs{
                requiredStamina: requiredStamina,
                requiredPrice:   exploreMaster.RequiredPayment,
                RequiredItems:   requiredItems,
                requiredSkills:  requiredSkills,
                currentStamina:  currentStamina,
                currentFund:     userResources.Fund,
                itemStockList:   itemStockList,
                skillLvList:     skillLvList,
                execNum:         execNum,
        }</span>
}

type CheckActionPossibleFunc func(*CheckIsPossibleArgs) map[core.IsPossibleType]core.IsPossible

func CheckIsExplorePossible(
        args *CheckIsPossibleArgs,
) map[core.IsPossibleType]core.IsPossible <span class="cov8" title="1">{
        isStaminaEnough := func(required core.StaminaCost, actual core.Stamina, execNum int) core.IsPossible </span><span class="cov8" title="1">{
                return core.IsPossible(actual.CheckIsStaminaEnough(required.Multiply(execNum)))
        }</span>(args.requiredStamina, args.currentStamina, args.execNum)

        <span class="cov8" title="1">isFundEnough := func(required core.Cost, actual core.Fund, execNum int) core.IsPossible </span><span class="cov8" title="1">{
                return core.IsPossible(actual.CheckIsFundEnough(required.Multiply(execNum)))
        }</span>(args.requiredPrice, args.currentFund, args.execNum)

        <span class="cov8" title="1">isSkillEnough := func(required []*RequiredSkill, actual map[core.SkillId]core.SkillLv) core.IsPossible </span><span class="cov8" title="1">{
                for _, v := range required </span><span class="cov8" title="1">{
                        skillLv := actual[v.SkillId]
                        if skillLv &lt; v.RequiredLv </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }(args.requiredSkills, args.skillLvList)

        <span class="cov8" title="1">isItemEnough := func(
                required []*ConsumingItem,
                actual map[core.ItemId]core.Stock,
                execNum int,
        ) core.IsPossible </span><span class="cov8" title="1">{
                for _, v := range required </span><span class="cov8" title="1">{
                        itemStock := actual[v.ItemId]
                        if itemStock &lt; core.Stock(v.MaxCount).Multiply(execNum) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }(args.RequiredItems, args.itemStockList, args.execNum)

        <span class="cov8" title="1">isPossible := isFundEnough &amp;&amp; isSkillEnough &amp;&amp; isStaminaEnough &amp;&amp; isItemEnough

        return map[core.IsPossibleType]core.IsPossible{
                core.PossibleTypeAll:     isPossible,
                core.PossibleTypeSkill:   isSkillEnough,
                core.PossibleTypeStamina: isStaminaEnough,
                core.PossibleTypeItem:    isItemEnough,
                core.PossibleTypeFund:    isFundEnough,
        }</span>
}

type CreateValidateActionArgsFunc func(context.Context, core.UserId, ActionId, int) (*CheckIsPossibleArgs, error)

func CreateShortValidateActionArgs(
        fetchUserResource GetResourceFunc,
        fetchActionMaster FetchExploreMasterFunc,
        fetchConsumingItem FetchConsumingItemFunc,
        fetchRequiredSkill FetchRequiredSkillsFunc,
        fetchUserSkill FetchUserSkillFunc,
        fetchStorage FetchStorageFunc,
        staminaReductionFunc CalcStaminaReductionFunc,
        getTime core.GetCurrentTimeFunc,
        generateArgs GenerateIsExplorePossibleArgsFunc,
) CreateValidateActionArgsFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                userId core.UserId,
                exploreId ActionId,
                execNum int,
        ) (*CheckIsPossibleArgs, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (*CheckIsPossibleArgs, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("updating shelf size: %w", err)
                }</span>

                <span class="cov0" title="0">userResource, err := fetchUserResource(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">exploreMasterRes, err := fetchActionMaster(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if len(exploreMasterRes) &lt;= 0 </span><span class="cov0" title="0">{
                        return handleError(&amp;InvalidResponseFromInfrastructureError{Message: "no rows returned from fetchActionMaster"})
                }</span>
                <span class="cov0" title="0">exploreMaster := exploreMasterRes[0]
                consumingItems, err := fetchConsumingItem(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">requiredSkills, err := fetchRequiredSkill(ctx, []ActionId{exploreId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">skillIds := RequiredSkillsToIdArray(requiredSkills)
                userSkills, err := fetchUserSkill(ctx, userId, skillIds)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">itemIds := ConsumingItemsToIdArray(consumingItems)
                storage, err := fetchStorage(ctx, ToUserItemPair(userId, itemIds))
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">userStorage := FindStorageData(storage, userId)
                if userStorage == nil </span><span class="cov0" title="0">{
                        return handleError(&amp;InvalidResponseFromInfrastructureError{Message: "no rows returned from fetchStorage"})
                }</span>
                <span class="cov0" title="0">currentTime := getTime()
                args := generateArgs(
                        exploreMaster,
                        userResource,
                        consumingItems,
                        requiredSkills,
                        userSkills.Skills,
                        userStorage.ItemData,
                        execNum,
                        staminaReductionFunc,
                        currentTime,
                )
                return &amp;args, nil</span>
        }
}

type ValidateActionFunc func(
        context.Context,
        core.UserId,
        ActionId,
        int,
) (map[core.IsPossibleType]core.IsPossible, error)

func CreateValidateAction(
        fetchUserResource GetResourceFunc,
        fetchActionMaster FetchExploreMasterFunc,
        fetchConsumingItem FetchConsumingItemFunc,
        fetchRequiredSkill FetchRequiredSkillsFunc,
        fetchUserSkill FetchUserSkillFunc,
        fetchStorage FetchStorageFunc,
        getTime core.GetCurrentTimeFunc,
) ValidateActionFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                userId core.UserId,
                exploreId ActionId,
                execNum int,
        ) (map[core.IsPossibleType]core.IsPossible, error) </span><span class="cov0" title="0">{
                args, err := CreateShortValidateActionArgs(
                        fetchUserResource,
                        fetchActionMaster,
                        fetchConsumingItem,
                        fetchRequiredSkill,
                        fetchUserSkill,
                        fetchStorage,
                        CalcStaminaReduction,
                        getTime,
                        GenerateIsExplorePossibleArgs,
                )(ctx, userId, exploreId, execNum)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return CheckIsExplorePossible(args), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package core

import (
        "errors"
        "fmt"
        "math"
        "time"
)

type UserId string

func NewUserId(userId string) (UserId, error) <span class="cov8" title="1">{
        isValid := func(userId string) error </span><span class="cov8" title="1">{
                if len(userId) &lt;= 0 </span><span class="cov8" title="1">{
                        return ThrowInvalidUserIdError(userId)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if err := isValid(userId); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return UserId(userId), nil</span>
}

func (id UserId) String() string <span class="cov8" title="1">{
        return string(id)
}</span>

type Name string

var InvalidNameError = errors.New("invalid name")

func NewName(name string) (Name, error) <span class="cov0" title="0">{
        const MaxNameLength = 10
        isValid := func(name string) error </span><span class="cov0" title="0">{
                if len(name) &lt;= 0 || len(name) &gt; MaxNameLength </span><span class="cov0" title="0">{
                        return InvalidNameError
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if err := isValid(name); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return Name(name), nil</span>
}

func (name Name) String() string <span class="cov0" title="0">{
        return string(name)
}</span>

type Fund int

func (f Fund) CheckIsFundEnough(cost Cost) bool <span class="cov0" title="0">{
        return int(f) &gt;= int(cost)
}</span>

func (f Fund) AddFund(profit Profit) Fund <span class="cov0" title="0">{
        return Fund(int(f) + int(profit))
}</span>

func (f Fund) ReduceFund(cost Cost) (Fund, error) <span class="cov0" title="0">{
        afterValue := int(f) - int(cost)
        if afterValue &lt; 0 </span><span class="cov0" title="0">{
                return Fund(0), fmt.Errorf("fund will be less than 0: (fund: %d, cost: %d)", int(f), int(cost))
        }</span>
        <span class="cov0" title="0">return Fund(int(math.Max(0, float64(afterValue)))), nil</span>
}

// 1 point equals to 30 sec.
const StaminaSec = 30.0

type Stamina int

func (s StaminaCost) Multiply(value int) StaminaCost <span class="cov0" title="0">{
        return StaminaCost(int(s) * value)
}</span>

type StaminaCost int
type ReducedStaminaCost int

func (s Stamina) CheckIsStaminaEnough(cost StaminaCost) bool <span class="cov0" title="0">{
        return int(s) &gt;= int(cost)
}</span>

type MaxStamina int
type StaminaRecoverTime time.Time

func (s Stamina) Reduction(rate float64) Stamina <span class="cov0" title="0">{
        return Stamina(float64(s) * rate)
}</span>

func (recoverTime StaminaRecoverTime) CalcStamina(currentTime time.Time, maxStamina MaxStamina) Stamina <span class="cov0" title="0">{
        timeDiff := time.Time(recoverTime).Unix() - currentTime.Unix()
        timeDiffSec := float64(timeDiff)
        lostStamina := Stamina(math.Ceil(timeDiffSec / StaminaSec))
        return Stamina(maxStamina) - lostStamina
}</span>

func CalcAfterStamina(
        currentStamina StaminaRecoverTime,
        reduceStamina StaminaCost,
) StaminaRecoverTime <span class="cov8" title="1">{
        extendTime := int64(float64(reduceStamina) * StaminaSec)
        return StaminaRecoverTime(time.Time(currentStamina).Add(time.Second * time.Duration(extendTime)))
}</span>

type DisplayName string

func (name DisplayName) String() string <span class="cov0" title="0">{
        return string(name)
}</span>

type Description string

type ItemId string

var EmptyItemId = ItemId("empty")

func NewItemId(id string) (ItemId, error) <span class="cov0" title="0">{
        return ItemId(id), nil
}</span>

func (id ItemId) String() string <span class="cov0" title="0">{
        return string(id)
}</span>

type current int
type Price current

func (p Price) CalculateCost(num Count) Cost <span class="cov0" title="0">{
        return Cost(int(p) * int(num))
}</span>

func (p Price) CalculateProfit(num Count) Profit <span class="cov0" title="0">{
        return Profit(int(p) * int(num))
}</span>

type Cost current

func (c Cost) Multiply(value int) Cost <span class="cov0" title="0">{
        return Cost(int(c) * value)
}</span>

type Profit current

func (p Profit) Multiply(value int) Profit <span class="cov0" title="0">{
        return Profit(int(p) * value)
}</span>

type MaxStock int
type Count int

func (s Stock) CheckIsStockEnough(num Count) bool <span class="cov0" title="0">{
        return s &gt;= Stock(num)
}</span>

func CheckIsStockOver(stock Stock, num Count, maxCount MaxStock) bool <span class="cov0" title="0">{
        return int(stock)+int(num) &gt; int(maxCount)
}</span>

type SalesFigures int

func (s SalesFigures) AddSalesFigures(num Count) SalesFigures <span class="cov0" title="0">{
        return SalesFigures(int(s) + int(num))
}</span>

func (s SalesFigures) TotalingSales(other SalesFigures) SalesFigures <span class="cov0" title="0">{
        return SalesFigures(int(s) + int(other))
}</span>

type Stock int

func (s Stock) AddStock(count Count, max MaxStock) Stock <span class="cov0" title="0">{
        return Stock(math.Max(0, math.Min(float64(s)+float64(count), float64(max))))
}</span>

func (s Stock) SubStock(count Count) (Stock, error) <span class="cov0" title="0">{
        if s &lt; Stock(count) </span><span class="cov0" title="0">{
                return Stock(0), fmt.Errorf("stock will be less than 0: (stock: %d, count: %d)", int(s), int(count))
        }</span>
        <span class="cov0" title="0">return Stock(math.Max(0, float64(s)-float64(count))), nil</span>
}

func (s Stock) Multiply(value int) Stock <span class="cov0" title="0">{
        return Stock(int(s) * value)
}</span>

// skill master
type SkillId string

func (id SkillId) ToString() string <span class="cov0" title="0">{
        return string(id)
}</span>

// skill user
type SkillLv int

var MaxSkillLv = SkillLv(100)

func (lv SkillLv) ApplySkillRate(rate float64) float64 <span class="cov0" title="0">{
        if lv &lt;= 1 </span><span class="cov0" title="0">{
                return rate
        }</span>
        <span class="cov0" title="0">skillRate := float64(MaxSkillLv-lv) / float64(MaxSkillLv)
        return rate * skillRate</span>
}

type SkillExp int

func (exp SkillExp) CalcLv() SkillLv <span class="cov8" title="1">{
        skillMax := 100
        sum := int(exp)
        for i := 1; i &lt; skillMax; i++ </span><span class="cov8" title="1">{
                sum = sum - i*10
                if sum &lt; 0 </span><span class="cov8" title="1">{
                        return SkillLv(i)
                }</span>
        }
        <span class="cov8" title="1">return SkillLv(skillMax)</span>
}

// explore user
type IsKnown bool

func ToIsKnown(val int) IsKnown <span class="cov0" title="0">{
        return val != 0
}</span>

type IsPossible bool
type IsPossibleType string

const (
        PossibleTypeAll     IsPossibleType = "All"
        PossibleTypeSkill   IsPossibleType = "Skill"
        PossibleTypeItem    IsPossibleType = "Item"
        PossibleTypeStamina IsPossibleType = "Stamina"
        PossibleTypeFund    IsPossibleType = "Func"
)

type Limit int
type Offset int
</pre>
		
		<pre class="file" id="file66" style="display: none">package core

type Services struct {
        UpdateUserName UpdateUserNameServiceFunc
        UpdateShopName UpdateShopNameServiceFunc
}

func NewService(updateUserName UpdateUserNameFunc, updateShopName UpdateShopNameFunc) *Services <span class="cov0" title="0">{
        return &amp;Services{
                UpdateUserName: CreateUpdateUserNameService(updateUserName),
                UpdateShopName: CreateUpdateShopNameService(updateShopName),
        }
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package core

import "context"

type UpdateShopNameServiceFunc func(context.Context, UserId, Name) error

func CreateUpdateShopNameService(updateShopName UpdateShopNameFunc) UpdateShopNameServiceFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId UserId, userName Name) error </span><span class="cov0" title="0">{
                return updateShopName(ctx, userId, userName)
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package core

import "context"

type UpdateUserNameServiceFunc func(context.Context, UserId, Name) error

func CreateUpdateUserNameService(updateUserName UpdateUserNameFunc) UpdateUserNameServiceFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId UserId, userName Name) error </span><span class="cov0" title="0">{
                return updateUserName(ctx, userId, userName)
        }</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package core

import (
        "math/rand"
        "time"
)

type EmitRandomFunc func() float32

func EmitRandom() float32 <span class="cov0" title="0">{
        return rand.Float32()
}</span>

type RandomEmitter struct{}

func (emitter *RandomEmitter) Emit() float32 <span class="cov0" title="0">{
        return rand.Float32()
}</span>

type GetCurrentTimeFunc func() time.Time

type GenerateUUIDFunc func() string
</pre>
		
		<pre class="file" id="file70" style="display: none">package crypto

import "golang.org/x/crypto/bcrypt"

func Encrypt(password string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(hash), err
}</span>

func Compare(hash, password string) error <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package crypto

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
)

type SHA256Func func(string, string) (string, error)

func SHA256WithKey(key, msg string) (string, error) <span class="cov8" title="1">{
        mac := hmac.New(sha256.New, []byte(key))
        _, err := mac.Write([]byte(msg))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("sha256 with key: %w", err)
        }</span>
        <span class="cov8" title="1">str := hex.EncodeToString(mac.Sum(nil))
        return str, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/jmoiron/sqlx"
)

type ConnectionSettings struct {
        UserName string
        Password string
        Port     string
        Protocol string
        Host     string
        Database string
}

func ConnectDB(settings *ConnectionSettings) (*sqlx.DB, error) <span class="cov0" title="0">{
        dataSource := fmt.Sprintf(
                "%s:%s@%s(%s:%s)/%s",
                settings.UserName,
                settings.Password,
                settings.Protocol,
                settings.Host,
                settings.Port,
                settings.Database,
        )
        dataSource = fmt.Sprintf("%s?parseTime=True", dataSource)
        db, err := sqlx.Open("mysql", dataSource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return db, nil</span>
}

type (
        DBAccessor struct {
                writer *sqlx.DB
                reader *sqlx.DB
        }

        abstractSqlxDB interface {
                BindNamed(query string, arg interface{}) (q string, args []interface{}, err error)
                ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
                QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error)
        }

        ctxKeyTx struct{}
)

func NewDBAccessor(
        writer *sqlx.DB,
        reader *sqlx.DB,
) *DBAccessor <span class="cov8" title="1">{
        return &amp;DBAccessor{
                writer: writer,
                reader: reader,
        }
}</span>

func withTxDB(ctx context.Context, tx *sqlx.Tx) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, &amp;ctxKeyTx{}, tx)
}</span>

func getTxFromContext(ctx context.Context) (*sqlx.Tx, error) <span class="cov8" title="1">{
        if v := ctx.Value(&amp;ctxKeyTx{}); v != nil </span><span class="cov8" title="1">{
                tx, ok := v.(*sqlx.Tx)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert to *sqlx.Tx: %v", v)
                }</span>

                <span class="cov8" title="1">return tx, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func (dba *DBAccessor) Close() error <span class="cov0" title="0">{
        writerErr := dba.writer.Close()
        if dba.writer == dba.reader </span><span class="cov0" title="0">{
                return writerErr
        }</span>
        <span class="cov0" title="0">readerErr := dba.reader.Close()
        if writerErr != nil </span><span class="cov0" title="0">{
                if readerErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("writerErr: %w, readerErr: %w", writerErr, readerErr)
                }</span>
                <span class="cov0" title="0">return writerErr</span>
        }
        <span class="cov0" title="0">if readerErr != nil </span><span class="cov0" title="0">{
                return readerErr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (dba *DBAccessor) Transaction(ctx context.Context, txFunc func(context.Context) error) (err error) <span class="cov8" title="1">{
        tx, err := dba.writer.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if err := tx.Rollback(); err != nil </span>{<span class="cov0" title="0">
                                // ログ出力
                        }</span>
                        <span class="cov0" title="0">err = fmt.Errorf("panicked on execution txFunc: %v", r)</span>
                }
        }()

        <span class="cov8" title="1">txCtx := withTxDB(ctx, tx)

        if txErr := txFunc(txCtx); txErr != nil </span><span class="cov8" title="1">{
                if err := tx.Rollback(); err != nil </span>{<span class="cov0" title="0">
                        // ログ出力
                }</span>

                <span class="cov8" title="1">return txErr</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type ExecFunc func(
        ctx context.Context,
        query string,
        arg interface{},
) (sql.Result, error)

func (dba *DBAccessor) Exec(
        ctx context.Context,
        query string,
        arg interface{},
) (sql.Result, error) <span class="cov8" title="1">{
        tx, err := getTxFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to getTxFromContext: %w", err)
        }</span>

        <span class="cov8" title="1">var da abstractSqlxDB
        if tx != nil </span><span class="cov8" title="1">{
                da = tx
        }</span> else<span class="cov8" title="1"> {
                da = dba.writer
        }</span>

        <span class="cov8" title="1">if arg == nil </span><span class="cov8" title="1">{
                result, err := da.ExecContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to run exec: %w", err)
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }

        // prepare
        <span class="cov8" title="1">namedQuery, namedArgs, err := da.BindNamed(query, arg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to BindNamed: %w", err)
        }</span>
        <span class="cov8" title="1">namedQuery, namedArgs, err = sqlx.In(namedQuery, namedArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sqlx.In: %w", err)
        }</span>

        <span class="cov8" title="1">result, err := da.ExecContext(ctx, namedQuery, namedArgs...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to run exec: %w", err)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

type QueryFunc func(
        ctx context.Context,
        query string,
        arg interface{},
) (*sqlx.Rows, error)

func (dba *DBAccessor) Query(
        ctx context.Context,
        query string,
        arg interface{},
) (*sqlx.Rows, error) <span class="cov8" title="1">{
        tx, err := getTxFromContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to getTxFromContext: %w", err)
        }</span>

        <span class="cov8" title="1">var da abstractSqlxDB
        if tx != nil </span><span class="cov8" title="1">{
                da = tx
        }</span> else<span class="cov8" title="1"> {
                da = dba.reader
        }</span>

        <span class="cov8" title="1">if arg == nil </span><span class="cov8" title="1">{
                rows, err := da.QueryxContext(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to run query: %w", err)
                }</span>
                <span class="cov8" title="1">return rows, nil</span>
        }

        // prepare
        <span class="cov8" title="1">namedQuery, namedArgs, err := da.BindNamed(query, arg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to BindNamed: %w", err)
        }</span>
        // namedQuery, namedArgs, err = sqlx.In(namedQuery, namedArgs...)
        <span class="cov8" title="1">namedQuery, namedArgs, err = sqlx.In(namedQuery, namedArgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sqlx.In: %w", err)
        }</span>

        <span class="cov8" title="1">rows, err := da.QueryxContext(ctx, namedQuery, namedArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to run query: %w", err)
        }</span>

        <span class="cov8" title="1">return rows, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package debug

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/database"
)

type AddInitialPeriodFunc func(ctx context.Context) error

func CreateAddInitialPeriod(execFunc database.ExecFunc) AddInitialPeriodFunc <span class="cov8" title="1">{
        return func(ctx context.Context) error </span><span class="cov8" title="1">{
                query := `INSERT INTO ringo.rank_period_table (rank_period) VALUES (1)`
                _, err := execFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert initial period: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package debug

import "flag"

type RunMode struct {
        devMode bool
}

func NewRunMode() *RunMode <span class="cov0" title="0">{
        devMode := flag.Bool("dev", false, "Run in dev mode")
        flag.Parse()
        return &amp;RunMode{
                devMode: *devMode,
        }
}</span>

func (r *RunMode) IsDevMode() bool <span class="cov0" title="0">{
        return r.devMode
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package debug

import (
        "fmt"
        "github.com/asragi/RinGo/core"
        "time"
)

type Timer struct {
        emitTime core.GetCurrentTimeFunc
}

func NewTimer() *Timer <span class="cov8" title="1">{
        emitter := func() time.Time </span><span class="cov8" title="1">{
                return time.Now().UTC()
        }</span>
        <span class="cov8" title="1">return &amp;Timer{
                emitTime: emitter,
        }</span>
}

func (t *Timer) EmitTime() time.Time <span class="cov8" title="1">{
        out := t.emitTime()
        fmt.Printf("Time emitted: %v\n", out.Format(time.DateTime))
        return out
}</span>

func (t *Timer) SetTimer(f core.GetCurrentTimeFunc) <span class="cov8" title="1">{
        fmt.Printf("Set timer:%s\n", f().Format(time.DateTime))
        t.emitTime = f
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/admin"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type AdminLoginEndpoint func(context.Context, *gateway.AdminLoginRequest) (*gateway.AdminLoginResponse, error)

func CreateAdminLoginEndpoint(loginFunc admin.LoginFunc) AdminLoginEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.AdminLoginRequest) (*gateway.AdminLoginResponse, error) </span><span class="cov8" title="1">{
                userId := core.UserId(req.UserId)
                rowPass := auth.RowPassword(req.RowPassword)
                res, err := loginFunc(ctx, userId, rowPass)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("login endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.AdminLoginResponse{
                        Token: res.String(),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/admin"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game/shelf/reservation"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type AutoInsertReservationEndpoint func(
        ctx context.Context,
        req *gateway.InvokeAutoApplyReservationRequest,
) (*gateway.InvokeAutoApplyReservationResponse, error)

func CreateAutoInsertReservationEndpoint(
        apply reservation.AutoInsertReservationFunc,
        validateToken auth.ValidateTokenFunc,
        checkIsAdmin admin.CheckIsAdminFunc,
) AutoInsertReservationEndpoint <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                req *gateway.InvokeAutoApplyReservationRequest,
        ) (*gateway.InvokeAutoApplyReservationResponse, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (*gateway.InvokeAutoApplyReservationResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on auto insert reservation: %w", err)
                }</span>
                <span class="cov0" title="0">token, err := auth.NewAccessToken(req.GetToken())
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">isAdmin, err := checkIsAdmin(ctx, tokenInfo.UserId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">if !isAdmin </span><span class="cov0" title="0">{
                        return handleError(admin.NotAdminError)
                }</span>
                <span class="cov0" title="0">err = apply(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return &amp;gateway.InvokeAutoApplyReservationResponse{}, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/admin"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game/shelf/ranking"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type ChangePeriodEndpoint func(context.Context, *gateway.ChangePeriodRequest) (*gateway.ChangePeriodResponse, error)

func CreateChangePeriod(
        changePeriod ranking.OnChangePeriodFunc,
        validateToken auth.ValidateTokenFunc,
        checkIsAdmin admin.CheckIsAdminFunc,
) ChangePeriodEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.ChangePeriodRequest) (*gateway.ChangePeriodResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.ChangePeriodResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on change period: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">isAdmin, err := checkIsAdmin(ctx, tokenInfo.UserId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if !isAdmin </span><span class="cov0" title="0">{
                        return handleError(admin.NotAdminError)
                }</span>
                <span class="cov8" title="1">err = changePeriod(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.ChangePeriodResponse{}, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "time"

        "github.com/asragi/RinGo/admin"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/debug"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type ChangeTimeEndpointFunc func(context.Context, *gateway.ChangeTimeRequest) (*gateway.ChangeTimeResponse, error)

func CreateChangeTimeEndpoint(
        changeTime debug.ChangeTimeInterface,
        validateToken auth.ValidateTokenFunc,
        checkIsAdmin admin.CheckIsAdminFunc,
) ChangeTimeEndpointFunc <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.ChangeTimeRequest) (*gateway.ChangeTimeResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.ChangeTimeResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on change time: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">isAdmin, err := checkIsAdmin(ctx, tokenInfo.UserId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">if !isAdmin </span><span class="cov0" title="0">{
                        return handleError(admin.NotAdminError)
                }</span>
                <span class="cov8" title="1">changeTime.SetTimer(func() time.Time </span><span class="cov8" title="1">{ return req.Time.AsTime() }</span>)
                <span class="cov8" title="1">return &amp;gateway.ChangeTimeResponse{}, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetItemActionDetailEndpoint func(
        context.Context,
        *gateway.GetItemActionDetailRequest,
) (*gateway.GetItemActionDetailResponse, error)

func CreateGetItemActionDetailEndpoint(
        getItemActionFunc explore.GetItemActionDetailFunc,
        validateToken auth.ValidateTokenFunc,
) GetItemActionDetailEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.GetItemActionDetailRequest) (
                *gateway.GetItemActionDetailResponse,
                error,
        ) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetItemActionDetailResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("on get item action detail endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.AccessToken)
                tokenInformation, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInformation.UserId
                itemId := core.ItemId(req.ItemId)
                exploreId := game.ActionId(req.ExploreId)
                res, err := getItemActionFunc(ctx, userId, itemId, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">requiredSkills := explore.RequiredSkillsToGateway(res.RequiredSkills)
                requiredItems := explore.RequiredItemsToGateway(res.RequiredItems)
                earningItems := explore.EarningItemsToGateway(res.EarningItems)

                return &amp;gateway.GetItemActionDetailResponse{
                        UserId:            string(res.UserId),
                        ItemId:            string(res.ItemId),
                        DisplayName:       string(res.DisplayName),
                        ActionDisplayName: string(res.ActionDisplayName),
                        RequiredPayment:   int32(res.RequiredPayment),
                        RequiredStamina:   int32(res.RequiredStamina),
                        RequiredItems:     requiredItems,
                        RequiredSkills:    requiredSkills,
                        EarningItems:      earningItems,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetItemDetailEndpointFunc func(
        context.Context,
        *gateway.GetItemDetailRequest,
) (*gateway.GetItemDetailResponse, error)

func CreateGetItemDetail(
        getItemDetail explore.GetItemDetailFunc,
        validateToken auth.ValidateTokenFunc,
) GetItemDetailEndpointFunc <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.GetItemDetailRequest) (*gateway.GetItemDetailResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetItemDetailResponse, error) </span><span class="cov0" title="0">{
                        return &amp;gateway.GetItemDetailResponse{}, fmt.Errorf("error on get item detail endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">itemId := core.ItemId(req.ItemId)
                token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                res, err := getItemDetail(ctx, userId, itemId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">explores := func(explores []*game.UserExplore) []*gateway.UserExplore </span><span class="cov8" title="1">{
                        result := make([]*gateway.UserExplore, len(explores))
                        for i, v := range explores </span><span class="cov8" title="1">{
                                result[i] = &amp;gateway.UserExplore{
                                        ExploreId:   string(v.ExploreId),
                                        DisplayName: string(v.DisplayName),
                                        IsKnown:     bool(v.IsKnown),
                                        IsPossible:  bool(v.IsPossible),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(res.UserExplores)
                <span class="cov8" title="1">return &amp;gateway.GetItemDetailResponse{
                        UserId:      string(res.UserId),
                        ItemId:      string(res.ItemId),
                        Price:       int32(res.Price),
                        MaxStock:    int32(res.MaxStock),
                        Stock:       int32(res.Stock),
                        UserExplore: explores,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetItemListEndpoint func(context.Context, *gateway.GetItemListRequest) (*gateway.GetItemListResponse, error)

func CreateGetItemService(
        getItem game.GetItemListFunc,
        validateToken auth.ValidateTokenFunc,
) GetItemListEndpoint <span class="cov8" title="1">{
        get := func(ctx context.Context, req *gateway.GetItemListRequest) (*gateway.GetItemListResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetItemListResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("get item list endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                res, err := getItem(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;gateway.GetItemListResponse{}, fmt.Errorf("error on get item list endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">itemList := func(res []*game.ItemListRow) []*gateway.GetItemListResponseRow </span><span class="cov8" title="1">{
                        result := make([]*gateway.GetItemListResponseRow, len(res))
                        for i, v := range res </span><span class="cov8" title="1">{
                                result[i] = &amp;gateway.GetItemListResponseRow{
                                        ItemId:      string(v.ItemId),
                                        DisplayName: string(v.DisplayName),
                                        Stock:       int32(v.Stock),
                                        MaxStock:    int32(v.MaxStock),
                                        Price:       int32(v.Price),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(res)
                <span class="cov8" title="1">return &amp;gateway.GetItemListResponse{
                        ItemList: itemList,
                }, nil</span>
        }

        <span class="cov8" title="1">return get</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/reservation"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetMyShelvesEndpointFunc func(context.Context, *gateway.GetMyShelfRequest) (*gateway.GetMyShelfResponse, error)

func CreateGetMyShelvesEndpoint(
        getShelvesFunc shelf.GetShelfFunc,
        applyReservation reservation.ApplyReservationFunc,
        validateToken auth.ValidateTokenFunc,
) GetMyShelvesEndpointFunc <span class="cov8" title="1">{
        return func(ctx context.Context, request *gateway.GetMyShelfRequest) (*gateway.GetMyShelfResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetMyShelfResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error on get my shelves: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(request.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userIdReq := []core.UserId{tokenInfo.UserId}
                err = applyReservation(ctx, userIdReq)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">shelves, err := getShelvesFunc(ctx, userIdReq)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">res := func() []*gateway.Shelf </span><span class="cov8" title="1">{
                        var res []*gateway.Shelf
                        for _, shelf := range shelves </span><span class="cov8" title="1">{
                                res = append(
                                        res, &amp;gateway.Shelf{
                                                Index:       int32(shelf.Index),
                                                SetPrice:    int32(shelf.SetPrice),
                                                ItemId:      shelf.ItemId.String(),
                                                DisplayName: shelf.DisplayName.String(),
                                                Stock:       int32(shelf.Stock),
                                                UserId:      shelf.UserId.String(),
                                                ShelfId:     shelf.Id.String(),
                                        },
                                )
                        }</span>
                        <span class="cov8" title="1">return res</span>
                }()
                <span class="cov8" title="1">return &amp;gateway.GetMyShelfResponse{
                        Shelves: res,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/ranking"
        "github.com/asragi/RinGo/core/game/shelf/reservation"
        "github.com/asragi/RinGo/utils"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetRankingUserListEndpoint func(
        context.Context,
        *gateway.GetDailyRankingRequest,
) (*gateway.GetDailyRankingResponse, error)

func CreateGetRankingUserList(
        applyAllReservation reservation.ApplyAllReservationsFunc,
        getUserRankingList ranking.FetchUserDailyRanking,
) GetRankingUserListEndpoint <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                req *gateway.GetDailyRankingRequest,
        ) (*gateway.GetDailyRankingResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetDailyRankingResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("get ranking user list endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">err := applyAllReservation(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">limit := core.Limit(req.Limit)
                offset := core.Offset(req.Offset)
                res, err := getUserRankingList(ctx, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userRankingResSet := utils.NewSet(res)
                userList := utils.SetSelect(
                        userRankingResSet, func(rankData *ranking.UserDailyRanking) *gateway.RankingRow </span><span class="cov8" title="1">{
                                shelvesSet := utils.NewSet(rankData.Shelves)
                                shelvesRes := utils.SetSelect(
                                        shelvesSet, func(shelf *shelf.Shelf) *gateway.Shelf </span><span class="cov8" title="1">{
                                                return &amp;gateway.Shelf{
                                                        Index:       int32(shelf.Index),
                                                        SetPrice:    int32(shelf.SetPrice),
                                                        ItemId:      shelf.ItemId.String(),
                                                        DisplayName: shelf.DisplayName.String(),
                                                        Stock:       int32(shelf.Stock),
                                                        MaxStock:    -1, // TODO: remove MaxStock from gateway.Shelf or set it from master data
                                                        UserId:      shelf.UserId.String(),
                                                        ShelfId:     shelf.Id.String(),
                                                }
                                        }</span>,
                                )
                                <span class="cov8" title="1">return &amp;gateway.RankingRow{
                                        UserId:     rankData.UserId.String(),
                                        UserName:   rankData.UserName.String(),
                                        Rank:       int32(rankData.Rank),
                                        TotalScore: int32(rankData.TotalScore),
                                        Shelves:    shelvesRes.ToArray(),
                                }</span>
                        },
                )
                <span class="cov8" title="1">return &amp;gateway.GetDailyRankingResponse{
                        Ranking: userList.ToArray(),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RingoSuPBGo/gateway"
        "google.golang.org/protobuf/types/known/timestamppb"
        "time"
)

type GetResourceEndpoint func(context.Context, *gateway.GetResourceRequest) (*gateway.GetResourceResponse, error)

func CreateGetResourceEndpoint(
        serviceFunc explore.GetUserResourceServiceFunc,
        validateToken auth.ValidateTokenFunc,
) GetResourceEndpoint <span class="cov8" title="1">{
        get := func(ctx context.Context, req *gateway.GetResourceRequest) (*gateway.GetResourceResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetResourceResponse, error) </span><span class="cov0" title="0">{
                        return &amp;gateway.GetResourceResponse{}, fmt.Errorf("error on get resource: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                res, err := serviceFunc(ctx, userId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.GetResourceResponse{
                        UserId:      string(res.UserId),
                        MaxStamina:  int32(res.MaxStamina),
                        RecoverTime: timestamppb.New(time.Time(res.StaminaRecoverTime)),
                        Fund:        int32(res.Fund),
                }, nil</span>
        }
        <span class="cov8" title="1">return get</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game"

        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetStageActionEndpointFunc func(
        context.Context,
        *gateway.GetStageActionDetailRequest,
) (*gateway.GetStageActionDetailResponse, error)

func CreateGetStageActionDetail(
        createStageActionDetail explore.GetStageActionDetailFunc,
        validateToken auth.ValidateTokenFunc,
) GetStageActionEndpointFunc <span class="cov8" title="1">{
        get := func(
                ctx context.Context,
                req *gateway.GetStageActionDetailRequest,
        ) (*gateway.GetStageActionDetailResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetStageActionDetailResponse, error) </span><span class="cov0" title="0">{
                        return &amp;gateway.GetStageActionDetailResponse{}, fmt.Errorf(
                                "error on get stage action detail endpoint: %w",
                                err,
                        )
                }</span>
                <span class="cov8" title="1">exploreId := game.ActionId(req.ExploreId)
                stageId := explore.StageId(req.StageId)
                token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                res, err := createStageActionDetail(ctx, userId, stageId, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;res, nil</span>
        }

        <span class="cov8" title="1">return get</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game"

        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type GetStageListEndpointFunc func(
        context.Context,
        *gateway.GetStageListRequest,
) (*gateway.GetStageListResponse, error)

func CreateGetStageList(
        getStageList explore.GetStageListFunc,
        validateToken auth.ValidateTokenFunc,
        timer core.GetCurrentTimeFunc,
) GetStageListEndpointFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                req *gateway.GetStageListRequest,
        ) (*gateway.GetStageListResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.GetStageListResponse, error) </span><span class="cov0" title="0">{
                        return &amp;gateway.GetStageListResponse{}, fmt.Errorf("error on get stage list: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                res, err := getStageList(ctx, userId, timer)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">information := func(
                        res []*explore.StageInformation,
                ) []*gateway.StageInformation </span><span class="cov8" title="1">{
                        result := make([]*gateway.StageInformation, len(res))
                        for i, v := range res </span><span class="cov8" title="1">{
                                explores := func(exps []*game.UserExplore) []*gateway.UserExplore </span><span class="cov8" title="1">{
                                        result := make([]*gateway.UserExplore, len(exps))
                                        for i, v := range exps </span><span class="cov8" title="1">{
                                                result[i] = &amp;gateway.UserExplore{
                                                        ExploreId:   string(v.ExploreId),
                                                        DisplayName: string(v.DisplayName),
                                                        IsKnown:     bool(v.IsKnown),
                                                        IsPossible:  bool(v.IsPossible),
                                                }
                                        }</span>
                                        <span class="cov8" title="1">return result</span>
                                }(v.UserExplores)
                                <span class="cov8" title="1">result[i] = &amp;gateway.StageInformation{
                                        StageId:     string(v.StageId),
                                        DisplayName: string(v.DisplayName),
                                        Description: string(v.Description),
                                        IsKnown:     bool(v.IsKnown),
                                        UserExplore: explores,
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }(res)

                <span class="cov8" title="1">return &amp;gateway.GetStageListResponse{
                        StageInformation: information,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type LoginEndpoint func(context.Context, *gateway.LoginRequest) (*gateway.LoginResponse, error)

func CreateLoginEndpoint(loginFunc auth.LoginFunc) LoginEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.LoginRequest) (*gateway.LoginResponse, error) </span><span class="cov8" title="1">{
                userId := core.UserId(req.UserId)
                rowPass := auth.RowPassword(req.RowPassword)
                res, err := loginFunc(ctx, userId, rowPass)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("login endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.LoginResponse{
                        AccessToken: string(res),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package endpoint

import (
        "context"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RingoSuPBGo/gateway"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type PostActionEndpointFunc func(context.Context, *gateway.PostActionRequest) (*gateway.PostActionResponse, error)

func CreatePostAction(
        postAction game.PostActionFunc,
        validateToken auth.ValidateTokenFunc,
) PostActionEndpointFunc <span class="cov8" title="1">{
        post := func(ctx context.Context, req *gateway.PostActionRequest) (*gateway.PostActionResponse, error) </span><span class="cov8" title="1">{
                exploreId := game.ActionId(req.ExploreId)
                token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Unauthenticated, "error on post action: %+v", err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                execCount := int(req.ExecCount)
                res, err := postAction(ctx, userId, execCount, exploreId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.Internal, "error on post action: %+v", err)
                }</span>

                <span class="cov8" title="1">earnedItem := func() []*gateway.EarnedItems </span><span class="cov8" title="1">{
                        result := make([]*gateway.EarnedItems, len(res.EarnedItems))
                        for i, v := range res.EarnedItems </span><span class="cov8" title="1">{
                                result[i] = &amp;gateway.EarnedItems{
                                        ItemId: string(v.ItemId),
                                        Count:  int32(v.Count),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">consumedItem := func() []*gateway.ConsumedItems </span><span class="cov8" title="1">{
                        result := make([]*gateway.ConsumedItems, len(res.ConsumedItems))
                        for i, v := range res.ConsumedItems </span><span class="cov0" title="0">{
                                result[i] = &amp;gateway.ConsumedItems{
                                        ItemId: string(v.ItemId),
                                        Count:  int32(v.Count),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">skillGrowth := func() []*gateway.SkillGrowthResult </span><span class="cov8" title="1">{
                        result := make([]*gateway.SkillGrowthResult, len(res.SkillGrowthInformation))
                        for i, v := range res.SkillGrowthInformation </span><span class="cov8" title="1">{
                                result[i] = &amp;gateway.SkillGrowthResult{
                                        DisplayName: string(v.DisplayName),
                                        BeforeExp:   int32(v.GrowthResult.BeforeExp),
                                        BeforeLv:    int32(v.GrowthResult.BeforeLv),
                                        SkillId:     string(v.GrowthResult.SkillId),
                                        AfterExp:    int32(v.GrowthResult.AfterExp),
                                        AfterLv:     int32(v.GrowthResult.AfterLv),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">return &amp;gateway.PostActionResponse{
                        EarnedItems:       earnedItem,
                        ConsumedItems:     consumedItem,
                        SkillGrowthResult: skillGrowth,
                }, nil</span>
        }

        <span class="cov8" title="1">return post</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type RegisterEndpointFunc func(context.Context, *gateway.SignUpRequest) (*gateway.SignUpResponse, error)

func CreateRegisterEndpoint(
        register auth.RegisterUserFunc,
        initializeShelf shelf.InitializeShelfFunc,
) RegisterEndpointFunc <span class="cov8" title="1">{
        return func(ctx context.Context, _ *gateway.SignUpRequest) (*gateway.SignUpResponse, error) </span><span class="cov8" title="1">{
                res, err := register(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("register endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">err = initializeShelf(ctx, res.UserId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("register endpoint: %w", err)
                }</span>

                <span class="cov8" title="1">return &amp;gateway.SignUpResponse{
                        UserId:      string(res.UserId),
                        RowPassword: string(res.Password),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/reservation"
        "github.com/asragi/RingoSuPBGo/gateway"
        "google.golang.org/protobuf/types/known/timestamppb"
)

type UpdateShelfContentEndpointFunc func(
        ctx context.Context,
        req *gateway.UpdateShelfContentRequest,
) (*gateway.UpdateShelfContentResponse, error)

func CreateUpdateShelfContentEndpoint(
        updateShelfContent shelf.UpdateShelfContentFunc,
        insertReservation reservation.InsertReservationFunc,
        validateToken auth.ValidateTokenFunc,
) UpdateShelfContentEndpointFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                req *gateway.UpdateShelfContentRequest,
        ) (*gateway.UpdateShelfContentResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.UpdateShelfContentResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("on update shelf content endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                itemId := core.ItemId(req.ItemId)
                index := shelf.Index(req.Index)
                setPrice := shelf.SetPrice(req.SetPrice)
                updateInfo, err := updateShelfContent(ctx, userId, itemId, setPrice, index)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">reservations, err := insertReservation(
                        ctx,
                        updateInfo.UserId,
                        updateInfo.UpdatedIndex,
                        updateInfo.Indices,
                        updateInfo.Shelves,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.UpdateShelfContentResponse{
                        Index:        req.Index,
                        SetPrice:     req.SetPrice,
                        ItemId:       req.ItemId,
                        Reservations: reservationToResponse(reservations.Reservations),
                }, nil</span>
        }
}

func reservationToResponse(reservation []*reservation.InsertedReservation) []*gateway.Reservation <span class="cov8" title="1">{
        reservations := make([]*gateway.Reservation, len(reservation))
        for i, r := range reservation </span><span class="cov8" title="1">{
                reservations[i] = &amp;gateway.Reservation{
                        UserId:        string(r.UserId),
                        Index:         int32(r.Index),
                        ReservationId: string(r.ReservationId),
                        ScheduledTime: timestamppb.New(r.ScheduledTime),
                        PurchaseNum:   int32(r.PurchaseNum),
                }
        }</span>
        <span class="cov8" title="1">return reservations</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type UpdateShelfSizeEndpoint func(
        context.Context,
        *gateway.UpdateShelfSizeRequest,
) (*gateway.UpdateShelfSizeResponse, error)

func CreateUpdateShelfSizeEndpoint(
        updateShelfSize shelf.UpdateShelfSizeFunc,
        validateToken auth.ValidateTokenFunc,
) UpdateShelfSizeEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.UpdateShelfSizeRequest) (*gateway.UpdateShelfSizeResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.UpdateShelfSizeResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("on update shelf size endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">sizeInt := req.Size
                token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                size := shelf.Size(sizeInt)
                err = updateShelfSize(ctx, userId, size)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.UpdateShelfSizeResponse{
                        Size: sizeInt,
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type UpdateShopNameEndpoint func(
        context.Context,
        *gateway.UpdateShopNameRequest,
) (*gateway.UpdateShopNameResponse, error)

func CreateUpdateShopNameEndpoint(
        updateShopName core.UpdateShopNameServiceFunc,
        validateToken auth.ValidateTokenFunc,
) UpdateShopNameEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.UpdateShopNameRequest) (*gateway.UpdateShopNameResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.UpdateShopNameResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("on update shop name endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                shopName, err := core.NewName(req.GetShopName())
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateShopName(ctx, userId, shopName)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.UpdateShopNameResponse{
                        ShopName: shopName.String(),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package endpoint

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RingoSuPBGo/gateway"
)

type UpdateUserNameEndpoint func(
        context.Context,
        *gateway.UpdateUserNameRequest,
) (*gateway.UpdateUserNameResponse, error)

func CreateUpdateUserNameEndpoint(
        updateUserName core.UpdateUserNameServiceFunc,
        validateToken auth.ValidateTokenFunc,
) UpdateUserNameEndpoint <span class="cov8" title="1">{
        return func(ctx context.Context, req *gateway.UpdateUserNameRequest) (*gateway.UpdateUserNameResponse, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*gateway.UpdateUserNameResponse, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("on update user name endpoint: %w", err)
                }</span>
                <span class="cov8" title="1">token := auth.AccessToken(req.Token)
                tokenInfo, err := validateToken(&amp;token)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">userId := tokenInfo.UserId
                userName, err := core.NewName(req.GetUserName())
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">err = updateUserName(ctx, userId, userName)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;gateway.UpdateUserNameResponse{
                        UserName: userName.String(),
                }, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package infrastructure

import (
        "fmt"
        "github.com/asragi/RinGo/core"
)

func UserIdsToString(userIds []core.UserId) []string <span class="cov8" title="1">{
        result := make([]string, len(userIds))
        for i, v := range userIds </span><span class="cov8" title="1">{
                result[i] = fmt.Sprintf(`"%s"`, v)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package in_memory

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/shelf"
)

func FetchSizeToActionRepoInMemory(_ context.Context, size shelf.Size) (game.ActionId, error) <span class="cov8" title="1">{
        return game.ActionId(fmt.Sprintf("size-to-%d", size)), nil
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package mysql

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/admin"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/database"
)

func CreateRegisterAdmin(exec database.ExecFunc) admin.RegisterRepo <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, password auth.HashedPassword) error </span><span class="cov0" title="0">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("register admin: %w", err)
                }</span>
                <span class="cov0" title="0">type req struct {
                        UserId         core.UserId         `db:"user_id"`
                        HashedPassword auth.HashedPassword `db:"hashed_password"`
                }
                query := `INSERT INTO ringo.admin (user_id, hashed_password) VALUES (:user_id, :hashed_password)`
                _, err := exec(ctx, query, req{UserId: userId, HashedPassword: password})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func CreateFetchAdminHashedPassword(queryFunc database.QueryFunc) admin.FetchHashedPassword <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId) (auth.HashedPassword, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (auth.HashedPassword, error) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("fetch hashed password: %w", err)
                }</span>
                <span class="cov0" title="0">type req struct {
                        UserId core.UserId `db:"user_id"`
                }
                var hashedPassword auth.HashedPassword
                query := `SELECT hashed_password FROM ringo.admin WHERE user_id = :user_id`
                rows, err := queryFunc(ctx, query, req{UserId: userId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                if !rows.Next() </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("hashed password not found"))
                }</span>
                <span class="cov0" title="0">if err := rows.Scan(&amp;hashedPassword); err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return hashedPassword, nil</span>
        }
}

func CreateCheckIsAdmin(queryFunc database.QueryFunc) admin.CheckIsAdminRepo <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId) (bool, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (bool, error) </span><span class="cov0" title="0">{
                        return false, fmt.Errorf("check is admin: %w", err)
                }</span>
                <span class="cov0" title="0">type req struct {
                        UserId core.UserId `db:"user_id"`
                }
                query := `SELECT EXISTS(SELECT 1 FROM ringo.admin WHERE user_id = :user_id)`
                rows, err := queryFunc(ctx, query, req{UserId: userId})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                if !rows.Next() </span><span class="cov0" title="0">{
                        return handleError(fmt.Errorf("not found: %s", userId))
                }</span>
                <span class="cov0" title="0">var isAdmin bool
                if err := rows.Scan(&amp;isAdmin); err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">return isAdmin, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package mysql

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/database"
        "github.com/asragi/RinGo/infrastructure"
)

func CreateUpdateUserName(execFunc database.ExecFunc) core.UpdateUserNameFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, userName core.Name) error </span><span class="cov0" title="0">{
                query := fmt.Sprintf(
                        `UPDATE ringo.users SET name = "%s" WHERE user_id = "%s"`,
                        userName.String(),
                        userId.String(),
                )
                _, err := execFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update user name: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
func CreateUpdateShopName(execFunc database.ExecFunc) core.UpdateShopNameFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, shopName core.Name) error </span><span class="cov0" title="0">{
                query := fmt.Sprintf(
                        `UPDATE ringo.users SET shop_name = "%s" WHERE user_id = "%s"`,
                        shopName.String(),
                        userId.String(),
                )
                _, err := execFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update shop name: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func CreateFetchUserName(queryFunc database.QueryFunc) core.FetchUserNameFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userIds []core.UserId) ([]*core.FetchUserNameRes, error) </span><span class="cov0" title="0">{
                if len(userIds) == 0 </span><span class="cov0" title="0">{
                        return []*core.FetchUserNameRes{}, nil
                }</span>
                <span class="cov0" title="0">userIdString := spreadString(infrastructure.UserIdsToString(userIds))
                query := fmt.Sprintf(
                        `SELECT user_id, name, shop_name FROM ringo.users WHERE user_id IN (%s)`,
                        userIdString,
                )
                rows, err := queryFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                var res []*core.FetchUserNameRes
                for rows.Next() </span><span class="cov0" title="0">{
                        var r core.FetchUserNameRes
                        if err := rows.Scan(&amp;r.UserId, &amp;r.UserName, &amp;r.ShopName); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">res = append(res, &amp;r)</span>
                }
                <span class="cov0" title="0">return res, nil</span>
        }
}

func CreateFetchAllUserId(queryFunc database.QueryFunc) core.FetchAllUserId <span class="cov0" title="0">{
        return func(ctx context.Context) ([]core.UserId, error) </span><span class="cov0" title="0">{
                handleError := func(err error) ([]core.UserId, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch all user id: %w", err)
                }</span>
                <span class="cov0" title="0">query := `SELECT user_id FROM ringo.users`
                rows, err := queryFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                var userIds []core.UserId
                for rows.Next() </span><span class="cov0" title="0">{
                        var userId core.UserId
                        if err := rows.Scan(&amp;userId); err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov0" title="0">userIds = append(userIds, userId)</span>
                }
                <span class="cov0" title="0">return userIds, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package mysql

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/database"
        "github.com/asragi/RinGo/infrastructure"
        _ "github.com/go-sql-driver/mysql"
        "strconv"
        "time"
)

type (
        reqInterface[S any, T any] interface {
                Create(S) *T
        }
        userReq struct {
                UserId core.UserId `db:"user_id"`
        }
        exploreReq struct {
                ExploreId game.ActionId `db:"explore_id"`
        }
        stageReq struct {
                StageId explore.StageId `db:"stage_id"`
        }
        itemReq struct {
                ItemId core.ItemId `db:"item_id"`
        }
        skillReq struct {
                SkillId core.SkillId `db:"skill_id"`
        }
)

func (exploreReq) Create(v game.ActionId) *exploreReq <span class="cov0" title="0">{
        return &amp;exploreReq{ExploreId: v}
}</span>

func (stageReq) Create(v explore.StageId) *stageReq <span class="cov8" title="1">{
        return &amp;stageReq{StageId: v}
}</span>

func (itemReq) Create(v core.ItemId) *itemReq <span class="cov8" title="1">{
        return &amp;itemReq{ItemId: v}
}</span>

func (skillReq) Create(v core.SkillId) *skillReq <span class="cov0" title="0">{
        return &amp;skillReq{SkillId: v}
}</span>

func CreateCheckUserExistence(queryFunc database.QueryFunc) core.CheckDoesUserExist <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov8" title="1">{
                        return fmt.Errorf("check user existence: %w", err)
                }</span>
                <span class="cov8" title="1">queryString := fmt.Sprintf(`SELECT user_id from ringo.users WHERE user_id = "%s";`, userId)
                rows, err := queryFunc(ctx, queryString, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                if rows.Next() </span><span class="cov8" title="1">{
                        return handleError(fmt.Errorf(`user-id "%s" already exists: %w`, userId, auth.UserAlreadyExistsError))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateGetUserPassword(queryFunc database.QueryFunc) auth.FetchHashedPassword <span class="cov8" title="1">{
        type dbResponse struct {
                HashedPassword auth.HashedPassword `db:"hashed_password"`
        }
        return func(ctx context.Context, id core.UserId) (auth.HashedPassword, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (auth.HashedPassword, error) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("get hashed password: %w", err)
                }</span>
                <span class="cov8" title="1">queryString := fmt.Sprintf(`SELECT hashed_password FROM ringo.users WHERE user_id = "%s";`, id)
                rows, err := queryFunc(ctx, queryString, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result dbResponse
                if !rows.Next() </span><span class="cov0" title="0">{
                        return handleError(sql.ErrNoRows)
                }</span>
                <span class="cov8" title="1">err = rows.StructScan(&amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return result.HashedPassword, nil</span>
        }
}

func CreateInsertNewUser(
        dbExec database.ExecFunc,
        initialFund core.Fund,
        initialMaxStamina core.MaxStamina,
        initialPopularity shelf.ShopPopularity,
        getTime core.GetCurrentTimeFunc,
) auth.InsertNewUser <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                id core.UserId,
                userName core.Name,
                shopName core.Name,
                password auth.HashedPassword,
        ) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert new user: %w", err)
                }</span>
                <span class="cov8" title="1">queryText := `INSERT INTO ringo.users (user_id, name, shop_name,  fund, max_stamina, stamina_recover_time, hashed_password, popularity) VALUES (:user_id, :name, :shop_name, :fund, :max_stamina, :stamina_recover_time, :hashed_password, :popularity);`

                type UserToDB struct {
                        UserId             core.UserId          `db:"user_id"`
                        Name               core.Name            `db:"name"`
                        ShopName           core.Name            `db:"shop_name"`
                        Fund               core.Fund            `db:"fund"`
                        MaxStamina         core.MaxStamina      `db:"max_stamina"`
                        StaminaRecoverTime time.Time            `db:"stamina_recover_time"`
                        HashedPassword     auth.HashedPassword  `db:"hashed_password"`
                        Popularity         shelf.ShopPopularity `db:"popularity"`
                }

                createUserData := UserToDB{
                        UserId:             id,
                        Name:               userName,
                        ShopName:           shopName,
                        Fund:               initialFund,
                        MaxStamina:         initialMaxStamina,
                        StaminaRecoverTime: getTime(),
                        HashedPassword:     password,
                        Popularity:         initialPopularity,
                }

                _, err := dbExec(ctx, queryText, []*UserToDB{&amp;createUserData})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateGetResourceMySQL(q database.QueryFunc) game.GetResourceFunc <span class="cov8" title="1">{
        type responseStruct struct {
                UserId             core.UserId     `db:"user_id"`
                MaxStamina         core.MaxStamina `db:"max_stamina"`
                StaminaRecoverTime time.Time       `db:"stamina_recover_time"`
                Fund               core.Fund       `db:"fund"`
        }

        return func(ctx context.Context, userId core.UserId) (*game.GetResourceRes, error) </span><span class="cov8" title="1">{
                handleError := func(err error) (*game.GetResourceRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("get resource from mysql: %w", err)
                }</span>
                <span class="cov8" title="1">rows, err := q(
                        ctx,
                        fmt.Sprintf(
                                `SELECT user_id, max_stamina, stamina_recover_time, fund FROM ringo.users WHERE user_id = "%s";`,
                                userId,
                        ),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result responseStruct
                if !rows.Next() </span><span class="cov0" title="0">{
                        return nil, sql.ErrNoRows
                }</span>
                <span class="cov8" title="1">err = rows.StructScan(&amp;result)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return &amp;game.GetResourceRes{
                        UserId:             result.UserId,
                        MaxStamina:         result.MaxStamina,
                        StaminaRecoverTime: core.StaminaRecoverTime(result.StaminaRecoverTime),
                        Fund:               result.Fund,
                }, err</span>
        }
}

func CreateFetchFund(q database.QueryFunc) game.FetchFundFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userIds []core.UserId) ([]*game.FundRes, error) </span><span class="cov0" title="0">{
                handleError := func(err error) ([]*game.FundRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch fund from mysql: %w", err)
                }</span>
                <span class="cov0" title="0">spreadUserId := spreadString(infrastructure.UserIdsToString(userIds))
                query := fmt.Sprintf(
                        `SELECT user_id, fund FROM ringo.users WHERE user_id IN (%s);`,
                        spreadUserId,
                )
                rows, err := q(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                var result []*game.FundRes
                for rows.Next() </span><span class="cov0" title="0">{
                        var res game.FundRes
                        err = rows.Scan(&amp;res.UserId, &amp;res.Fund)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov0" title="0">result = append(result, &amp;res)</span>
                }
                <span class="cov0" title="0">return result, nil</span>
        }
}

func CreateFetchStamina(q database.QueryFunc) game.FetchStaminaFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userIds []core.UserId) ([]*game.StaminaRes, error) </span><span class="cov0" title="0">{
                handleError := func(err error) ([]*game.StaminaRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch stamina from mysql: %w", err)
                }</span>
                <span class="cov0" title="0">spreadUserId := spreadString(infrastructure.UserIdsToString(userIds))
                query := fmt.Sprintf(
                        `SELECT user_id, max_stamina, stamina_recover_time FROM ringo.users WHERE user_id IN (%s);`,
                        spreadUserId,
                )
                rows, err := q(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                var result []*game.StaminaRes
                for rows.Next() </span><span class="cov0" title="0">{
                        var res game.StaminaRes
                        err = rows.Scan(&amp;res.UserId, &amp;res.MaxStamina, &amp;res.StaminaRecoverTime)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov0" title="0">result = append(result, &amp;res)</span>
                }
                <span class="cov0" title="0">return result, nil</span>
        }
}

func CreateUpdateStamina(execDb database.ExecFunc) game.UpdateStaminaFunc <span class="cov8" title="1">{
        type updateStaminaReq struct {
                StaminaRecoverTime time.Time `db:"stamina_recover_time"`
        }
        query := func(userId core.UserId) string </span><span class="cov8" title="1">{
                return fmt.Sprintf(
                        `UPDATE ringo.users SET stamina_recover_time = :stamina_recover_time WHERE user_id = "%s";`,
                        userId,
                )
        }</span>
        <span class="cov8" title="1">return func(ctx context.Context, userId core.UserId, recoverTime core.StaminaRecoverTime) error </span><span class="cov8" title="1">{
                return CreateExec[updateStaminaReq](
                        execDb,
                        "update stamina: %w",
                        query(userId),
                )(ctx, []*updateStaminaReq{{StaminaRecoverTime: time.Time(recoverTime)}})
        }</span>
}

func CreateGetItemMasterMySQL(q database.QueryFunc) game.FetchItemMasterFunc <span class="cov8" title="1">{
        return CreateGetQueryFromReq[core.ItemId, itemReq, game.GetItemMasterRes](
                q,
                "get item master from mysql: %w",
                "SELECT item_id, price, display_name, description, max_stock from ringo.item_masters WHERE item_id IN (:item_id);",
        )
}</span>

func CreateGetStageMaster(q database.QueryFunc) explore.FetchStageMasterFunc <span class="cov8" title="1">{
        return CreateGetQueryFromReq[explore.StageId, stageReq, explore.StageMaster](
                q,
                "get stage master: %w",
                "SELECT stage_id, display_name, description from ringo.stage_masters WHERE stage_id IN (:stage_id);",
        )
}</span>

func CreateGetAllStageMaster(q database.QueryFunc) explore.FetchAllStageFunc <span class="cov8" title="1">{
        f := func(ctx context.Context) ([]*explore.StageMaster, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*explore.StageMaster, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("get all stage master from mysql: %w", err)
                }</span>
                <span class="cov8" title="1">query := "SELECT stage_id, display_name, description from ringo.stage_masters;"
                rows, err := q(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*explore.StageMaster
                for rows.Next() </span><span class="cov8" title="1">{
                        var res explore.StageMaster
                        err = rows.Scan(&amp;res.StageId, &amp;res.DisplayName, &amp;res.Description)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov8" title="1">result = append(result, &amp;res)</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">return f</span>
}

func CreateGetQueryFromReq[S any, SReq reqInterface[S, SReq], T any](
        q database.QueryFunc,
        errorMessageFormat string,
        queryText string,
) func(context.Context, []S) ([]*T, error) <span class="cov8" title="1">{
        f := CreateGetQuery[SReq, T](q, errorMessageFormat, queryText)
        return func(ctx context.Context, s []S) ([]*T, error) </span><span class="cov8" title="1">{
                req := func(s []S) []*SReq </span><span class="cov8" title="1">{
                        result := make([]*SReq, len(s))
                        for i, v := range s </span><span class="cov8" title="1">{
                                var tmp SReq
                                result[i] = tmp.Create(v)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(s)
                <span class="cov8" title="1">return f(ctx, req)</span>
        }
}

func CreateGetExploreMasterMySQL(q database.QueryFunc) game.FetchExploreMasterFunc <span class="cov8" title="1">{
        f := CreateGetQuery[exploreReq, game.GetExploreMasterRes](
                q,
                "get explore master from mysql: %w",
                "SELECT explore_id, display_name, description, consuming_stamina, required_payment, stamina_reducible_rate from ringo.explore_masters WHERE explore_id IN (:explore_id);",
        )

        return func(ctx context.Context, ids []game.ActionId) ([]*game.GetExploreMasterRes, error) </span><span class="cov8" title="1">{
                req := func(ids []game.ActionId) []*exploreReq </span><span class="cov8" title="1">{
                        result := make([]*exploreReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;exploreReq{ExploreId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">return f(ctx, req)</span>
        }
}

func CreateGetSkillMaster(q database.QueryFunc) game.FetchSkillMasterFunc <span class="cov8" title="1">{
        f := CreateGetQuery[skillReq, game.SkillMaster](
                q,
                "get skill master from mysql: %w",
                "SELECT skill_id, display_name from ringo.skill_masters WHERE skill_id IN (:skill_id);",
        )
        return func(ctx context.Context, ids []core.SkillId) ([]*game.SkillMaster, error) </span><span class="cov8" title="1">{
                req := func(ids []core.SkillId) []*skillReq </span><span class="cov8" title="1">{
                        result := make([]*skillReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;skillReq{SkillId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">res, err := f(ctx, req)
                return res, err</span>
        }
}

func CreateGetEarningItem(q database.QueryFunc) game.FetchEarningItemFunc <span class="cov8" title="1">{
        f := CreateGetQuery[exploreReq, game.EarningItem](
                q,
                "get earning item data from mysql: %w",
                "SELECT item_id, min_count, max_count, probability from ringo.earning_items WHERE explore_id IN (:explore_id);",
        )

        return func(ctx context.Context, id game.ActionId) ([]*game.EarningItem, error) </span><span class="cov8" title="1">{
                req := &amp;exploreReq{ExploreId: id}
                return f(ctx, []*exploreReq{req})
        }</span>
}

func CreateGetConsumingItem(q database.QueryFunc) game.FetchConsumingItemFunc <span class="cov8" title="1">{
        f := CreateGetQuery[exploreReq, game.ConsumingItem](
                q,
                "get consuming item data from mysql: %w",
                "SELECT explore_id, item_id, max_count, consumption_prob from ringo.consuming_items WHERE explore_id IN (:explore_id)",
        )

        return func(ctx context.Context, ids []game.ActionId) ([]*game.ConsumingItem, error) </span><span class="cov8" title="1">{
                req := func(ids []game.ActionId) []*exploreReq </span><span class="cov8" title="1">{
                        result := make([]*exploreReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;exploreReq{ExploreId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">return f(ctx, req)</span>
        }
}

func CreateGetRequiredSkills(q database.QueryFunc) game.FetchRequiredSkillsFunc <span class="cov8" title="1">{
        f := CreateGetQuery[exploreReq, game.RequiredSkill](
                q,
                "get required skill from mysql :%w",
                "SELECT explore_id, skill_id, skill_lv from ringo.required_skills WHERE explore_id IN (:explore_id)",
        )
        return func(ctx context.Context, ids []game.ActionId) ([]*game.RequiredSkill, error) </span><span class="cov8" title="1">{
                req := func(ids []game.ActionId) []*exploreReq </span><span class="cov8" title="1">{
                        result := make([]*exploreReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;exploreReq{ExploreId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">return f(ctx, req)</span>
        }
}

func CreateGetSkillGrowth(q database.QueryFunc) game.FetchSkillGrowthData <span class="cov8" title="1">{
        f := CreateGetQuery[exploreReq, game.SkillGrowthData](
                q,
                "get skill growth from mysql: %w",
                `SELECT explore_id, skill_id, gaining_point FROM ringo.skill_growth_data WHERE explore_id IN (:explore_id);`,
        )

        return func(ctx context.Context, id game.ActionId) ([]*game.SkillGrowthData, error) </span><span class="cov8" title="1">{
                req := &amp;exploreReq{ExploreId: id}
                return f(ctx, []*exploreReq{req})
        }</span>
}

func CreateGetReductionSkill(q database.QueryFunc) game.FetchReductionStaminaSkillFunc <span class="cov8" title="1">{
        f := CreateGetQuery[exploreReq, game.StaminaReductionSkillPair](
                q,
                "get stamina reduction skill from mysql: %w",
                `SELECT explore_id, skill_id FROM ringo.stamina_reduction_skills WHERE explore_id IN (:explore_id) ORDER BY id;`,
        )

        return func(ctx context.Context, ids []game.ActionId) ([]*game.StaminaReductionSkillPair, error) </span><span class="cov8" title="1">{
                req := func(ids []game.ActionId) []*exploreReq </span><span class="cov8" title="1">{
                        result := make([]*exploreReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;exploreReq{ExploreId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">return f(ctx, req)</span>
        }
}

func CreateStageExploreRelation(q database.QueryFunc) explore.FetchStageExploreRelation <span class="cov8" title="1">{
        f := CreateGetQuery[stageReq, explore.StageExploreIdPairRow](
                q,
                "get stage explore relation from mysql: %w",
                "SELECT explore_id, stage_id FROM ringo.stage_explore_relations WHERE stage_id IN (:stage_id);",
        )

        return func(ctx context.Context, ids []explore.StageId) ([]*explore.StageExploreIdPairRow, error) </span><span class="cov8" title="1">{
                req := func(ids []explore.StageId) []*stageReq </span><span class="cov8" title="1">{
                        result := make([]*stageReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;stageReq{StageId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">return f(ctx, req)</span>
        }
}

func CreateItemExploreRelation(q database.QueryFunc) explore.FetchItemExploreRelationFunc <span class="cov8" title="1">{
        type fetchExploreIdRes struct {
                ExploreId game.ActionId `db:"explore_id"`
        }
        f := CreateGetQuery[itemReq, fetchExploreIdRes](
                q,
                "get item explore relation from mysql: %w",
                "SELECT explore_id FROM ringo.item_explore_relations WHERE item_id IN (:item_id);",
        )

        return func(ctx context.Context, id core.ItemId) ([]game.ActionId, error) </span><span class="cov8" title="1">{
                req := &amp;itemReq{ItemId: id}
                res, err := f(ctx, []*itemReq{req})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result := make([]game.ActionId, len(res))
                for i, v := range res </span><span class="cov8" title="1">{
                        result[i] = v.ExploreId
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }
}

func CreateGetUserExplore(q database.QueryFunc) game.GetUserExploreFunc <span class="cov8" title="1">{
        type exploreRes struct {
                ExploreId game.ActionId `db:"explore_id"`
                IsKnown   int           `db:"is_known"`
        }
        f := CreateUserQuery[exploreReq, exploreRes](
                q,
                "get user explore data: %w",
                createQueryFromUserId(`SELECT explore_id, is_known FROM ringo.user_explore_data WHERE user_id = "%s" AND explore_id IN (:explore_id);`),
        )

        return func(ctx context.Context, id core.UserId, ids []game.ActionId) ([]*game.ExploreUserData, error) </span><span class="cov8" title="1">{
                req := func(ids []game.ActionId) []*exploreReq </span><span class="cov8" title="1">{
                        result := make([]*exploreReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;exploreReq{ExploreId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">res, err := f(ctx, id, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return func() []*game.ExploreUserData </span><span class="cov8" title="1">{
                        result := make([]*game.ExploreUserData, len(res))
                        for i, v := range res </span><span class="cov8" title="1">{
                                result[i] = &amp;game.ExploreUserData{
                                        ExploreId: v.ExploreId,
                                        IsKnown:   core.ToIsKnown(v.IsKnown),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(), nil
        }
}

func CreateGetUserStageData(queryFunc database.QueryFunc) explore.FetchUserStageFunc <span class="cov8" title="1">{
        type userStageRes struct {
                StageId explore.StageId `db:"stage_id"`
                IsKnown int             `db:"is_known"`
        }
        f := CreateUserQuery[stageReq, userStageRes](
                queryFunc,
                "get user stage data: %w",
                createQueryFromUserId(`SELECT stage_id, is_known FROM ringo.user_stage_data WHERE user_id = '%s' AND stage_id IN (:stage_id);`),
        )

        return func(ctx context.Context, id core.UserId, ids []explore.StageId) ([]*explore.UserStage, error) </span><span class="cov8" title="1">{
                req := func(ids []explore.StageId) []*stageReq </span><span class="cov8" title="1">{
                        result := make([]*stageReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;stageReq{StageId: v}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(ids)
                <span class="cov8" title="1">res, err := f(ctx, id, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return func() []*explore.UserStage </span><span class="cov8" title="1">{
                        result := make([]*explore.UserStage, len(res))
                        for i, v := range res </span><span class="cov8" title="1">{
                                result[i] = &amp;explore.UserStage{
                                        StageId: v.StageId,
                                        IsKnown: core.ToIsKnown(v.IsKnown),
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(), nil
        }
}

func CreateUpdateFund(dbExec database.ExecFunc) game.UpdateFundFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userFundPair []*game.UserFundPair) error </span><span class="cov8" title="1">{
                userIds, fundIds := game.FundPairToUserId(userFundPair)
                userIdsToString := func(userIds []core.UserId) []string </span><span class="cov8" title="1">{
                        result := make([]string, len(userIds))
                        for i, v := range userIds </span><span class="cov8" title="1">{
                                result[i] = fmt.Sprintf(`"%s"`, v)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(userIds)
                <span class="cov8" title="1">spreadUserId := spreadString(userIdsToString)
                fundIdsToString := func(fundIds []core.Fund) []string </span><span class="cov8" title="1">{
                        result := make([]string, len(fundIds))
                        for i, v := range fundIds </span><span class="cov8" title="1">{
                                result[i] = strconv.Itoa(int(v))
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(fundIds)
                <span class="cov8" title="1">spreadFund := spreadString(fundIdsToString)
                query := fmt.Sprintf(
                        `UPDATE ringo.users SET fund = ELT(FIELD(user_id,%s),%s)        WHERE user_id IN (%s)`,
                        spreadUserId, spreadFund, spreadUserId,
                )
                _, err := dbExec(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update fund: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateGetStorage(queryF database.QueryFunc) game.FetchStorageFunc <span class="cov8" title="1">{
        type ItemDataRes struct {
                UserId core.UserId `db:"user_id"`
                ItemId core.ItemId `db:"item_id"`
                Stock  core.Stock  `db:"stock"`
        }
        g := func(
                ctx context.Context,
                userItemPair []*game.UserItemPair,
        ) ([]*ItemDataRes, error) </span><span class="cov8" title="1">{
                toInKeywords := func(userItemPair []*game.UserItemPair) string </span><span class="cov8" title="1">{
                        result := "("
                        for i, v := range userItemPair </span><span class="cov8" title="1">{
                                result += fmt.Sprintf(`("%s", "%s")`, v.UserId, v.ItemId)
                                if i != len(userItemPair)-1 </span><span class="cov8" title="1">{
                                        result += ", "
                                }</span>
                        }
                        <span class="cov8" title="1">result += ")"
                        return result</span>
                }(userItemPair)
                <span class="cov8" title="1">query := fmt.Sprintf(
                        `SELECT user_id, item_id, stock FROM ringo.item_storages WHERE (user_id, item_id) IN %s;`,
                        toInKeywords,
                )
                rows, err := queryF(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*ItemDataRes
                for rows.Next() </span><span class="cov8" title="1">{
                        var row ItemDataRes
                        err = rows.StructScan(&amp;row)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">result = append(result, &amp;row)</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }
        <span class="cov8" title="1">return func(ctx context.Context, userItemPair []*game.UserItemPair) ([]*game.BatchGetStorageRes, error) </span><span class="cov8" title="1">{
                if len(userItemPair) &lt;= 0 </span><span class="cov0" title="0">{
                        return []*game.BatchGetStorageRes{}, nil
                }</span>
                <span class="cov8" title="1">res, err := g(ctx, userItemPair)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return func() []*game.BatchGetStorageRes </span><span class="cov8" title="1">{
                        resToMap := func() map[core.UserId][]*game.StorageData </span><span class="cov8" title="1">{
                                var mapping = map[core.UserId][]*game.StorageData{}
                                for _, v := range res </span><span class="cov8" title="1">{
                                        if _, ok := mapping[v.UserId]; !ok </span><span class="cov8" title="1">{
                                                mapping[v.UserId] = []*game.StorageData{}
                                        }</span>
                                        <span class="cov8" title="1">mapping[v.UserId] = append(
                                                mapping[v.UserId], &amp;game.StorageData{
                                                        UserId:  v.UserId,
                                                        ItemId:  v.ItemId,
                                                        Stock:   v.Stock,
                                                        IsKnown: true,
                                                },
                                        )</span>
                                }
                                <span class="cov8" title="1">return mapping</span>
                        }()
                        <span class="cov8" title="1">for _, v := range userItemPair </span><span class="cov8" title="1">{
                                if _, ok := resToMap[v.UserId]; ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">resToMap[v.UserId] = append(
                                        resToMap[v.UserId], &amp;game.StorageData{
                                                UserId:  v.UserId,
                                                ItemId:  v.ItemId,
                                                Stock:   0,
                                                IsKnown: false,
                                        },
                                )</span>
                        }
                        <span class="cov8" title="1">allUserIds := func() []core.UserId </span><span class="cov8" title="1">{
                                check := map[core.UserId]struct{}{}
                                var result []core.UserId
                                for _, v := range res </span><span class="cov8" title="1">{
                                        if _, ok := check[v.UserId]; ok </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">check[v.UserId] = struct{}{}
                                        result = append(result, v.UserId)</span>
                                }
                                <span class="cov8" title="1">return result</span>
                        }()
                        <span class="cov8" title="1">result := make([]*game.BatchGetStorageRes, len(allUserIds))
                        for i, v := range allUserIds </span><span class="cov8" title="1">{
                                result[i] = &amp;game.BatchGetStorageRes{
                                        UserId:   v,
                                        ItemData: resToMap[v],
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(), nil
        }
}

func CreateGetAllStorage(queryFunc database.QueryFunc) game.FetchAllStorageFunc <span class="cov8" title="1">{
        type resStruct struct {
                UserId  core.UserId `db:"user_id"`
                ItemId  core.ItemId `db:"item_id"`
                Stock   core.Stock  `db:"stock"`
                IsKnown int         `db:"is_known"`
        }
        return func(ctx context.Context, userId core.UserId) ([]*game.StorageData, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*game.StorageData, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("get all storage from mysql: %w", err)
                }</span>
                <span class="cov8" title="1">query := fmt.Sprintf(
                        `SELECT user_id, item_id, stock, is_known from ringo.item_storages WHERE user_id = "%s";`,
                        userId,
                )
                rows, err := queryFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*resStruct
                for rows.Next() </span><span class="cov8" title="1">{
                        var res resStruct
                        err = rows.Scan(&amp;res.UserId, &amp;res.ItemId, &amp;res.Stock, &amp;res.IsKnown)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov8" title="1">result = append(result, &amp;res)</span>
                }
                <span class="cov8" title="1">if result == nil || len(result) == 0 </span><span class="cov0" title="0">{
                        return []*game.StorageData{}, sql.ErrNoRows
                }</span>
                <span class="cov8" title="1">return func() []*game.StorageData </span><span class="cov8" title="1">{
                        tmp := make([]*game.StorageData, len(result))
                        for i, v := range result </span><span class="cov8" title="1">{
                                tmp[i] = &amp;game.StorageData{
                                        UserId:  v.UserId,
                                        ItemId:  v.ItemId,
                                        Stock:   v.Stock,
                                        IsKnown: core.ToIsKnown(v.IsKnown),
                                }
                        }</span>
                        <span class="cov8" title="1">return tmp</span>
                }(), nil
        }
}

func CreateUpdateItemStorage(dbExec database.ExecFunc) game.UpdateItemStorageFunc <span class="cov8" title="1">{
        return func(ctx context.Context, data []*game.StorageData) error </span><span class="cov8" title="1">{
                baseQuery := `INSERT INTO ringo.item_storages (user_id, item_id, stock, is_known) VALUES %s ON DUPLICATE KEY UPDATE stock = VALUES(stock);`
                dataString := func(data []*game.StorageData) []string </span><span class="cov8" title="1">{
                        result := make([]string, len(data))
                        for i, v := range data </span><span class="cov8" title="1">{
                                result[i] = fmt.Sprintf(`("%s", "%s", %d, %t)`, v.UserId, v.ItemId, v.Stock, v.IsKnown)
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(data)
                <span class="cov8" title="1">query := fmt.Sprintf(baseQuery, spreadString(dataString))
                _, err := dbExec(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update item storage: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateGetUserSkill(dbExec database.QueryFunc) game.FetchUserSkillFunc <span class="cov8" title="1">{
        type skillReq struct {
                SkillId string `db:"skill_id"`
        }
        queryFromUserId := createQueryFromUserId(
                `SELECT user_id, skill_id, skill_exp FROM ringo.user_skills WHERE user_id = "%s" AND skill_id IN (:skill_id);`,
        )
        g := CreateUserQuery[skillReq, game.UserSkillRes](
                dbExec,
                "get user skill data :%w",
                queryFromUserId,
        )
        f := func(ctx context.Context, userId core.UserId, skillIds []core.SkillId) (game.BatchGetUserSkillRes, error) </span><span class="cov8" title="1">{
                skillReqStructs := func(ids []core.SkillId) []*skillReq </span><span class="cov8" title="1">{
                        result := make([]*skillReq, len(ids))
                        for i, v := range ids </span><span class="cov8" title="1">{
                                result[i] = &amp;skillReq{SkillId: v.ToString()}
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }(skillIds)
                <span class="cov8" title="1">res, err := g(ctx, userId, skillReqStructs)
                if err != nil </span><span class="cov0" title="0">{
                        return game.BatchGetUserSkillRes{}, err
                }</span>
                <span class="cov8" title="1">return game.BatchGetUserSkillRes{
                        Skills: res,
                        UserId: userId,
                }, nil</span>
        }
        <span class="cov8" title="1">return f</span>
}

func CreateUpdateUserSkill(dbExec database.ExecFunc) game.UpdateUserSkillExpFunc <span class="cov8" title="1">{
        g := CreateExec[game.SkillGrowthPostRow]
        f := func(ctx context.Context, growthData game.SkillGrowthPost) error </span><span class="cov8" title="1">{
                query := `INSERT INTO ringo.user_skills (user_id, skill_id, skill_exp) VALUES (:user_id, :skill_id, :skill_exp) ON DUPLICATE KEY UPDATE skill_exp =VALUES(skill_exp);`

                return g(
                        dbExec,
                        "update skill growth: %w",
                        query,
                )(
                        ctx,
                        growthData.SkillGrowth,
                )
        }</span>

        <span class="cov8" title="1">return f</span>
}

func CreateGetQuery[S any, T any](
        queryFunc database.QueryFunc,
        errorMessageFormat string,
        queryText string,
) func(context.Context, []*S) ([]*T, error) <span class="cov8" title="1">{
        f := func(ctx context.Context, ids []*S) ([]*T, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*T, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(errorMessageFormat, err)
                }</span>
                <span class="cov8" title="1">if len(ids) &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">rows, err := queryFunc(ctx, queryText, ids)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*T
                for rows.Next() </span><span class="cov8" title="1">{
                        var row T
                        err = rows.StructScan(&amp;row)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov8" title="1">result = append(result, &amp;row)</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }
        <span class="cov8" title="1">return f</span>
}

func createQueryFromUserId(queryText string) func(core.UserId) string <span class="cov8" title="1">{
        return func(userId core.UserId) string </span><span class="cov8" title="1">{
                return fmt.Sprintf(queryText, userId)
        }</span>
}

func CreateUserQuery[S any, T any](
        queryFunc database.QueryFunc,
        errorMessageFormat string,
        queryTextFromUserId func(core.UserId) string,
) func(context.Context, core.UserId, []*S) ([]*T, error) <span class="cov8" title="1">{
        f := func(ctx context.Context, userId core.UserId, ids []*S) ([]*T, error) </span><span class="cov8" title="1">{
                handleError := func(err error) ([]*T, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf(errorMessageFormat, err)
                }</span>
                <span class="cov8" title="1">if len(ids) &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">queryText := queryTextFromUserId(userId)
                rows, err := queryFunc(ctx, queryText, ids)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*T
                for rows.Next() </span><span class="cov8" title="1">{
                        var row T
                        err = rows.StructScan(&amp;row)
                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov8" title="1">result = append(result, &amp;row)</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }
        <span class="cov8" title="1">return f</span>
}

func CreateExec[S any](
        dbExec database.ExecFunc,
        errorMessageFormat string,
        query string,
) func(context.Context, []*S) error <span class="cov8" title="1">{
        return func(ctx context.Context, data []*S) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf(errorMessageFormat, err)
                }</span>
                <span class="cov8" title="1">if data == nil || len(data) &lt;= 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">_, err := dbExec(ctx, query, data)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func spreadString(s []string) string <span class="cov8" title="1">{
        result := ""
        for i, v := range s </span><span class="cov8" title="1">{
                result += v
                if i != len(s)-1 </span><span class="cov8" title="1">{
                        result += ", "
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package mysql

import (
        "context"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf/ranking"
        "github.com/asragi/RinGo/database"
        "github.com/asragi/RinGo/infrastructure"
)

func CreateFetchDailyRanking(queryFunc database.QueryFunc) ranking.FetchUserDailyRankingRepo <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                limit core.Limit,
                offset core.Offset,
                latestPeriod ranking.RankPeriod,
        ) ([]*ranking.UserDailyRankingRes, error) </span><span class="cov0" title="0">{
                handleError := func(err error) ([]*ranking.UserDailyRankingRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch daily ranking: %w", err)
                }</span>
                <span class="cov0" title="0">query := fmt.Sprintf(
                        `SELECT user_id FROM ringo.scores WHERE rank_period = %d ORDER BY total_score DESC LIMIT %d OFFSET %d`,
                        latestPeriod.ToInt(),
                        limit,
                        offset,
                )
                rows, err := queryFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                var res []*ranking.UserDailyRankingRes
                rankIndex := 1
                for rows.Next() </span><span class="cov0" title="0">{
                        var userId core.UserId
                        if err := rows.Scan(&amp;userId); err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov0" title="0">res = append(
                                res, &amp;ranking.UserDailyRankingRes{
                                        UserId: userId,
                                        Rank:   ranking.Rank(int(offset) + rankIndex),
                                },
                        )
                        rankIndex += 1</span>
                }
                <span class="cov0" title="0">return res, nil</span>
        }
}

func CreateFetchLatestRankPeriod(queryFunc database.QueryFunc) ranking.FetchLatestRankPeriod <span class="cov0" title="0">{
        return func(ctx context.Context) (ranking.RankPeriod, error) </span><span class="cov0" title="0">{
                handleError := func(err error) (ranking.RankPeriod, error) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("fetch latest rank period: %w", err)
                }</span>
                <span class="cov0" title="0">query := `SELECT rank_period FROM ringo.rank_period_table ORDER BY rank_period DESC LIMIT 1`
                rows, err := queryFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                var latestPeriod ranking.RankPeriod
                if rows.Next() </span><span class="cov0" title="0">{
                        if err := rows.Scan(&amp;latestPeriod); err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                }
                <span class="cov0" title="0">return latestPeriod, nil</span>
        }
}

func CreateInsertRankPeriod(exec database.ExecFunc) ranking.InsertRankPeriodRepo <span class="cov8" title="1">{
        return func(ctx context.Context, period ranking.RankPeriod) error </span><span class="cov8" title="1">{
                type req struct {
                        RankPeriod ranking.RankPeriod `db:"rank_period"`
                }
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert rank period: %w", err)
                }</span>
                <span class="cov8" title="1">query := `INSERT INTO ringo.rank_period_table (rank_period) VALUES (:rank_period)`
                _, err := exec(ctx, query, &amp;req{RankPeriod: period})
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateFetchWinRepo(queryFunc database.QueryFunc) ranking.FetchWinRepo <span class="cov0" title="0">{
        return func(ctx context.Context, userIds []core.UserId) ([]*ranking.FetchWinRes, error) </span><span class="cov0" title="0">{
                handleError := func(err error) ([]*ranking.FetchWinRes, error) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch win: %w", err)
                }</span>
                <span class="cov0" title="0">userIdString := infrastructure.UserIdsToString(userIds)
                userIdSpread := spreadString(userIdString)
                query := fmt.Sprintf(`SELECT user_id, win_count FROM ringo.win_count WHERE user_id IN (%s)`, userIdSpread)
                rows, err := queryFunc(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                var res []*ranking.FetchWinRes
                for rows.Next() </span><span class="cov0" title="0">{
                        var r ranking.FetchWinRes
                        if err := rows.Scan(&amp;r.UserId, &amp;r.WinCount); err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>
                        <span class="cov0" title="0">res = append(res, &amp;r)</span>
                }
                <span class="cov0" title="0">return res, nil</span>
        }
}

func CreateInsertWin(exec database.ExecFunc) ranking.InsertWinRepo <span class="cov8" title="1">{
        return func(ctx context.Context, reqs []*ranking.InsertWinReq) error </span><span class="cov8" title="1">{
                handleError := func(err error) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert win: %w", err)
                }</span>
                <span class="cov8" title="1">query := `INSERT INTO ringo.winners (user_id, win_rank, rank_period) VALUES (:user_id, :win_rank, :rank_period)`
                _, err := exec(ctx, query, reqs)
                if err != nil </span><span class="cov0" title="0">{
                        return handleError(err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package mysql

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/reservation"
        "github.com/asragi/RinGo/database"
        "github.com/asragi/RinGo/infrastructure"
        "github.com/asragi/RinGo/location"
        "github.com/asragi/RinGo/utils"
        "time"
)

func CreateInsertReservation(dbExec database.ExecFunc) reservation.InsertReservationRepoFunc <span class="cov0" title="0">{
        return CreateExec[reservation.ReservationRow](
                dbExec,
                "insert reservation: %w",
                "INSERT INTO ringo.reservations (reservation_id, user_id, shelf_index, scheduled_time, purchase_num) VALUES (:reservation_id, :user_id, :shelf_index, :scheduled_time, :purchase_num)",
        )
}</span>

func CreateFetchReservation(queryFunc database.QueryFunc) reservation.FetchReservationRepoFunc <span class="cov8" title="1">{
        return func(ctx context.Context, users []core.UserId, from time.Time, to time.Time) (
                []*reservation.ReservationRow,
                error,
        ) </span><span class="cov8" title="1">{
                layout := "2006-01-02 15:04:05"
                userIdStrings := infrastructure.UserIdsToString(users)
                spreadUserIdStrings := spreadString(userIdStrings)
                fromInUTC := from.In(location.UTC())
                toInUTC := to.In(location.UTC())
                fromString := fromInUTC.Format(layout)
                toString := toInUTC.Format(layout)

                rows, err := queryFunc(
                        ctx,
                        fmt.Sprintf(
                                `SELECT reservation_id, user_id, shelf_index, scheduled_time, purchase_num FROM ringo.reservations WHERE user_id IN (%s) AND scheduled_time BETWEEN "%s" AND "%s"`,
                                spreadUserIdStrings,
                                fromString,
                                toString,
                        ),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch reservation: %w", err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*reservation.ReservationRow
                for rows.Next() </span><span class="cov8" title="1">{
                        var row reservation.ReservationRow
                        if err := rows.StructScan(&amp;row); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("fetch reservation: %w", err)
                        }</span>
                        <span class="cov8" title="1">result = append(result, &amp;row)</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }
}

func CreateFetchCheckedTime(queryFunc database.QueryFunc) reservation.FetchCheckedTimeFunc <span class="cov8" title="1">{
        return func(ctx context.Context, shelves []shelf.Id) ([]*reservation.CheckedTimePair, error) </span><span class="cov8" title="1">{
                shelfIds := func() []string </span><span class="cov8" title="1">{
                        var ids []string
                        for _, id := range shelves </span><span class="cov8" title="1">{
                                ids = append(ids, fmt.Sprintf(`"%s"`, id))
                        }</span>
                        <span class="cov8" title="1">return ids</span>
                }()
                <span class="cov8" title="1">idStrings := spreadString(shelfIds)
                rows, err := queryFunc(
                        ctx,
                        fmt.Sprintf("SELECT shelf_id, checked_time FROM ringo.shelves WHERE shelf_id IN (%s)", idStrings),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch checked time: %w", err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var result []*reservation.CheckedTimePair
                for rows.Next() </span><span class="cov8" title="1">{
                        var res reservation.CheckedTimePair
                        var checkedTime sql.NullTime
                        if err := rows.Scan(&amp;res.ShelfId, &amp;checkedTime); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("fetch checked time: %w", err)
                        }</span>
                        <span class="cov8" title="1">res.CheckedTime = reservation.NewCheckedTime(checkedTime.Time, checkedTime.Valid)
                        result = append(result, &amp;res)</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }
}

func CreateUpdateCheckedTime(dbExec database.ExecFunc) reservation.UpdateCheckedTime <span class="cov8" title="1">{
        return func(ctx context.Context, checkedTimePairs []*reservation.UpdateCheckedTimePair) error </span><span class="cov8" title="1">{
                if len(checkedTimePairs) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">checkedTimePairSet := utils.NewSet(checkedTimePairs)
                shelfIds := utils.SetSelect(
                        checkedTimePairSet,
                        func(p *reservation.UpdateCheckedTimePair) string </span><span class="cov8" title="1">{ return fmt.Sprintf(`"%s"`, p.ShelfId.String()) }</span>,
                )
                <span class="cov8" title="1">spreadShelfId := spreadString(shelfIds.ToArray())
                checkedTimeSet := utils.SetSelect(
                        checkedTimePairSet, func(p *reservation.UpdateCheckedTimePair) string </span><span class="cov8" title="1">{
                                return fmt.Sprintf(`"%s"`, p.CheckedTime.Format(time.DateTime))
                        }</span>,
                )
                <span class="cov8" title="1">spreadCheckedTime := spreadString(checkedTimeSet.ToArray())
                queryText := fmt.Sprintf(
                        `UPDATE ringo.shelves SET checked_time = CAST(ELT(FIELD(shelf_id, %s), %s) AS DATETIME) WHERE shelf_id IN (%s)`,
                        spreadShelfId,
                        spreadCheckedTime,
                        spreadShelfId,
                )

                _, err := dbExec(
                        ctx,
                        queryText,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update checked time: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateDeleteReservationToShelf(dbExec database.ExecFunc) reservation.DeleteReservationToShelfRepoFunc <span class="cov8" title="1">{
        return func(ctx context.Context, userId core.UserId, index shelf.Index) error </span><span class="cov8" title="1">{
                _, err := dbExec(
                        ctx,
                        fmt.Sprintf(`DELETE FROM ringo.reservations WHERE user_id = "%s" AND shelf_index = %d`, userId, index),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete reservation to shelf: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateDeleteReservation(dbExec database.ExecFunc) reservation.DeleteReservationRepoFunc <span class="cov8" title="1">{
        return func(ctx context.Context, reservationIds []reservation.Id) error </span><span class="cov8" title="1">{
                ids := func() []string </span><span class="cov8" title="1">{
                        var ids []string
                        for _, id := range reservationIds </span><span class="cov8" title="1">{
                                ids = append(ids, fmt.Sprintf(`"%s"`, id))
                        }</span>
                        <span class="cov8" title="1">return ids</span>
                }()
                <span class="cov8" title="1">idStrings := spreadString(ids)
                _, err := dbExec(
                        ctx,
                        fmt.Sprintf("DELETE FROM ringo.reservations WHERE reservation_id IN (%s);", idStrings),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete reservation: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateFetchItemAttraction(queryFunc database.QueryFunc) reservation.FetchItemAttractionFunc <span class="cov8" title="1">{
        f := CreateGetQuery[itemReq, reservation.ItemAttractionRes](
                queryFunc,
                "fetch item attraction: %w",
                `SELECT item_id, attraction, purchase_probability FROM ringo.item_masters WHERE item_id IN (:item_id)`,
        )
        return func(ctx context.Context, itemIds []core.ItemId) ([]*reservation.ItemAttractionRes, error) </span><span class="cov8" title="1">{
                reqs := make([]*itemReq, len(itemIds))
                for i, id := range itemIds </span><span class="cov8" title="1">{
                        reqs[i] = &amp;itemReq{ItemId: id}
                }</span>
                <span class="cov8" title="1">res, err := f(ctx, reqs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch item attraction: %w", err)
                }</span>
                <span class="cov8" title="1">return res, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package mysql

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/ranking"
        "github.com/asragi/RinGo/database"
        "github.com/asragi/RinGo/infrastructure"
        "github.com/asragi/RinGo/utils"
)

type nullableShelfRow struct {
        Id         shelf.Id          `db:"shelf_id"`
        UserId     core.UserId       `db:"user_id"`
        ItemId     sql.NullString    `db:"item_id"`
        Index      shelf.Index       `db:"shelf_index"`
        SetPrice   shelf.SetPrice    `db:"set_price"`
        TotalSales core.SalesFigures `db:"total_sales"`
}

func (r *nullableShelfRow) toShelfRow() *shelf.ShelfRepoRow <span class="cov8" title="1">{
        itemId := func() core.ItemId </span><span class="cov8" title="1">{
                if !r.ItemId.Valid </span><span class="cov0" title="0">{
                        return core.EmptyItemId
                }</span>
                <span class="cov8" title="1">return core.ItemId(r.ItemId.String)</span>
        }()

        <span class="cov8" title="1">return &amp;shelf.ShelfRepoRow{
                Id:         r.Id,
                UserId:     r.UserId,
                ItemId:     itemId,
                Index:      r.Index,
                SetPrice:   r.SetPrice,
                TotalSales: r.TotalSales,
        }</span>
}

func toNullableShelfRow(shelfRow *shelf.ShelfRepoRow) *nullableShelfRow <span class="cov0" title="0">{
        return &amp;nullableShelfRow{
                Id:         shelfRow.Id,
                UserId:     shelfRow.UserId,
                ItemId:     sql.NullString{String: string(shelfRow.ItemId), Valid: shelfRow.ItemId != core.EmptyItemId},
                Index:      shelfRow.Index,
                SetPrice:   shelfRow.SetPrice,
                TotalSales: shelfRow.TotalSales,
        }
}</span>

func CreateFetchShelfRepo(query database.QueryFunc) shelf.FetchShelf <span class="cov8" title="1">{
        return func(ctx context.Context, userIds []core.UserId) ([]*shelf.ShelfRepoRow, error) </span><span class="cov8" title="1">{
                if len(userIds) == 0 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">userIdStrings := infrastructure.UserIdsToString(userIds)
                spreadUserIdStrings := spreadString(userIdStrings)

                rows, err := query(
                        ctx,
                        fmt.Sprintf(
                                `SELECT shelf_id, user_id, item_id, shelf_index, set_price, total_sales FROM ringo.shelves WHERE user_id IN (%s)`,
                                spreadUserIdStrings,
                        ),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch shelf: %w", err)
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                var response []*nullableShelfRow
                for rows.Next() </span><span class="cov8" title="1">{
                        var row nullableShelfRow
                        if err := rows.StructScan(&amp;row); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("fetch shelf scan: %w", err)
                        }</span>
                        <span class="cov8" title="1">response = append(response, &amp;row)</span>
                }
                <span class="cov8" title="1">result := func() []*shelf.ShelfRepoRow </span><span class="cov8" title="1">{
                        var result []*shelf.ShelfRepoRow
                        for _, row := range response </span><span class="cov8" title="1">{
                                result = append(result, row.toShelfRow())
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">return result, nil</span>
        }
}

func createUpdateShelf(dbExec database.ExecFunc) func(
        context.Context,
        shelf.Id,
        core.ItemId,
        shelf.SetPrice,
        core.SalesFigures,
) error <span class="cov0" title="0">{
        f := CreateExec[nullableShelfRow](
                dbExec,
                "update shelf content: %w",
                "UPDATE ringo.shelves set set_price = :set_price, total_sales = :total_sales, item_id = :item_id WHERE shelf_id = :shelf_id",
        )
        return func(
                ctx context.Context,
                shelfId shelf.Id,
                itemId core.ItemId,
                setPrice shelf.SetPrice,
                totalSales core.SalesFigures,
        ) error </span><span class="cov0" title="0">{
                shelfRow := toNullableShelfRow(
                        &amp;shelf.ShelfRepoRow{
                                Id:         shelfId,
                                ItemId:     itemId,
                                SetPrice:   setPrice,
                                TotalSales: totalSales,
                        },
                )
                return f(
                        ctx, []*nullableShelfRow{shelfRow},
                )
        }</span>
}

func CreateUpdateTotalSales(dbExec database.ExecFunc) shelf.UpdateShelfTotalSalesFunc <span class="cov8" title="1">{
        return func(
                ctx context.Context,
                reqs []*shelf.TotalSalesReq,
        ) error </span><span class="cov8" title="1">{
                shelfIdString, totalSalesString := func() (string, string) </span><span class="cov8" title="1">{
                        var shelfIds, totalSalesData []string
                        for _, r := range reqs </span><span class="cov8" title="1">{
                                shelfIds = append(shelfIds, fmt.Sprintf(`"%s"`, r.Id.String()))
                                totalSalesData = append(totalSalesData, fmt.Sprintf("%d", r.TotalSales))
                        }</span>
                        <span class="cov8" title="1">return spreadString(shelfIds), spreadString(totalSalesData)</span>
                }()
                <span class="cov8" title="1">_, err := dbExec(
                        ctx,
                        fmt.Sprintf(
                                `UPDATE ringo.shelves SET total_sales = ELT(FIELD(shelf_id,%s),%s) WHERE shelf_id IN (%s)`,
                                shelfIdString,
                                totalSalesString,
                                shelfIdString,
                        ),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update total sales: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func CreateUpdateShelfContentRepo(dbExec database.ExecFunc) shelf.UpdateShelfContentRepoFunc <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                shelfId shelf.Id,
                itemId core.ItemId,
                setPrice shelf.SetPrice,
        ) error </span><span class="cov0" title="0">{
                return createUpdateShelf(dbExec)(ctx, shelfId, itemId, setPrice, 0)
        }</span>
}

func CreateInsertEmptyShelf(dbExec database.ExecFunc) shelf.InsertEmptyShelfFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, shelves []*shelf.ShelfRepoRow) error </span><span class="cov0" title="0">{
                shelvesReq := func() []*nullableShelfRow </span><span class="cov0" title="0">{
                        var result []*nullableShelfRow
                        for _, s := range shelves </span><span class="cov0" title="0">{
                                result = append(result, toNullableShelfRow(s))
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }()
                <span class="cov0" title="0">_, err := dbExec(
                        ctx,
                        "INSERT INTO ringo.shelves (shelf_id, user_id, item_id, set_price, total_sales, shelf_index) VALUES (:shelf_id, :user_id, :item_id, :set_price, :total_sales, :shelf_index)",
                        shelvesReq,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert empty shelf: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func CreateDeleteShelfBySize(dbExec database.ExecFunc) shelf.DeleteShelfBySizeFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userId core.UserId, size shelf.Size) error </span><span class="cov0" title="0">{
                _, err := dbExec(
                        ctx,
                        fmt.Sprintf(`DELETE FROM ringo.shelves WHERE user_id = "%s" AND shelf_index &gt;= %d`, userId, size),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete shelf by size: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func CreateFetchScore(q database.QueryFunc) ranking.FetchUserScore <span class="cov0" title="0">{
        return func(
                ctx context.Context,
                userIds []core.UserId,
                rankPeriod ranking.RankPeriod,
        ) ([]*ranking.UserScorePair, error) </span><span class="cov0" title="0">{
                userIdStrings := infrastructure.UserIdsToString(userIds)
                spreadUserIdStrings := spreadString(userIdStrings)
                query := fmt.Sprintf(
                        `SELECT user_id, total_score from ringo.scores WHERE user_id IN (%s) AND rank_period = %d;`,
                        spreadUserIdStrings,
                        rankPeriod.ToInt(),
                )
                rows, err := q(ctx, query, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("select scores: %w", err)
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                var result []*ranking.UserScorePair
                for rows.Next() </span><span class="cov0" title="0">{
                        var res ranking.UserScorePair
                        err = rows.StructScan(&amp;res)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("select scores: %w", err)
                        }</span>
                        <span class="cov0" title="0">result = append(result, &amp;res)</span>
                }
                <span class="cov0" title="0">return result, nil</span>
        }
}

func CreateUpsertScore(exec database.ExecFunc) ranking.UpsertScoreFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userScorePair []*ranking.UserScorePair, rankPeriod ranking.RankPeriod) error </span><span class="cov0" title="0">{
                type request struct {
                        UserId     core.UserId        `db:"user_id"`
                        TotalScore ranking.TotalScore `db:"total_score"`
                        RankPeriod ranking.RankPeriod `db:"rank_period"`
                }
                reqSet := utils.NewSet(userScorePair)
                req := utils.SetSelect(
                        reqSet, func(v *ranking.UserScorePair) *request </span><span class="cov0" title="0">{
                                return &amp;request{
                                        UserId:     v.UserId,
                                        TotalScore: v.TotalScore,
                                        RankPeriod: rankPeriod,
                                }
                        }</span>,
                )
                <span class="cov0" title="0">q := `INSERT INTO ringo.scores (user_id, total_score, rank_period) VALUES (:user_id, :total_score, :rank_period) ON DUPLICATE KEY UPDATE total_score = VALUES(total_score)`
                _, err := exec(
                        ctx,
                        q,
                        req.ToArray(),
                )
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("runned query: %s\n", q)
                        fmt.Printf("runned request: %+v\n", req.ToArray())
                        return fmt.Errorf("update score: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func CreateFetchUserPopularity(queryFunc database.QueryFunc) shelf.FetchUserPopularityFunc <span class="cov8" title="1">{
        f := CreateGetQuery[userReq, shelf.UserPopularity](
                queryFunc,
                "fetch user popularity: %w",
                `SELECT user_id, popularity FROM ringo.users WHERE user_id IN (:user_id)`,
        )
        return func(ctx context.Context, userIds []core.UserId) ([]*shelf.UserPopularity, error) </span><span class="cov8" title="1">{
                req := func() []*userReq </span><span class="cov8" title="1">{
                        result := make([]*userReq, len(userIds))
                        for i, v := range userIds </span><span class="cov8" title="1">{
                                result[i] = &amp;userReq{
                                        UserId: v,
                                }
                        }</span>
                        <span class="cov8" title="1">return result</span>
                }()
                <span class="cov8" title="1">res, err := f(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("fetch user popularity: %w", err)
                }</span>
                <span class="cov8" title="1">if len(res) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user popularity not found")
                }</span>
                <span class="cov8" title="1">return res, nil</span>
        }
}

func CreateUpdateUserPopularity(exec database.ExecFunc) shelf.UpdateUserPopularityFunc <span class="cov0" title="0">{
        return func(ctx context.Context, userPopularity []*shelf.UserPopularity) error </span><span class="cov0" title="0">{
                userIds := func() []core.UserId </span><span class="cov0" title="0">{
                        var result []core.UserId
                        for _, v := range userPopularity </span><span class="cov0" title="0">{
                                result = append(result, v.UserId)
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }()
                <span class="cov0" title="0">userIdString := infrastructure.UserIdsToString(userIds)
                spreadUserId := spreadString(userIdString)
                popularity := func() []string </span><span class="cov0" title="0">{
                        result := make([]string, len(userPopularity))
                        for i, v := range userPopularity </span><span class="cov0" title="0">{
                                result[i] = fmt.Sprintf(`%f`, v.Popularity)
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }()
                <span class="cov0" title="0">spreadPopularity := spreadString(popularity)

                _, err := exec(
                        ctx,
                        fmt.Sprintf(
                                `UPDATE ringo.users SET popularity = ELT(FIELD(user_id,%s),%s) WHERE user_id IN (%s)`,
                                spreadUserId,
                                spreadPopularity,
                                spreadUserId,
                        ),
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update popularity: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package initialize

import (
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/debug"
        "github.com/google/wire"
)

func provideChangeTime(timer *debug.Timer) debug.ChangeTimeInterface <span class="cov8" title="1">{
        return timer
}</span>

func provideGetCurrentTime(timer *debug.Timer) core.GetCurrentTimeFunc <span class="cov8" title="1">{
        return timer.EmitTime
}</span>

var commonSet = wire.NewSet(
        debug.NewTimer,
        provideChangeTime,
        provideGetCurrentTime,
)
</pre>
		
		<pre class="file" id="file104" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package initialize

import (
        "github.com/asragi/RinGo/admin"
        "github.com/asragi/RinGo/auth"
        "github.com/asragi/RinGo/core"
        "github.com/asragi/RinGo/core/game"
        "github.com/asragi/RinGo/core/game/explore"
        "github.com/asragi/RinGo/core/game/shelf"
        "github.com/asragi/RinGo/core/game/shelf/ranking"
        "github.com/asragi/RinGo/core/game/shelf/reservation"
        "github.com/asragi/RinGo/crypto"
        "github.com/asragi/RinGo/database"
        "github.com/asragi/RinGo/debug"
        "github.com/asragi/RinGo/endpoint"
        "github.com/asragi/RinGo/infrastructure/in_memory"
        "github.com/asragi/RinGo/infrastructure/mysql"
        "github.com/asragi/RinGo/tool"
        "github.com/asragi/RinGo/utils"
)

// Injectors from wire.go:

func CreateEndpoints(key auth.SecretHashKey, constants *Constants, exec database.ExecFunc, query database.QueryFunc) *endpoint.Endpoints <span class="cov8" title="1">{
        createUserIdChallengeNum := constants.UserIdChallengeNum
        checkDoesUserExist := mysql.CreateCheckUserExistence(query)
        generateUUIDFunc := _wireGenerateUUIDFuncValue
        createUserIdFunc := auth.CreateUserId(createUserIdChallengeNum, checkDoesUserExist, generateUUIDFunc)
        rowPasswordGenerator := _wireRowPasswordGeneratorValue
        createRowPasswordFunc := auth.GenerateRowPassword(rowPasswordGenerator)
        encryptFunc := _wireEncryptFuncValue
        createHashedPasswordFunc := auth.CreateHashedPassword(encryptFunc)
        fund := constants.InitialFund
        maxStamina := constants.InitialMaxStamina
        shopPopularity := constants.InitialPopularity
        timer := debug.NewTimer()
        getCurrentTimeFunc := provideGetCurrentTime(timer)
        insertNewUser := mysql.CreateInsertNewUser(exec, fund, maxStamina, shopPopularity, getCurrentTimeFunc)
        decideInitialName := core.CreateDecideInitialName()
        decideInitialShopName := core.CreateDecideInitialShopName()
        registerUserFunc := auth.RegisterUser(createUserIdFunc, createRowPasswordFunc, createHashedPasswordFunc, insertNewUser, decideInitialName, decideInitialShopName)
        insertEmptyShelfFunc := mysql.CreateInsertEmptyShelf(exec)
        initializeShelfFunc := shelf.CreateInitializeShelf(insertEmptyShelfFunc, generateUUIDFunc)
        registerEndpointFunc := endpoint.CreateRegisterEndpoint(registerUserFunc, initializeShelfFunc)
        fetchHashedPassword := mysql.CreateGetUserPassword(query)
        compareHashedPassword := _wireCompareHashedPasswordValue
        base64EncodeFunc := _wireBase64EncodeFuncValue
        structToJsonFunc := _wireStructToJsonFuncValue
        sha256Func := _wireSha256FuncValue
        createTokenFunc := auth.CreateTokenFuncEmitter(base64EncodeFunc, getCurrentTimeFunc, structToJsonFunc, key, sha256Func)
        loginFunc := auth.CreateLoginFunc(fetchHashedPassword, compareHashedPassword, createTokenFunc)
        loginEndpoint := endpoint.CreateLoginEndpoint(loginFunc)
        updateUserNameFunc := mysql.CreateUpdateUserName(exec)
        updateUserNameServiceFunc := core.CreateUpdateUserNameService(updateUserNameFunc)
        compareToken := auth.CreateCompareToken(key, sha256Func)
        base64DecodeFunc := _wireBase64DecodeFuncValue
        jsonToStructFunc := _wireJsonToStructFuncValue
        getTokenInformationFunc := auth.CreateGetTokenInformation(base64DecodeFunc, jsonToStructFunc)
        validateTokenFunc := auth.CreateValidateToken(compareToken, getTokenInformationFunc)
        updateUserNameEndpoint := endpoint.CreateUpdateUserNameEndpoint(updateUserNameServiceFunc, validateTokenFunc)
        updateShopNameFunc := mysql.CreateUpdateShopName(exec)
        updateShopNameServiceFunc := core.CreateUpdateShopNameService(updateShopNameFunc)
        updateShopNameEndpoint := endpoint.CreateUpdateShopNameEndpoint(updateShopNameServiceFunc, validateTokenFunc)
        getResourceFunc := mysql.CreateGetResourceMySQL(query)
        getUserResourceServiceFunc := explore.CreateGetUserResourceService(getResourceFunc)
        getResourceEndpoint := endpoint.CreateGetResourceEndpoint(getUserResourceServiceFunc, validateTokenFunc)
        fetchAllStorageFunc := mysql.CreateGetAllStorage(query)
        fetchItemMasterFunc := mysql.CreateGetItemMasterMySQL(query)
        getItemListFunc := game.CreateGetItemListService(fetchAllStorageFunc, fetchItemMasterFunc)
        getItemListEndpoint := endpoint.CreateGetItemService(getItemListFunc, validateTokenFunc)
        fetchStorageFunc := mysql.CreateGetStorage(query)
        fetchExploreMasterFunc := mysql.CreateGetExploreMasterMySQL(query)
        fetchItemExploreRelationFunc := mysql.CreateItemExploreRelation(query)
        fetchUserSkillFunc := mysql.CreateGetUserSkill(query)
        fetchReductionStaminaSkillFunc := mysql.CreateGetReductionSkill(query)
        calcConsumingStaminaFunc := game.CreateCalcConsumingStaminaService(fetchUserSkillFunc, fetchExploreMasterFunc, fetchReductionStaminaSkillFunc)
        getUserExploreFunc := mysql.CreateGetUserExplore(query)
        fetchRequiredSkillsFunc := mysql.CreateGetRequiredSkills(query)
        fetchConsumingItemFunc := mysql.CreateGetConsumingItem(query)
        generateMakeUserExploreArgs := game.CreateGenerateMakeUserExploreArgs(getResourceFunc, getUserExploreFunc, fetchRequiredSkillsFunc, fetchConsumingItemFunc, fetchStorageFunc, fetchUserSkillFunc, calcConsumingStaminaFunc, fetchExploreMasterFunc, getCurrentTimeFunc)
        makeUserExploreFunc := game.CreateMakeUserExplore(generateMakeUserExploreArgs)
        generateItemDetailArgsFunc := explore.CreateGenerateGetItemDetailArgs(fetchItemMasterFunc, fetchStorageFunc, fetchExploreMasterFunc, fetchItemExploreRelationFunc, calcConsumingStaminaFunc, makeUserExploreFunc)
        getItemDetailFunc := explore.CreateGetItemDetailService(generateItemDetailArgsFunc)
        getItemDetailEndpointFunc := endpoint.CreateGetItemDetail(getItemDetailFunc, validateTokenFunc)
        fetchEarningItemFunc := mysql.CreateGetEarningItem(query)
        fetchSkillMasterFunc := mysql.CreateGetSkillMaster(query)
        getCommonActionFunc := explore.CreateGetCommonActionDetail(calcConsumingStaminaFunc, fetchStorageFunc, fetchExploreMasterFunc, fetchEarningItemFunc, fetchConsumingItemFunc, fetchSkillMasterFunc, fetchUserSkillFunc, fetchRequiredSkillsFunc)
        getItemActionDetailFunc := explore.CreateGetItemActionDetailService(getCommonActionFunc, fetchItemMasterFunc)
        getItemActionDetailEndpoint := endpoint.CreateGetItemActionDetailEndpoint(getItemActionDetailFunc, validateTokenFunc)
        fetchShelf := mysql.CreateFetchShelfRepo(query)
        getShelfFunc := shelf.CreateGetShelves(fetchShelf, fetchItemMasterFunc, fetchStorageFunc)
        fetchReservationRepoFunc := mysql.CreateFetchReservation(query)
        deleteReservationRepoFunc := mysql.CreateDeleteReservation(exec)
        fetchUserPopularityFunc := mysql.CreateFetchUserPopularity(query)
        fetchFundFunc := mysql.CreateFetchFund(query)
        updateFundFunc := mysql.CreateUpdateFund(exec)
        updateUserPopularityFunc := mysql.CreateUpdateUserPopularity(exec)
        updateItemStorageFunc := mysql.CreateUpdateItemStorage(exec)
        updateShelfTotalSalesFunc := mysql.CreateUpdateTotalSales(exec)
        fetchUserScore := mysql.CreateFetchScore(query)
        fetchLatestRankPeriod := mysql.CreateFetchLatestRankPeriod(query)
        upsertScoreFunc := mysql.CreateUpsertScore(exec)
        updateTotalScoreServiceFunc := ranking.CreateUpdateTotalScoreService(fetchUserScore, fetchLatestRankPeriod, upsertScoreFunc)
        calcReservationApplicationFunc := _wireCalcReservationApplicationFuncValue
        applyReservationFunc := reservation.CreateApplyReservation(fetchReservationRepoFunc, deleteReservationRepoFunc, fetchItemMasterFunc, fetchStorageFunc, fetchUserPopularityFunc, fetchShelf, fetchFundFunc, updateFundFunc, updateUserPopularityFunc, updateItemStorageFunc, updateShelfTotalSalesFunc, updateTotalScoreServiceFunc, calcReservationApplicationFunc, getCurrentTimeFunc)
        getMyShelvesEndpointFunc := endpoint.CreateGetMyShelvesEndpoint(getShelfFunc, applyReservationFunc, validateTokenFunc)
        fetchAllUserId := mysql.CreateFetchAllUserId(query)
        applyAllReservationsFunc := reservation.CreateApplyAllReservations(fetchAllUserId, applyReservationFunc)
        fetchUserNameFunc := mysql.CreateFetchUserName(query)
        fetchUserDailyRankingRepo := mysql.CreateFetchDailyRanking(query)
        fetchUserDailyRanking := ranking.CreateFetchUserDailyRanking(fetchUserNameFunc, fetchUserDailyRankingRepo, fetchUserScore, fetchLatestRankPeriod, getShelfFunc)
        getRankingUserListEndpoint := endpoint.CreateGetRankingUserList(applyAllReservationsFunc, fetchUserDailyRanking)
        getAllStageFunc := _wireGetAllStageFuncValue
        fetchAllStageFunc := mysql.CreateGetAllStageMaster(query)
        fetchUserStageFunc := mysql.CreateGetUserStageData(query)
        fetchStageExploreRelation := mysql.CreateStageExploreRelation(query)
        fetchStageDataFunc := explore.CreateFetchStageData(fetchAllStageFunc, fetchUserStageFunc, fetchStageExploreRelation, makeUserExploreFunc)
        getStageListFunc := explore.CreateGetStageList(getAllStageFunc, fetchStageDataFunc)
        getStageListEndpointFunc := endpoint.CreateGetStageList(getStageListFunc, validateTokenFunc, getCurrentTimeFunc)
        fetchStageMasterFunc := mysql.CreateGetStageMaster(query)
        getStageActionDetailFunc := explore.CreateGetStageActionDetailService(getCommonActionFunc, fetchStageMasterFunc)
        getStageActionEndpointFunc := endpoint.CreateGetStageActionDetail(getStageActionDetailFunc, validateTokenFunc)
        fetchSkillGrowthData := mysql.CreateGetSkillGrowth(query)
        generatePostActionArgsFunc := game.CreateGeneratePostActionArgs(getResourceFunc, fetchExploreMasterFunc, fetchSkillMasterFunc, fetchSkillGrowthData, fetchUserSkillFunc, fetchEarningItemFunc, fetchConsumingItemFunc, fetchRequiredSkillsFunc, fetchStorageFunc, fetchItemMasterFunc, fetchReductionStaminaSkillFunc)
        calcSkillGrowthFunc := _wireCalcSkillGrowthFuncValue
        growthApplyFunc := _wireGrowthApplyFuncValue
        calcEarnedItemFunc := _wireCalcEarnedItemFuncValue
        calcConsumedItemFunc := _wireCalcConsumedItemFuncValue
        calcTotalItemFunc := _wireCalcTotalItemFuncValue
        calcStaminaReductionFunc := _wireCalcStaminaReductionFuncValue
        updateUserSkillExpFunc := mysql.CreateUpdateUserSkill(exec)
        updateStaminaFunc := mysql.CreateUpdateStamina(exec)
        emitRandomFunc := _wireEmitRandomFuncValue
        postActionFunc := game.CreatePostAction(generatePostActionArgsFunc, calcSkillGrowthFunc, growthApplyFunc, calcEarnedItemFunc, calcConsumedItemFunc, calcTotalItemFunc, calcStaminaReductionFunc, updateItemStorageFunc, updateUserSkillExpFunc, updateStaminaFunc, updateFundFunc, emitRandomFunc)
        postActionEndpointFunc := endpoint.CreatePostAction(postActionFunc, validateTokenFunc)
        updateShelfContentRepoFunc := mysql.CreateUpdateShelfContentRepo(exec)
        validateUpdateShelfContentFunc := _wireValidateUpdateShelfContentFuncValue
        updateShelfContentFunc := shelf.CreateUpdateShelfContent(fetchStorageFunc, fetchItemMasterFunc, fetchShelf, updateShelfContentRepoFunc, validateUpdateShelfContentFunc)
        fetchItemAttractionFunc := mysql.CreateFetchItemAttraction(query)
        createReservationFunc := _wireCreateReservationFuncValue
        insertReservationRepoFunc := mysql.CreateInsertReservation(exec)
        deleteReservationToShelfRepoFunc := mysql.CreateDeleteReservationToShelf(exec)
        updateCheckedTime := mysql.CreateUpdateCheckedTime(exec)
        insertReservationFunc := reservation.CreateInsertReservation(fetchItemAttractionFunc, fetchUserPopularityFunc, createReservationFunc, insertReservationRepoFunc, deleteReservationToShelfRepoFunc, updateCheckedTime, emitRandomFunc, getCurrentTimeFunc, generateUUIDFunc)
        updateShelfContentEndpointFunc := endpoint.CreateUpdateShelfContentEndpoint(updateShelfContentFunc, insertReservationFunc, validateTokenFunc)
        fetchSizeToActionRepoFunc := _wireFetchSizeToActionRepoFuncValue
        deleteShelfBySizeFunc := mysql.CreateDeleteShelfBySize(exec)
        validateUpdateShelfSizeFunc := _wireValidateUpdateShelfSizeFuncValue
        validateActionFunc := game.CreateValidateAction(getResourceFunc, fetchExploreMasterFunc, fetchConsumingItemFunc, fetchRequiredSkillsFunc, fetchUserSkillFunc, fetchStorageFunc, getCurrentTimeFunc)
        updateShelfSizeFunc := shelf.CreateUpdateShelfSize(fetchShelf, fetchSizeToActionRepoFunc, insertEmptyShelfFunc, deleteShelfBySizeFunc, postActionFunc, validateUpdateShelfSizeFunc, validateActionFunc, generateUUIDFunc)
        updateShelfSizeEndpoint := endpoint.CreateUpdateShelfSizeEndpoint(updateShelfSizeFunc, validateTokenFunc)
        insertWinRepo := mysql.CreateInsertWin(exec)
        insertRankPeriodRepo := mysql.CreateInsertRankPeriod(exec)
        onChangePeriodFunc := ranking.CreateOnChangePeriod(fetchUserDailyRanking, insertWinRepo, fetchLatestRankPeriod, insertRankPeriodRepo)
        checkIsAdminRepo := mysql.CreateCheckIsAdmin(query)
        checkIsAdminFunc := admin.CreateCheckIsAdmin(checkIsAdminRepo)
        changePeriodEndpoint := endpoint.CreateChangePeriod(onChangePeriodFunc, validateTokenFunc, checkIsAdminFunc)
        adminFetchHashedPassword := mysql.CreateFetchAdminHashedPassword(query)
        createCommonLoginFunc := _wireCreateCommonLoginFuncValue
        adminLoginFunc := admin.CreateLogin(adminFetchHashedPassword, compareHashedPassword, createTokenFunc, createCommonLoginFunc)
        adminLoginEndpoint := endpoint.CreateAdminLoginEndpoint(adminLoginFunc)
        fetchCheckedTimeFunc := mysql.CreateFetchCheckedTime(query)
        batchInsertReservationFunc := reservation.CreateBatchInsertReservation(fetchItemMasterFunc, fetchShelf, fetchItemAttractionFunc, fetchUserPopularityFunc, createReservationFunc, insertReservationRepoFunc, fetchCheckedTimeFunc, updateCheckedTime, emitRandomFunc, generateUUIDFunc, getCurrentTimeFunc)
        autoInsertReservationFunc := reservation.CreateAutoInsertReservation(fetchAllUserId, batchInsertReservationFunc)
        autoInsertReservationEndpoint := endpoint.CreateAutoInsertReservationEndpoint(autoInsertReservationFunc, validateTokenFunc, checkIsAdminFunc)
        changeTimeInterface := provideChangeTime(timer)
        changeTimeEndpointFunc := endpoint.CreateChangeTimeEndpoint(changeTimeInterface, validateTokenFunc, checkIsAdminFunc)
        endpoints := &amp;endpoint.Endpoints{
                SignUp:                registerEndpointFunc,
                Login:                 loginEndpoint,
                UpdateUserName:        updateUserNameEndpoint,
                UpdateShopName:        updateShopNameEndpoint,
                GetResource:           getResourceEndpoint,
                GetItemList:           getItemListEndpoint,
                GetItemDetail:         getItemDetailEndpointFunc,
                GetItemActionDetail:   getItemActionDetailEndpoint,
                GetMyShelves:          getMyShelvesEndpointFunc,
                GetRankingUserList:    getRankingUserListEndpoint,
                GetStageList:          getStageListEndpointFunc,
                GetStageActionDetail:  getStageActionEndpointFunc,
                PostAction:            postActionEndpointFunc,
                UpdateShelfContent:    updateShelfContentEndpointFunc,
                UpdateShelfSize:       updateShelfSizeEndpoint,
                ChangePeriod:          changePeriodEndpoint,
                AdminLogin:            adminLoginEndpoint,
                AutoInsertReservation: autoInsertReservationEndpoint,
                ChangeTime:            changeTimeEndpointFunc,
        }
        return endpoints
}</span>

var (
        _wireGenerateUUIDFuncValue               = core.GenerateUUIDFunc(utils.GenerateUUID)
        _wireRowPasswordGeneratorValue           = auth.RowPasswordGenerator(utils.GenerateUUID)
        _wireEncryptFuncValue                    = auth.EncryptFunc(crypto.Encrypt)
        _wireCompareHashedPasswordValue          = auth.CompareHashedPassword(crypto.Compare)
        _wireBase64EncodeFuncValue               = auth.Base64EncodeFunc(auth.StringToBase64)
        _wireStructToJsonFuncValue               = utils.StructToJsonFunc[auth.AccessTokenInformation](utils.StructToJson[auth.AccessTokenInformation])
        _wireSha256FuncValue                     = auth.Sha256Func(auth.CryptWithSha256)
        _wireBase64DecodeFuncValue               = auth.Base64DecodeFunc(auth.Base64ToString)
        _wireJsonToStructFuncValue               = utils.JsonToStructFunc[auth.AccessTokenInformationFromJson](utils.JsonToStruct[auth.AccessTokenInformationFromJson])
        _wireCalcReservationApplicationFuncValue = reservation.CalcReservationApplicationFunc(reservation.CalcReservationApplication)
        _wireGetAllStageFuncValue                = explore.GetAllStageFunc(explore.GetAllStage)
        _wireCalcSkillGrowthFuncValue            = game.CalcSkillGrowthFunc(game.CalcSkillGrowthService)
        _wireGrowthApplyFuncValue                = game.GrowthApplyFunc(game.CalcApplySkillGrowth)
        _wireCalcEarnedItemFuncValue             = game.CalcEarnedItemFunc(game.CalcEarnedItem)
        _wireCalcConsumedItemFuncValue           = game.CalcConsumedItemFunc(game.CalcConsumedItem)
        _wireCalcTotalItemFuncValue              = game.CalcTotalItemFunc(game.CalcTotalItem)
        _wireCalcStaminaReductionFuncValue       = game.CalcStaminaReductionFunc(game.CalcStaminaReduction)
        _wireEmitRandomFuncValue                 = core.EmitRandomFunc(core.EmitRandom)
        _wireValidateUpdateShelfContentFuncValue = shelf.ValidateUpdateShelfContentFunc(shelf.ValidateUpdateShelfContent)
        _wireCreateReservationFuncValue          = reservation.CreateReservationFunc(reservation.CreateReservation)
        _wireFetchSizeToActionRepoFuncValue      = shelf.FetchSizeToActionRepoFunc(in_memory.FetchSizeToActionRepoInMemory)
        _wireValidateUpdateShelfSizeFuncValue    = shelf.ValidateUpdateShelfSizeFunc(shelf.ValidateUpdateShelfSize)
        _wireCreateCommonLoginFuncValue          = admin.CreateCommonLoginFunc(auth.CreateLoginFunc)
)

func CreateTools(exec database.ExecFunc) *tool.Tools <span class="cov8" title="1">{
        registerRepo := mysql.CreateRegisterAdmin(exec)
        encryptFunc := _wireEncryptFuncValue
        createHashedPasswordFunc := auth.CreateHashedPassword(encryptFunc)
        registerFunc := admin.CreateRegister(registerRepo, createHashedPasswordFunc)
        tools := &amp;tool.Tools{
                RegisterAdmin: registerFunc,
        }
        return tools
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package location

import "time"

var utc *time.Location

func init() <span class="cov8" title="1">{
        utc = time.FixedZone("UTC", 0)
}</span>

func UTC() *time.Location <span class="cov8" title="1">{
        return utc
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">package server

import (
        "fmt"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"
        "net"
)

type Serve func() error
type StopDBFunc func()
type RegisterServer func(grpc.ServiceRegistrar)

func NewRPCServer(port int, registerOption RegisterServer) (Serve, StopDBFunc, error) <span class="cov8" title="1">{
        var stopDB StopDBFunc
        handleError := func(err error) (Serve, StopDBFunc, error) </span><span class="cov0" title="0">{
                return nil, stopDB, fmt.Errorf("new rpc server: %w", err)
        }</span>
        <span class="cov8" title="1">listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err)
        }</span>
        <span class="cov8" title="1">s := grpc.NewServer()
        stopDB = s.GracefulStop
        registerOption(s)
        // TODO: for debug
        reflection.Register(s)

        serve := func() error </span><span class="cov8" title="1">{
                return s.Serve(listener)
        }</span>
        <span class="cov8" title="1">return serve, stopDB, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package server

import (
        "context"
        "github.com/asragi/RinGo/debug"
        "github.com/asragi/RinGo/endpoint"
        "github.com/asragi/RingoSuPBGo/gateway"
        "google.golang.org/grpc"
)

func parseArgs() *debug.RunMode <span class="cov0" title="0">{
        return debug.NewRunMode()
}</span>

type gRPCServer struct {
        gateway.UnimplementedRingoServer
        gateway.UnimplementedChangePeriodServer
        gateway.UnimplementedDebugTimeServer
        gateway.UnimplementedInvokeAutoApplyReservationServer
        endpoints *endpoint.Endpoints
}

func newGrpcServer(endpoints *endpoint.Endpoints) *gRPCServer <span class="cov8" title="1">{
        return &amp;gRPCServer{endpoints: endpoints}
}</span>

func (s *gRPCServer) SignUp(
        ctx context.Context,
        req *gateway.SignUpRequest,
) (*gateway.SignUpResponse, error) <span class="cov8" title="1">{
        return s.endpoints.SignUp(ctx, req)
}</span>

func (s *gRPCServer) Login(
        ctx context.Context,
        req *gateway.LoginRequest,
) (*gateway.LoginResponse, error) <span class="cov8" title="1">{
        return s.endpoints.Login(ctx, req)
}</span>

func (s *gRPCServer) GetResource(
        ctx context.Context,
        req *gateway.GetResourceRequest,
) (*gateway.GetResourceResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetResource(ctx, req)
}</span>

func (s *gRPCServer) UpdateUserName(
        ctx context.Context,
        req *gateway.UpdateUserNameRequest,
) (*gateway.UpdateUserNameResponse, error) <span class="cov8" title="1">{
        return s.endpoints.UpdateUserName(ctx, req)
}</span>

func (s *gRPCServer) UpdateShopName(
        ctx context.Context,
        req *gateway.UpdateShopNameRequest,
) (*gateway.UpdateShopNameResponse, error) <span class="cov8" title="1">{
        return s.endpoints.UpdateShopName(ctx, req)
}</span>

func (s *gRPCServer) GetMyShelf(
        ctx context.Context,
        req *gateway.GetMyShelfRequest,
) (*gateway.GetMyShelfResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetMyShelves(ctx, req)
}</span>

func (s *gRPCServer) GetStageList(
        ctx context.Context,
        req *gateway.GetStageListRequest,
) (*gateway.GetStageListResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetStageList(ctx, req)
}</span>

func (s *gRPCServer) GetStageActionDetail(
        ctx context.Context,
        req *gateway.GetStageActionDetailRequest,
) (*gateway.GetStageActionDetailResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetStageActionDetail(ctx, req)
}</span>

func (s *gRPCServer) PostAction(
        ctx context.Context,
        req *gateway.PostActionRequest,
) (*gateway.PostActionResponse, error) <span class="cov8" title="1">{
        return s.endpoints.PostAction(ctx, req)
}</span>

func (s *gRPCServer) GetItemList(
        ctx context.Context,
        req *gateway.GetItemListRequest,
) (*gateway.GetItemListResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetItemList(ctx, req)
}</span>

func (s *gRPCServer) GetItemDetail(
        ctx context.Context,
        req *gateway.GetItemDetailRequest,
) (*gateway.GetItemDetailResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetItemDetail(ctx, req)
}</span>

func (s *gRPCServer) GetItemActionDetail(
        ctx context.Context,
        req *gateway.GetItemActionDetailRequest,
) (*gateway.GetItemActionDetailResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetItemActionDetail(ctx, req)
}</span>

func (s *gRPCServer) UpdateShelfContent(
        ctx context.Context,
        req *gateway.UpdateShelfContentRequest,
) (*gateway.UpdateShelfContentResponse, error) <span class="cov8" title="1">{
        return s.endpoints.UpdateShelfContent(ctx, req)
}</span>

func (s *gRPCServer) UpdateShelfSize(
        ctx context.Context,
        req *gateway.UpdateShelfSizeRequest,
) (*gateway.UpdateShelfSizeResponse, error) <span class="cov8" title="1">{
        return s.endpoints.UpdateShelfSize(ctx, req)
}</span>

func (s *gRPCServer) GetDailyRanking(
        ctx context.Context,
        req *gateway.GetDailyRankingRequest,
) (*gateway.GetDailyRankingResponse, error) <span class="cov8" title="1">{
        return s.endpoints.GetRankingUserList(ctx, req)
}</span>

func (s *gRPCServer) AdminLogin(
        ctx context.Context,
        req *gateway.AdminLoginRequest,
) (*gateway.AdminLoginResponse, error) <span class="cov8" title="1">{
        return s.endpoints.AdminLogin(ctx, req)
}</span>

func (s *gRPCServer) ChangePeriod(
        ctx context.Context,
        req *gateway.ChangePeriodRequest,
) (*gateway.ChangePeriodResponse, error) <span class="cov8" title="1">{
        return s.endpoints.ChangePeriod(ctx, req)
}</span>

func (s *gRPCServer) InvokeAutoApplyReservation(
        ctx context.Context,
        req *gateway.InvokeAutoApplyReservationRequest,
) (*gateway.InvokeAutoApplyReservationResponse, error) <span class="cov0" title="0">{
        return s.endpoints.AutoInsertReservation(ctx, req)
}</span>

func (s *gRPCServer) ChangeTime(
        ctx context.Context,
        req *gateway.ChangeTimeRequest,
) (*gateway.ChangeTimeResponse, error) <span class="cov8" title="1">{
        return s.endpoints.ChangeTime(ctx, req)
}</span>

func SetUpServer(port int, endpoints *endpoint.Endpoints) (Serve, StopDBFunc, error) <span class="cov8" title="1">{
        grpcServer := newGrpcServer(endpoints)
        registerServer := func(s grpc.ServiceRegistrar) </span><span class="cov8" title="1">{
                gateway.RegisterRingoServer(s, grpcServer)
                gateway.RegisterChangePeriodServer(s, grpcServer)
                gateway.RegisterDebugTimeServer(s, grpcServer)
                gateway.RegisterInvokeAutoApplyReservationServer(s, grpcServer)
        }</span>
        <span class="cov8" title="1">return NewRPCServer(port, registerServer)</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package test

import (
        "fmt"
        "github.com/jmoiron/sqlx"
        "github.com/ory/dockertest/v3"
        "os"
)

type PurgePool func() error

func CreateTestDB(
        imageName string,
        dockerfilePath string,
) (*sqlx.DB, PurgePool, error) <span class="cov8" title="1">{
        handleError := func(text string, err error) (*sqlx.DB, PurgePool, error) </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf(text, err)
        }</span>
        // uses a sensible default on windows (tcp/http) and linux/osx (socket)
        <span class="cov8" title="1">pool, err := dockertest.NewPool("")
        if err != nil </span><span class="cov0" title="0">{
                return handleError("Could not construct pool: %w", err)
        }</span>

        // uses pool to try to connect to Docker
        <span class="cov8" title="1">err = pool.Client.Ping()
        if err != nil </span><span class="cov0" title="0">{
                return handleError("Could not connect to Docker: %w", err)
        }</span>

        // pulls an image, creates a container based on it and runs it
        <span class="cov8" title="1">resource, err := pool.BuildAndRun(imageName, dockerfilePath, []string{})
        if err != nil </span><span class="cov0" title="0">{
                return handleError("Could not start resource: %w", err)
        }</span>
        /*
                if err = resource.Expire(20); err != nil {
                        return handleError("Could not set expiration time: %w", err)
                }
        */

        <span class="cov8" title="1">var db *sqlx.DB
        host := os.Getenv("DOCKER_TEST_DB_HOST")
        if host == "" </span><span class="cov0" title="0">{
                host = "localhost"
        }</span>
        // exponential backoff-retry, because the application in the container might not be ready to accept connections yet
        <span class="cov8" title="1">if err = pool.Retry(
                func() error </span><span class="cov8" title="1">{
                        db, err = sqlx.Open(
                                "mysql",
                                fmt.Sprintf("root:ringo@(%s:%s)/mysql?parseTime=true", host, resource.GetPort("3306/tcp")),
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return db.Ping()</span>
                },
        ); err != nil <span class="cov0" title="0">{
                return handleError("Could not connect to database: %w", err)
        }</span>

        <span class="cov8" title="1">stopPool := func() error </span><span class="cov0" title="0">{
                return pool.Purge(resource)
        }</span>
        <span class="cov8" title="1">return db, stopPool, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package test

import (
        "context"
        "github.com/asragi/RinGo/location"
        "reflect"
        "time"
)

func MockEmitRandom() float32 <span class="cov8" title="1">{
        return 0.5
}</span>

func MockCreateContext() context.Context <span class="cov8" title="1">{
        return context.Background()
}</span>

func MockTransaction(ctx context.Context, f func(context.Context) error) error <span class="cov0" title="0">{
        return f(ctx)
}</span>

func MockTime() time.Time <span class="cov8" title="1">{
        return time.Unix(100000, 0).In(location.UTC())
}</span>

func DeepEqual(a any, b any) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(a, b)
}</span>

func ErrorToString(err error) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return "{nil}"
        }</span>
        <span class="cov0" title="0">return err.Error()</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package utils

import "context"

type CreateContextFunc func() context.Context

// CreateContext is wrapper for creating Context
func CreateContext() context.Context <span class="cov0" title="0">{
        return context.Background()
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
)

type JsonToStructFunc[S any] func(json string) (*S, error)

func JsonToStruct[S any](jsonString string) (*S, error) <span class="cov8" title="1">{
        var targetStruct S
        err := json.Unmarshal([]byte(jsonString), &amp;targetStruct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal json: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;targetStruct, nil</span>
}

type StructToJsonFunc[S any] func(*S) (*string, error)

func StructToJson[S any](obj *S) (*string, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(*obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("struct to json: %w", err)
        }</span>
        <span class="cov8" title="1">jsonString := string(jsonData)
        return &amp;jsonString, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package utils

func Clamp(value, min, max float64) float64 <span class="cov8" title="1">{
        if value &lt; min </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">if value &gt; max </span><span class="cov8" title="1">{
                return max
        }</span>
        <span class="cov8" title="1">return value</span>
}

func AlmostEqual(a, b, epsilon float64) bool <span class="cov0" title="0">{
        return a+epsilon &gt; b &amp;&amp; a-epsilon &lt; b
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package utils

type Set[S any] struct {
        data []S
}

func NewSet[S any](data []S) *Set[S] <span class="cov8" title="1">{
        return &amp;Set[S]{data: data}
}</span>

func SetToMap[T comparable, S any](set *Set[S], generateKey func(S) T) map[T]S <span class="cov8" title="1">{
        m := make(map[T]S)
        for _, v := range set.data </span><span class="cov8" title="1">{
                key := generateKey(v)
                m[key] = v
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (s *Set[S]) Find(search func(S) bool) S <span class="cov8" title="1">{
        for _, v := range s.data </span><span class="cov8" title="1">{
                if search(v) </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov0" title="0">return *new(S)</span>
}

func (s *Set[S]) Length() int <span class="cov8" title="1">{
        return len(s.data)
}</span>

func (s *Set[S]) Get(index int) S <span class="cov8" title="1">{
        return s.data[index]
}</span>

func SetSelect[S any, T any](data *Set[S], f func(S) T) *Set[T] <span class="cov0" title="0">{
        var result []T
        for _, v := range data.data </span><span class="cov0" title="0">{
                result = append(result, f(v))
        }</span>
        <span class="cov0" title="0">return NewSet(result)</span>
}

func (s *Set[S]) Filter(f func(S) bool) *Set[S] <span class="cov0" title="0">{
        var result []S
        for _, v := range s.data </span><span class="cov0" title="0">{
                if f(v) </span><span class="cov0" title="0">{
                        result = append(result, v)
                }</span>
        }
        <span class="cov0" title="0">return NewSet(result)</span>
}

func (s *Set[S]) Foreach(f func(int, S)) <span class="cov0" title="0">{
        for i, v := range s.data </span><span class="cov0" title="0">{
                f(i, v)
        }</span>
}

func (s *Set[S]) ToArray() []S <span class="cov0" title="0">{
        return s.data
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">package utils

import "time"

func StringToTime(utcTime string) (time.Time, error) <span class="cov0" title="0">{
        const layout = "2006-01-02 15:04:05"
        t, err := time.Parse(layout, utcTime)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return t, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package utils

func ToObjArray[T any](pointers []*T) []T <span class="cov0" title="0">{
        var result []T
        for _, p := range pointers </span><span class="cov0" title="0">{
                result = append(result, *p)
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package utils

import "github.com/google/uuid"

func GenerateUUID() string <span class="cov8" title="1">{
        uuidObj, _ := uuid.NewUUID()
        return uuidObj.String()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
